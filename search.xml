<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[机器学习算法实践-树回归]]></title>
      <url>http://pytlab.github.io/2017/11/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5-%E6%A0%91%E5%9B%9E%E5%BD%92/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近由于开始要把精力集中在课题的应用上面了，这篇总结之后算法原理的学习先告一段落。本文主要介绍决策树用于回归问题的相关算法实现，其中包括回归树(regression tree)和模型树(model tree)的实现，并介绍了预剪枝(preprune)和后剪枝(postprune)的防止树过拟合的技术以及实现。最后对回归树和标准线性回归进行了对比。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在之前的文章中我总结了通过使用构建决策树来进行类型预测。直观来看树结构最容易对分类问题进行处理，通过递归我们在数据中选取最佳分割特征对训练数据进行分割并进行树分裂最终到达触底条件获得训练出来决策树，可以通过可视化的方式直观的查看训练模型并对数据进行分类。</p>
<a id="more"></a>
<p>通常决策树树分裂选择特征的方法有ID3, C4.5算法, C5.0算法和CART树。在《<a href="http://pytlab.github.io/2017/07/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5-%E5%86%B3%E7%AD%96%E6%A0%91/">机器学习算法实践-决策树(Decision Tree)</a>》中对ID3以及C4.5算法进行了介绍并使用ID3算法处理了分类问题。本文主要使用决策树解决回归问题，使用CART(Classification And Regression Trees)算法。</p>
<h3 id="CART"><a href="#CART" class="headerlink" title="CART"></a>CART</h3><p>CART是一种二分递归分割的技术，分割方法采用基于最小距离的基尼指数估计函数，将当前的样本集分为两个子样本集，使得生成的的每个非叶子节点都有两个分支。因此，CART算法生成的决策树是结构简洁的二叉树。</p>
<p>分类树是针对目标变量是离散型变量，通过二叉树将数据进行分割成离散类的方法。而回归树则是针对目标变量是连续性的变量，通过选取最优分割特征的某个值，然后数据根据大于或者小于这个值进行划分进行树分裂最终生成回归树。</p>
<h3 id="特征和最佳分割点的选取"><a href="#特征和最佳分割点的选取" class="headerlink" title="特征和最佳分割点的选取"></a>特征和最佳分割点的选取</h3><p>在使用决策树解决回归问题中我们需要不断的选取某一特征的一个值作为分割点来生成子树。选取的标准就是使得被分割的两部分数据能有最好的纯度。</p>
<ul>
<li>对于离散型数据我们可以通过计算分割两部分数据的基尼不纯度的变化来判定最有分割点；</li>
<li>对于连续性变量我们通过计算最小平方残差，也就是选择使得分割后数据方差变得最小的特征和分割点。直观的理解就是使得分割的两部分数据能够有最相近的值。</li>
</ul>
<h3 id="树分裂的终止条件"><a href="#树分裂的终止条件" class="headerlink" title="树分裂的终止条件"></a>树分裂的终止条件</h3><p>有了选取分割特征和最佳分割点的方法，树便可以依此进行分裂，但是分裂的终止条件是什么呢?</p>
<ol>
<li><strong>节点中所有目标变量的值相同</strong>, 既然都已经是相同的值了自然没有必要在分裂了，直接返回这个值就好了.</li>
<li>树的深度达到了预先指定的最大值</li>
<li><strong>不纯度的减小量小于预先定好的阈值</strong>,也就是之进一步的分割数据并不能更好的降低数据的不纯度的时候就可以停止树分裂了。</li>
<li>节点的数据量小于预先定好的阈值</li>
</ol>
<h3 id="回归树的Python实现"><a href="#回归树的Python实现" class="headerlink" title="回归树的Python实现"></a>回归树的Python实现</h3><p>本部分使用Python实现简单的回归树，并对给定的数据进行回归并可视化回归曲线和树结构。完整代码详见: <a href="https://github.com/PytLab/MLBox/tree/master/classification_and_regression_trees" target="_blank" rel="external">https://github.com/PytLab/MLBox/tree/master/classification_and_regression_trees</a></p>
<p>首先是加载数据的部分，这里的所有测试数据我均使用的《Machine Learning in Action》中的数据，格式比较规整加载方式也比较一致, 这里由于做树回归，自变量和因变量都放在同一个二维数组中:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">(filename)</span>:</span></div><div class="line">    <span class="string">''' 加载文本文件中的数据.</span></div><div class="line">    '''</div><div class="line">    dataset = []</div><div class="line">    <span class="keyword">with</span> open(filename, <span class="string">'r'</span>) <span class="keyword">as</span> f:</div><div class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</div><div class="line">            line_data = [float(data) <span class="keyword">for</span> data <span class="keyword">in</span> line.split()]</div><div class="line">            dataset.append(line_data)</div><div class="line">    <span class="keyword">return</span> dataset</div></pre></td></tr></table></figure></p>
<p>树回归中再找到分割特征和分割值之后需要将数据进行划分以便构建子树或者叶子节点:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_dataset</span><span class="params">(dataset, feat_idx, value)</span>:</span></div><div class="line">    <span class="string">''' 根据给定的特征编号和特征值对数据集进行分割</span></div><div class="line">    '''</div><div class="line">    ldata, rdata = [], []</div><div class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> dataset:</div><div class="line">        <span class="keyword">if</span> data[feat_idx] &lt; value:</div><div class="line">            ldata.append(data)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            rdata.append(data)</div><div class="line">    <span class="keyword">return</span> ldata, rdata</div></pre></td></tr></table></figure>
<p>然后就是重要的选取最佳分割特征和分割值了，这里我们通过找打使得分割后的方差最小的分割点最为最佳分割点:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose_best_feature</span><span class="params">(dataset, fleaf, ferr, opt)</span>:</span></div><div class="line">    <span class="string">''' 选取最佳分割特征和特征值</span></div><div class="line"></div><div class="line">    dataset: 待划分的数据集</div><div class="line">    fleaf: 创建叶子节点的函数</div><div class="line">    ferr: 计算数据误差的函数</div><div class="line">    opt: 回归树参数.</div><div class="line">        err_tolerance: 最小误差下降值;</div><div class="line">        n_tolerance: 数据切分最小样本数</div><div class="line">    '''</div><div class="line">    dataset = np.array(dataset)</div><div class="line">    m, n = dataset.shape</div><div class="line">    err_tolerance, n_tolerance = opt[<span class="string">'err_tolerance'</span>], opt[<span class="string">'n_tolerance'</span>]</div><div class="line"></div><div class="line">    err = ferr(dataset)</div><div class="line">    best_feat_idx, best_feat_val, best_err = <span class="number">0</span>, <span class="number">0</span>, float(<span class="string">'inf'</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 遍历所有特征</span></div><div class="line">    <span class="keyword">for</span> feat_idx <span class="keyword">in</span> range(n<span class="number">-1</span>):</div><div class="line">        values = dataset[:, feat_idx]</div><div class="line">        <span class="comment"># 遍历所有特征值</span></div><div class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> values:</div><div class="line">            <span class="comment"># 按照当前特征和特征值分割数据</span></div><div class="line">            ldata, rdata = split_dataset(dataset.tolist(), feat_idx, val)</div><div class="line">            <span class="keyword">if</span> len(ldata) &lt; n_tolerance <span class="keyword">or</span> len(rdata) &lt; n_tolerance:</div><div class="line">                <span class="comment"># 如果切分的样本量太小</span></div><div class="line">                <span class="keyword">continue</span></div><div class="line"></div><div class="line">            <span class="comment"># 计算误差</span></div><div class="line">            new_err = ferr(ldata) + ferr(rdata)</div><div class="line">            <span class="keyword">if</span> new_err &lt; best_err:</div><div class="line">                best_feat_idx = feat_idx</div><div class="line">                best_feat_val = val</div><div class="line">                best_err = new_err</div><div class="line"></div><div class="line">    <span class="comment"># 如果误差变化并不大归为一类</span></div><div class="line">    <span class="keyword">if</span> abs(err - best_err) &lt; err_tolerance:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">None</span>, fleaf(dataset)</div><div class="line"></div><div class="line">    <span class="comment"># 检查分割样本量是不是太小</span></div><div class="line">    ldata, rdata = split_dataset(dataset.tolist(), best_feat_idx, best_feat_val)</div><div class="line">    <span class="keyword">if</span> len(ldata) &lt; n_tolerance <span class="keyword">or</span> len(rdata) &lt; n_tolerance:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">None</span>, fleaf(dataset)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> best_feat_idx, best_feat_val</div></pre></td></tr></table></figure></p>
<p>其中，停止选取的条件有两个: 一个是当分割的子数据集的大小小于一定值；一个是当选取的最佳分割点分割的数据的方差减小量小于一定的值。</p>
<p><code>fleaf</code>是创建叶子节点的函数引用，不同的树结构此函数也是不同的，例如本部分的回归树，创建叶子节点就是根据分割后的数据集平均值，而对于模型树来说，此函数返回值是根据数据集得到的回归系数。<code>ferr</code>是计算数据集不纯度的函数，不同的树模型该函数也会不同，对于回归树，此函数计算数据集的方差来判定数据集的纯度，而对于模型树来说我们需要计算线性模型拟合程度也就是线性模型的残差平方和。</p>
<p>然后就是最主要的回归树的生成函数了，树结构肯定需要通过递归创建的，选不出新的分割点的时候就触底：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_tree</span><span class="params">(dataset, fleaf, ferr, opt=None)</span>:</span></div><div class="line">    <span class="string">''' 递归创建树结构</span></div><div class="line"></div><div class="line">    dataset: 待划分的数据集</div><div class="line">    fleaf: 创建叶子节点的函数</div><div class="line">    ferr: 计算数据误差的函数</div><div class="line">    opt: 回归树参数.</div><div class="line">        err_tolerance: 最小误差下降值;</div><div class="line">        n_tolerance: 数据切分最小样本数</div><div class="line">    '''</div><div class="line">    <span class="keyword">if</span> opt <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        opt = &#123;<span class="string">'err_tolerance'</span>: <span class="number">1</span>, <span class="string">'n_tolerance'</span>: <span class="number">4</span>&#125;</div><div class="line"></div><div class="line">    <span class="comment"># 选择最优化分特征和特征值</span></div><div class="line">    feat_idx, value = choose_best_feature(dataset, fleaf, ferr, opt)</div><div class="line">    </div><div class="line">    <span class="comment"># 触底条件</span></div><div class="line">    <span class="keyword">if</span> feat_idx <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">return</span> value</div><div class="line"></div><div class="line">    <span class="comment"># 创建回归树</span></div><div class="line">    tree = &#123;<span class="string">'feat_idx'</span>: feat_idx, <span class="string">'feat_val'</span>: value&#125;</div><div class="line"></div><div class="line">    <span class="comment"># 递归创建左子树和右子树</span></div><div class="line">    ldata, rdata = split_dataset(dataset, feat_idx, value)</div><div class="line">    ltree = create_tree(ldata, fleaf, ferr, opt)</div><div class="line">    rtree = create_tree(rdata, fleaf, ferr, opt)</div><div class="line">    tree[<span class="string">'left'</span>] = ltree</div><div class="line">    tree[<span class="string">'right'</span>] = rtree</div><div class="line"></div><div class="line">    <span class="keyword">return</span> tree</div></pre></td></tr></table></figure></p>
<h3 id="使用回归树对数据进行回归"><a href="#使用回归树对数据进行回归" class="headerlink" title="使用回归树对数据进行回归"></a>使用回归树对数据进行回归</h3><p>这里使用了现成的分段数据作为训练数据生成回归树，本文所有使用的数据详见: <a href="https://github.com/PytLab/MLBox/tree/master/classification_and_regression_trees" target="_blank" rel="external">https://github.com/PytLab/MLBox/tree/master/classification_and_regression_trees</a></p>
<h4 id="可视化数据点"><a href="#可视化数据点" class="headerlink" title="可视化数据点"></a>可视化数据点</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dataset = load_data(<span class="string">'ex0.txt'</span>)</div><div class="line">dataset = np.array(dataset)</div><div class="line"><span class="comment"># 绘制散点</span></div><div class="line">plt.scatter(dataset[:, <span class="number">0</span>], dataset[:, <span class="number">1</span>])</div></pre></td></tr></table></figure>
<p><img src="/assets/images/blog_img/2017-11-03-机器学习算法实践-树回归/ex0_data.png" alt=""></p>
<h4 id="创建回归树并可视化"><a href="#创建回归树并可视化" class="headerlink" title="创建回归树并可视化"></a>创建回归树并可视化</h4><p>看到这种分段的数据，回归树拟合它可是最合适不过了，我们创建回归树:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tree = create_tree(dataset, fleaf, ferr, opt=&#123;<span class="string">'n_tolerance'</span>: <span class="number">4</span>,</div><div class="line">                                              <span class="string">'err_tolerance'</span>: <span class="number">1</span>&#125;)</div></pre></td></tr></table></figure></p>
<p>通过Python字典表示的回归树结构:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="string">'feat_idx'</span>: <span class="number">0</span>,</div><div class="line"> <span class="string">'feat_val'</span>: <span class="number">0.40015800000000001</span>,</div><div class="line"> <span class="string">'left'</span>: &#123;<span class="string">'feat_idx'</span>: <span class="number">0</span>,</div><div class="line">          <span class="string">'feat_val'</span>: <span class="number">0.20819699999999999</span>,</div><div class="line">          <span class="string">'left'</span>: <span class="number">-0.023838155555555553</span>,</div><div class="line">          <span class="string">'right'</span>: <span class="number">1.0289583666666666</span>&#125;,</div><div class="line"> <span class="string">'right'</span>: &#123;<span class="string">'feat_idx'</span>: <span class="number">0</span>,</div><div class="line">           <span class="string">'feat_val'</span>: <span class="number">0.609483</span>,</div><div class="line">           <span class="string">'left'</span>: <span class="number">1.980035071428571</span>,</div><div class="line">           <span class="string">'right'</span>: &#123;<span class="string">'feat_idx'</span>: <span class="number">0</span>,</div><div class="line">                     <span class="string">'feat_val'</span>: <span class="number">0.81674199999999997</span>,</div><div class="line">                     <span class="string">'left'</span>: <span class="number">2.9836209534883724</span>,</div><div class="line">                     <span class="string">'right'</span>: <span class="number">3.9871631999999999</span>&#125;&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>这里我还是使用Graphviz来可视化回归树，类似之前决策树做分类的文章中的<code>dotify</code>函数，这里稍微修改下叶子节点的label，我们便可以递归得到决策树对应的dot文件, <code>dotify</code>函数的实现见:<a href="https://github.com/PytLab/MLBox/blob/master/classification_and_regression_trees/regression_tree.py#L159" target="_blank" rel="external">https://github.com/PytLab/MLBox/blob/master/classification_and_regression_trees/regression_tree.py#L159</a><br>然后获取树结构图:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">datafile = <span class="string">'ex0.txt'</span></div><div class="line">dotfile = <span class="string">'&#123;&#125;.dot'</span>.format(datafile.split(<span class="string">'.'</span>)[<span class="number">0</span>])</div><div class="line"><span class="keyword">with</span> open(dotfile, <span class="string">'w'</span>) <span class="keyword">as</span> f:</div><div class="line">    content = dotify(tree)</div><div class="line">    f.write(content)</div></pre></td></tr></table></figure></p>
<p>生成回归树图片:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dot -Tpng ex0.dot -o ex0_tree.png</div></pre></td></tr></table></figure></p>
<p><img src="/assets/images/blog_img/2017-11-03-机器学习算法实践-树回归/ex0_tree.png" alt=""></p>
<p>其中节点上数字代表:<code>特征编号: 特征分割值</code></p>
<h4 id="绘制回归树回归曲线"><a href="#绘制回归树回归曲线" class="headerlink" title="绘制回归树回归曲线"></a>绘制回归树回归曲线</h4><p>有了回归树，我们便可以绘制回归树回归曲线，看看它对于分段数据是否能有较好的回归效果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 绘制回归曲线</span></div><div class="line">x = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">50</span>)</div><div class="line">y = [tree_predict([i], tree) <span class="keyword">for</span> i <span class="keyword">in</span> x]</div><div class="line">plt.plot(x, y, c=<span class="string">'r'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure></p>
<p><img src="/assets/images/blog_img/2017-11-03-机器学习算法实践-树回归/ex0_regression.png" alt=""></p>
<h3 id="树剪枝"><a href="#树剪枝" class="headerlink" title="树剪枝"></a>树剪枝</h3><p>在介绍树剪枝之前先使用上一部分的代码对两组类似的数据进行回归，可视化后的数据以及回归曲线如下(<a href="https://github.com/PytLab/MLBox/blob/master/classification_and_regression_trees/ex00.txt" target="_blank" rel="external">数据文件左</a>&amp;<a href="https://github.com/PytLab/MLBox/blob/master/classification_and_regression_trees/ex2.txt" target="_blank" rel="external">数据文件右</a>):</p>
<p><img src="/assets/images/blog_img/2017-11-03-机器学习算法实践-树回归/prune_compare.png" alt=""></p>
<p>左右两边的数据的分布基本相同但是使用相同的参数得到的回归树却完全不同左边的回归树只有两个分支，而右边的分支则有很多，甚至有时候会为所有的数据点得到一个分支，这样回归树将会非常的庞大, 如下是可视化得到的两个回归树:</p>
<p><img src="/assets/images/blog_img/2017-11-03-机器学习算法实践-树回归/prune_tree_compare.png" alt=""></p>
<p>如果一棵树的节点过多则表明该模型可能对数据进行了“过拟合”。那么我们需要降低决策树的复杂度来避免过拟合，此过程就是<strong>剪枝</strong>。剪枝技术又分为<strong>预剪枝</strong>和<strong>后剪枝</strong>。</p>
<h4 id="预剪枝"><a href="#预剪枝" class="headerlink" title="预剪枝"></a>预剪枝</h4><p>预剪枝是在生成决策树之前通过改变参数然后在树生成的过程中进行的。比如在上文中我们创建回归树的函数中有个<code>opt</code>参数，其中包含<code>n_tolerance</code>和<code>err_tolerance</code>，他们可以控制何时停止树的分裂，当增大叶子节点的最小数据量以及增大误差容忍度，树的分裂也会越提前的终止。当我们把误差变化容忍度增加到2000的时候得到的回归树以及回归曲线可视化如下:</p>
<p><img src="/assets/images/blog_img/2017-11-03-机器学习算法实践-树回归/pruned_tree_regression.png" alt=""></p>
<h4 id="后剪枝"><a href="#后剪枝" class="headerlink" title="后剪枝"></a>后剪枝</h4><p>预剪枝技术需要用于预先指定参数，但是后剪枝技术则是通过测试数据来自动进行剪枝不需要用户干预因此是一种更理想的剪枝技术，但是我们需要写剪枝函数来处理。</p>
<blockquote>
<p>后剪枝的大致思想就是我们针对一颗子树，尝试将其左右子树(节点)合并，通过测试数据计算合并前后的方差，如果合并后的方差比合并前的小，这说明可以合并此子树。</p>
</blockquote>
<p>对树进行塌陷处理: 我们对一棵树进行塌陷处理，就是递归将这棵树进行合并返回这棵树的平均值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">collapse</span><span class="params">(tree)</span>:</span></div><div class="line">    <span class="string">''' 对一棵树进行塌陷处理, 得到给定树结构的平均值</span></div><div class="line">    '''</div><div class="line">    <span class="keyword">if</span> not_tree(tree):</div><div class="line">        <span class="keyword">return</span> tree</div><div class="line">    ltree, rtree = tree[<span class="string">'left'</span>], tree[<span class="string">'right'</span>]</div><div class="line">    <span class="keyword">return</span> (collapse(ltree) + collapse(rtree))/<span class="number">2</span></div></pre></td></tr></table></figure>
<p>后剪枝的Python实现:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">postprune</span><span class="params">(tree, test_data)</span>:</span></div><div class="line">    <span class="string">''' 根据测试数据对树结构进行后剪枝</span></div><div class="line">    '''</div><div class="line">    <span class="keyword">if</span> not_tree(tree):</div><div class="line">        <span class="keyword">return</span> tree</div><div class="line"></div><div class="line">    <span class="comment"># 若没有测试数据则直接返回树平均值</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> test_data:</div><div class="line">        <span class="keyword">return</span> collapse(tree)</div><div class="line"></div><div class="line">    ltree, rtree = tree[<span class="string">'left'</span>], tree[<span class="string">'right'</span>]</div><div class="line"></div><div class="line">    <span class="keyword">if</span> not_tree(ltree) <span class="keyword">and</span> not_tree(rtree):</div><div class="line">        <span class="comment"># 分割数据用于测试</span></div><div class="line">        ldata, rdata = split_dataset(test_data, tree[<span class="string">'feat_idx'</span>], tree[<span class="string">'feat_val'</span>])</div><div class="line">        <span class="comment"># 分别计算合并前和合并后的测试数据误差</span></div><div class="line">        err_no_merge = (np.sum((np.array(ldata) - ltree)**<span class="number">2</span>) +</div><div class="line">                        np.sum((np.array(rdata) - rtree)**<span class="number">2</span>))</div><div class="line">        err_merge = np.sum((np.array(test_data) - (ltree + rtree)/<span class="number">2</span>)**<span class="number">2</span>)</div><div class="line"></div><div class="line">        <span class="keyword">if</span> err_merge &lt; err_no_merge:</div><div class="line">            print(<span class="string">'merged'</span>)</div><div class="line">            <span class="keyword">return</span> (ltree + rtree)/<span class="number">2</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> tree</div><div class="line"></div><div class="line">    tree[<span class="string">'left'</span>] = postprune(tree[<span class="string">'left'</span>], test_data)</div><div class="line">    tree[<span class="string">'right'</span>] = postprune(tree[<span class="string">'right'</span>], test_data)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> tree</div></pre></td></tr></table></figure></p>
<p>我们看一下不对刚才的树进行预剪枝而是使用测试数据进行后剪枝的效果:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data_test = load_data(<span class="string">'ex2test.txt'</span>)</div><div class="line">pruned_tree = postprune(tree, data_test)</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">merged</div><div class="line">merged</div><div class="line">merged</div><div class="line">merged</div><div class="line">merged</div><div class="line">merged</div><div class="line">merged</div><div class="line">merged</div></pre></td></tr></table></figure>
<p>通过输出可以看到总共进行了8次剪枝操作，通过把剪枝前和剪枝后的树可视化对比下看看:</p>
<p><img src="/assets/images/blog_img/2017-11-03-机器学习算法实践-树回归/postprune_compare.png" alt=""></p>
<p>树的规模的确是减小了。</p>
<h3 id="模型树"><a href="#模型树" class="headerlink" title="模型树"></a>模型树</h3><p>上一部分叶子节点上放的是分割后数据的平均值并以他作为满足条件的样本的预测值，本部分我们将在叶子节点上放一个线性模型来做预测。也就是指我们的树是由多个线性模型组成的，显然会比强行用平均值来建模更有优势。</p>
<ul>
<li>模型树使用多个线性函数来做回归比用多个平均值组成一棵大树的模型更有可解释性</li>
<li>而且线性模型的使用可以使树的规模减小，毕竟平均值的覆盖范围只是局部的，而线性模型可以覆盖所有具有线性关系的数据。</li>
<li>模型树也具有更高的预测准确度</li>
</ul>
<h4 id="创建模型树"><a href="#创建模型树" class="headerlink" title="创建模型树"></a>创建模型树</h4><p>模型树和回归树的思想是完全一致的，只是在生成叶子节点的方法以及计算数据误差(不纯度)的方式不同。在模型树里针对一个叶子节点我们需要使用分割到的数据进行线性回归得到线性回归系数而不是简单的计算数据的平均值。不纯度的计算也不是简单的计算数据的方差，而是计算线性模型的残差平方和。</p>
<p>为了能为叶子节点计算线性模型，我们还需要实现一个标准线性回归函数<code>linear_regression</code>, 相应模型树的<code>ferr</code>和<code>fleaf</code>的Python实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_regression</span><span class="params">(dataset)</span>:</span></div><div class="line">    <span class="string">''' 获取标准线性回归系数</span></div><div class="line">    '''</div><div class="line">    dataset = np.matrix(dataset)</div><div class="line">    <span class="comment"># 分割数据并添加常数列</span></div><div class="line">    X_ori, y = dataset[:, :<span class="number">-1</span>], dataset[:, <span class="number">-1</span>]</div><div class="line">    X_ori, y = np.matrix(X_ori), np.matrix(y)</div><div class="line">    m, n = X_ori.shape</div><div class="line">    X = np.matrix(np.ones((m, n+<span class="number">1</span>)))</div><div class="line">    X[:, <span class="number">1</span>:] = X_ori</div><div class="line"></div><div class="line">    <span class="comment"># 回归系数</span></div><div class="line">    w = (X.T*X).I*X.T*y</div><div class="line">    <span class="keyword">return</span> w, X, y</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fleaf</span><span class="params">(dataset)</span>:</span></div><div class="line">    <span class="string">''' 计算给定数据集的线性回归系数</span></div><div class="line">    '''</div><div class="line">    w, _, _ = linear_regression(dataset)</div><div class="line">    <span class="keyword">return</span> w</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ferr</span><span class="params">(dataset)</span>:</span></div><div class="line">    <span class="string">''' 对给定数据集进行回归并计算误差</span></div><div class="line">    '''</div><div class="line">    w, X, y = linear_regression(dataset)</div><div class="line">    y_prime = X*w</div><div class="line">    <span class="keyword">return</span> np.var(y_prime - y)</div></pre></td></tr></table></figure></p>
<h4 id="在分段线性数据上应用模型树"><a href="#在分段线性数据上应用模型树" class="headerlink" title="在分段线性数据上应用模型树"></a>在分段线性数据上应用模型树</h4><p>本部分使用了事先准备好的分段线性数据来构建模型树，数据点可视化如下:</p>
<p><img src="/assets/images/blog_img/2017-11-03-机器学习算法实践-树回归/exp2_data.png" alt=""></p>
<p>现在我们使用这些数据构建一个模型树:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tree = create_tree(dataset, fleaf, ferr, opt=&#123;<span class="string">'err_tolerance'</span>: <span class="number">0.1</span>, <span class="string">'n_tolerance'</span>: <span class="number">4</span>&#125;)</div><div class="line">tree</div></pre></td></tr></table></figure></p>
<p>得到的树结构：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="string">'feat_idx'</span>: <span class="number">0</span>,</div><div class="line"> <span class="string">'feat_val'</span>: <span class="number">0.30440099999999998</span>,</div><div class="line"> <span class="string">'left'</span>: matrix([[ <span class="number">3.46877936</span>],</div><div class="line">                 [ <span class="number">1.18521743</span>]]),</div><div class="line"> <span class="string">'right'</span>: matrix([[  <span class="number">1.69855694e-03</span>],</div><div class="line">                  [  <span class="number">1.19647739e+01</span>]])&#125;</div></pre></td></tr></table></figure></p>
<p>可视化:</p>
<p><img src="/assets/images/blog_img/2017-11-03-机器学习算法实践-树回归/exp2_tree.png" alt=""></p>
<p>绘制回归曲线:</p>
<p><img src="/assets/images/blog_img/2017-11-03-机器学习算法实践-树回归/exp2_regression.png" alt=""></p>
<p>可以通过模型树看到对于此数据只需要两个分支，数的深度也只有2层。</p>
<ul>
<li>当$x &lt; 0.304$的时候，使用线性模型$y = 3.47 + 1.19x$来回归</li>
<li>当$x &gt; 0.304$的时候，使用线性模型$y = 0.0017 + 1.20x$来回归</li>
</ul>
<h3 id="回归树与线性回归的对比"><a href="#回归树与线性回归的对比" class="headerlink" title="回归树与线性回归的对比"></a>回归树与线性回归的对比</h3><p>本部分我们使用标准线性回归和回归树分别对同一组数据进行回归，并使用同一组测试数据计算相关系数(Correlation Coefficient)对两种模型的回归效果进行对比。</p>
<p>数据我还是使用《Machinie Learning in Action》中的现成数据，数据可视化如下:</p>
<p><img src="/assets/images/blog_img/2017-11-03-机器学习算法实践-树回归/bike_data.png" alt=""></p>
<p>现在我们分别使用标准线性回归和回归树对该数据进行回归，并计算模型预测值和测试样本的相关系数$R^2$(完整代码见:<a href="https://github.com/PytLab/MLBox/blob/master/classification_and_regression_trees/compare.py" target="_blank" rel="external">https://github.com/PytLab/MLBox/blob/master/classification_and_regression_trees/compare.py</a>)</p>
<p>相关系数计算:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_corrcoef</span><span class="params">(X, Y)</span>:</span></div><div class="line">    <span class="comment"># X Y 的协方差</span></div><div class="line">    cov = np.mean(X*Y) - np.mean(X)*np.mean(Y)</div><div class="line">    <span class="keyword">return</span> cov/(np.var(X)*np.var(Y))**<span class="number">0.5</span></div></pre></td></tr></table></figure></p>
<p>获得的相关系数:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">linear regression correlation coefficient: <span class="number">0.9434684235674773</span></div><div class="line">regression tree correlation coefficient: <span class="number">0.9780307932704089</span></div></pre></td></tr></table></figure></p>
<p>绘制线性回归和树回归的回归曲线(黄色会树回归曲线，红色会线性回归):</p>
<p><img src="/assets/images/blog_img/2017-11-03-机器学习算法实践-树回归/bike_regression.png" alt=""></p>
<p>可见树回归方法在预测复杂数据的时候会比简单的线性模型更有效。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对决策树用于连续数值的回归预测进行了介绍，并实现了回归树, 剪枝和模型树以及相应的树结构输出可视化等。对于模型树也给予了相应的Python实现并针对分段线性数据进行了回归测试。最后并对回归树模型和简单的标准线性回归模型进行了对比。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Machine Learning in Action》</li>
<li><a href="http://blog.csdn.net/u014568921/article/details/45082197" target="_blank" rel="external">CART分类与回归树的原理与实现</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MachineLearning </tag>
            
            <tag> LinearRegression </tag>
            
            <tag> CART </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习算法实践-岭回归和LASSO]]></title>
      <url>http://pytlab.github.io/2017/10/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-%E5%B2%AD%E5%9B%9E%E5%BD%92%E5%92%8CLASSO%E5%9B%9E%E5%BD%92/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>继续线性回归的总结, 本文主要介绍两种线性回归的缩减(shrinkage)方法的基础知识: 岭回归(Ridge Regression)和LASSO(Least Absolute Shrinkage and Selection Operator)并对其进行了Python实现。同时也对一种更为简单的向前逐步回归计算回归系数的方法进行了相应的实现。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>通过上一篇《<a href="http://pytlab.github.io/2017/10/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5-%E6%A0%87%E5%87%86%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8A%A0%E6%9D%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/">机器学习算法实践-标准与局部加权线性回归</a>》中标准线性回归的公式$w = (X^{T}X)^{-1}X^{T}y$中可以看出在计算回归系数的时候我们需要计算矩阵$X^TX$的逆，但是如果该矩阵是个奇异矩阵，则无法对其进行求解。那么什么情况下该矩阵会有奇异性呢?</p>
<a id="more"></a>
<ol>
<li>X本身存在线性相关关系(多重共线性), 即非满秩矩阵。如果数据的特征中存在两个相关的变量，即使并不是完全线性相关，但是也会造成矩阵求逆的时候造成求解不稳定。</li>
<li>当数据特征比数据量还要多的时候, 即$m &lt; n$, 这时候矩阵$X$是一个矮胖型的矩阵，非满秩。</li>
</ol>
<p>对于上面的两种情况，我们需要对最初的标准线性回归做一定的变化使原先无法求逆的矩阵变得非奇异，使得问题可以稳定求解。我们可以通过缩减的方式来处理这些问题例如岭回归和LASSO. </p>
<h3 id="中心化和标准化"><a href="#中心化和标准化" class="headerlink" title="中心化和标准化"></a>中心化和标准化</h3><p>这里先介绍下数据的中心化和标准化，在回归问题和一些机器学习算法中通常要对原始数据进行中心化和标准化处理，也就是需要将数据的均值调整到0，标准差调整为1, 计算过程很简单就是将所有数据减去平均值后再除以标准差:<br>$$<br>x_i^{‘} = \frac{x_i - \mu}{\sigma}<br>$$</p>
<p>这样调整后的均值:<br>$$\mu^{‘} = \frac{(\sum_{i=1}^{n}x_i)/n - \mu}{\sigma} = 0$$</p>
<p>调整后的标准差:<br>$$<br>\sigma^{‘} = \frac{(x_i - \mu)^2/n}{\sigma^2} = \frac{\sigma^2}{\sigma^2} = 1<br>$$</p>
<p>之所以需要进行中心化其实就是个平移过程，将所有数据的中心平移到原点。而标准化则是使得所有数据的不同特征都有相同的尺度Scale, 这样在使用梯度下降法以及其他方法优化的时候不同特征参数的影响程度就会一致了。</p>
<p>如下图所示，可以看出得到的标准化数据在每个维度上的尺度是一致的(图片来自网络，侵删)<br><img src="/assets/images/blog_img/2017-10-27-机器学习实践-岭回归和LASSO回归/standarize.jpg" alt=""></p>
<h3 id="岭回归-Ridge-Regression"><a href="#岭回归-Ridge-Regression" class="headerlink" title="岭回归(Ridge Regression)"></a>岭回归(Ridge Regression)</h3><p>标准最小二乘法优化问题:<br>$$<br>f(w) = \sum_{i=1}^{m} (y_i - x_{i}^{T}w)^2<br>$$<br>也可以通过矩阵表示:<br>$$<br>f(w) = (y - Xw)^{T}(y - Xw)<br>$$<br>得到的回归系数为:<br>$$<br>\hat{w} = (X^{T}X)^{-1}X^{T}y<br>$$</p>
<p>这个问题解存在且唯一的条件就是$X$列满秩:$rank(X) = dim(X)$.</p>
<p>即使$X$列满秩，但是当数据特征中存在共线性，即相关性比较大的时候，会使得标准最小二乘求解不稳定, $X^TX$的行列式接近零，计算$X^TX$的时候误差会很大。这个时候我们需要在cost function上添加一个惩罚项$\lambda\sum_{i=1}^{n}w_{i}^2$，称为L2正则化。</p>
<p>这个时候的cost function的形式就为:<br>$$<br>f(w) = \sum_{i=1}^{m} (y_i - x_{i}^{T}w)^2 + \lambda\sum_{i=1}^{n}w_{i}^{2}<br>$$</p>
<p>通过加入此惩罚项进行优化后，限制了回归系数$w_i$的绝对值，数学上可以证明上式的等价形式如下:<br>$$<br>f(w) = \sum_{i=1}^{m} (y_i - x_{i}^{T}w)^2 \\<br>s.t. \sum_{i=1}^{n}w_{j}^2 \le t<br>$$<br>其中t为某个阈值。</p>
<p>将岭回归系数用矩阵的形式表示:<br>$$<br>\hat{w} = (X^{T}X + \lambda I)^{-1}X^{T}y<br>$$</p>
<p>可以看到，就是通过将$X^TX$加上一个单位矩阵是的矩阵变成非奇异矩阵并可以进行求你运算。</p>
<h4 id="岭回归的几何意义"><a href="#岭回归的几何意义" class="headerlink" title="岭回归的几何意义"></a>岭回归的几何意义</h4><p>以两个变量为例, 残差平方和可以表示为$w_1, w_2$的一个二次函数，是一个在三维空间中的抛物面，可以用等值线来表示。而限制条件$w_1^2 + w_2^2 &lt; t$， 相当于在二维平面的一个圆。这个时候等值线与圆相切的点便是在约束条件下的最优点，如下图所示，</p>
<p><img src="/assets/images/blog_img/2017-10-27-机器学习实践-岭回归和LASSO回归/ridge_opt.png" alt=""></p>
<h4 id="岭回归的一些性质"><a href="#岭回归的一些性质" class="headerlink" title="岭回归的一些性质"></a>岭回归的一些性质</h4><ol>
<li>当岭参数$\lambda = 0$时，得到的解是最小二乘解</li>
<li>当岭参数$\lambda$趋向更大时，岭回归系数$w_i$趋向于0，约束项$t$很小</li>
</ol>
<h4 id="岭回归的Python实现"><a href="#岭回归的Python实现" class="headerlink" title="岭回归的Python实现"></a>岭回归的Python实现</h4><p>通过矩阵的形式计算$\hat{w}$, 可以很简单的实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ridge_regression</span><span class="params">(X, y, lambd=<span class="number">0.2</span>)</span>:</span></div><div class="line">    <span class="string">''' 获取岭回归系数</span></div><div class="line">    '''</div><div class="line">    XTX = X.T*X</div><div class="line">    m, _ = XTX.shape</div><div class="line">    I = np.matrix(np.eye(m))</div><div class="line">    w = (XTX + lambd*I).I*X.T*y</div><div class="line">    <span class="keyword">return</span> w</div></pre></td></tr></table></figure></p>
<h4 id="岭迹图"><a href="#岭迹图" class="headerlink" title="岭迹图"></a>岭迹图</h4><p>可以知道求得的岭系数$w_i$是岭参数$\lambda$的函数，不同的$\lambda$得到不同的岭参数$w_i$, 因此我们可以增大$\lambda$的值来得到岭回归系数的变化，以及岭参数的变化轨迹图(岭迹图), 不存在奇异性时，岭迹图应稳定的逐渐趋向于0。</p>
<p>通过岭迹图我们可以:</p>
<ol>
<li>观察较佳的$\lambda$取值</li>
<li>观察变量是否有多重共线性</li>
</ol>
<h4 id="绘制岭迹图"><a href="#绘制岭迹图" class="headerlink" title="绘制岭迹图"></a>绘制岭迹图</h4><p>上面我们通过函数<code>ridge_regression</code>实现了计算岭回归系数的计算，我们使用《机器学习实战》中的鲍鱼年龄的数据来进行计算并绘制不同$\lambda$的岭参数变化的轨迹图。数据以及完整代码详见 <a href="https://github.com/PytLab/MLBox/tree/master/linear_regression" target="_blank" rel="external">https://github.com/PytLab/MLBox/tree/master/linear_regression</a></p>
<p>选取30组不同的$\lambda$来获取岭系数矩阵包含30个不同的岭系数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ridge_traj</span><span class="params">(X, y, ntest=<span class="number">30</span>)</span>:</span></div><div class="line">    <span class="string">''' 获取岭轨迹矩阵</span></div><div class="line">    '''</div><div class="line">    _, n = X.shape</div><div class="line">    ws = np.zeros((ntest, n))</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(ntest):</div><div class="line">        w = ridge_regression(X, y, lambd=exp(i<span class="number">-10</span>))</div><div class="line">        ws[i, :] = w.T</div><div class="line">    <span class="keyword">return</span> ws</div></pre></td></tr></table></figure>
<p>绘制岭轨迹图<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="string">'__main__'</span> == __name__:</div><div class="line">    ntest = <span class="number">30</span></div><div class="line">    <span class="comment"># 加载数据</span></div><div class="line">    X, y = load_data(<span class="string">'abalone.txt'</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 中心化 &amp; 标准化</span></div><div class="line">    X, y = standarize(X), standarize(y)</div><div class="line"></div><div class="line">    <span class="comment"># 绘制岭轨迹</span></div><div class="line">    ws = ridge_traj(X, y, ntest)</div><div class="line">    fig = plt.figure()</div><div class="line">    ax = fig.add_subplot(<span class="number">111</span>)</div><div class="line"></div><div class="line">    lambdas = [i<span class="number">-10</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(ntest)]</div><div class="line">    ax.plot(lambdas, ws)</div><div class="line"></div><div class="line">    plt.show()</div></pre></td></tr></table></figure></p>
<p><img src="/assets/images/blog_img/2017-10-27-机器学习实践-岭回归和LASSO回归/ridge_traj.png" alt=""></p>
<p>上图绘制了回归系数$w_i$与$log(\lambda)$的关系，在最左边$\lambda$系数最小时，可以得到所有系数的原始值(与标准线性回归相同); 而在右边，系数全部缩减为0, 从不稳定趋于稳定；为了定量的找到最佳参数值，还需要进行交叉验证。要判断哪些变量对结果的预测最具影响力，可以观察他们的系数大小即可。</p>
<h3 id="LASSO"><a href="#LASSO" class="headerlink" title="LASSO"></a>LASSO</h3><p>岭回归限定了所有回归系数的平方和不大于$t$, 在使用普通最小二乘法回归的时候当两个变量具有相关性的时候，可能会使得其中一个系数是个很大正数，另一个系数是很大的负数。通过岭回归的$\sum_{i=1}^{n} w_i \le t$的限制，可以避免这个问题。</p>
<p>LASSO(The Least Absolute Shrinkage and Selection Operator)是另一种缩减方法，将回归系数收缩在一定的区域内。LASSO的主要思想是构造一个一阶惩罚函数获得一个精炼的模型, 通过最终确定一些变量的系数为0进行特征筛选。</p>
<p>LASSO的惩罚项为:<br>$$<br>\sum_{i=1}^{n} \vert w_i \vert \le t<br>$$</p>
<p>与岭回归的不同在于，此约束条件使用了绝对值的一阶惩罚函数代替了平方和的二阶函数。虽然只是形式稍有不同，但是得到的结果却又很大差别。在LASSO中，当$\lambda$很小的时候，一些系数会随着变为0而岭回归却很难使得某个系数<strong>恰好</strong>缩减为0. 我们可以通过几何解释看到LASSO与岭回归之间的不同。</p>
<h4 id="LASSO的几何解释"><a href="#LASSO的几何解释" class="headerlink" title="LASSO的几何解释"></a>LASSO的几何解释</h4><p>同样以两个变量为例，标准线性回归的cost function还是可以用二维平面的等值线表示，而约束条件则与岭回归的圆不同，LASSO的约束条件可以用方形表示，如下图:</p>
<p><img src="/assets/images/blog_img/2017-10-27-机器学习实践-岭回归和LASSO回归/lasso_opt.png" alt=""></p>
<p>相比圆，方形的顶点更容易与抛物面相交，顶点就意味着对应的很多系数为0，而岭回归中的圆上的任意一点都很容易与抛物面相交很难得到正好等于0的系数。这也就意味着，lasso起到了很好的筛选变量的作用。</p>
<h4 id="LASSO回归系数的计算"><a href="#LASSO回归系数的计算" class="headerlink" title="LASSO回归系数的计算"></a>LASSO回归系数的计算</h4><p>虽然惩罚函数只是做了细微的变化，但是相比岭回归可以直接通过矩阵运算得到回归系数相比，LASSO的计算变得相对复杂。由于惩罚项中含有绝对值，此函数的导数是连续不光滑的，所以无法进行求导并使用梯度下降优化。本部分使用坐标下降发对LASSO回归系数进行计算。</p>
<p>坐标下降法是每次选择一个维度的参数进行一维优化，然后不断的迭代对多个维度进行更新直到函数收敛。SVM对偶问题的优化算法SMO也是类似的原理，这部分的详细介绍我在之前的一篇博客中进行了整理，参考《<a href="http://pytlab.github.io/2017/09/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5-SVM%E4%B8%AD%E7%9A%84SMO%E7%AE%97%E6%B3%95/">机器学习算法实践-SVM中的SMO算法</a>》。</p>
<p>下面我们分别对LASSO的cost function的两部分求解：</p>
<ol>
<li>RSS部分</li>
</ol>
<p>$$<br>RSS(w) = \sum_{i=1}^{m}(y_i - \sum_{j=1}^{n}x_{ij}w_j)^2<br>$$</p>
<p>求导:<br>$$<br>\frac{\partial RSS(w)}{\partial w_k} = -2\sum_{i=1}^{m}x_{ik}(y_i - \sum_{j=1}^{n}x_{ij}w_j) \\<br>= -2\sum_{i=1}^{m}(x_{ik}y_i - x_{ik}\sum_{j=1, j \ne k}^{n}x_{ij}w_j - x_{ik}^2w_k) \\<br>= -2\sum_{i=1}^{m}x_{ik}(y_i - \sum_{j=1, j \ne k}^{n}x_{ij}w_{j}) + 2w_k\sum_{i=1}^{m}x_{ik}^2<br>$$</p>
<p>令$p_k = \sum_{i=1}^{m}x_{ik}(y_i - \sum_{j=1, j \ne k}^{n}x_{ij}w_{j})$, $z_k = \sum_{i=1}{m}x_{ik}^2$ 得到:</p>
<p>$$<br>\frac{\partial RSS(w)}{\partial w_j} = -2p_k + 2z_kw_k<br>$$</p>
<ol>
<li>正则项</li>
</ol>
<p>关于惩罚项的求导我们需要使用subgradient，可以参考<a href="https://www.zhihu.com/question/22332436/answer/21068494" target="_blank" rel="external">LASSO（least absolute shrinkage and selection operator） 回归中 如何用梯度下降法求解？</a></p>
<p>$$<br>\lambda \frac{\partial \sum_{i=1}^{n}\vert w_j \vert}{\partial w_k} = \begin{cases}<br>-\lambda &amp; w_k &lt; 0 \\<br>[-\lambda, \lambda] &amp; w_k = 0 \\<br>\lambda &amp; w_k &gt; 0<br>\end{cases}<br>$$</p>
<p>这样整体的偏导数:<br>$$<br>\frac{\partial f(w)}{\partial w_k} = 2z_kw_k - 2p_k + \begin{cases}<br>-\lambda &amp; w_k &lt; 0 \\<br>[-\lambda, \lambda] &amp; w_k = 0 \\<br>\lambda &amp; w_k &gt; 0<br>\end{cases} \\<br>= \begin{cases}<br>2z_kw_k - 2p_k - \lambda &amp; w_k &lt; 0 \\<br>[-2p_k - \lambda, -2p_k + \lambda] &amp; w_j = 0 \\<br>2z_kw_k - 2p_k + \lambda &amp; w_k &gt; 0<br>\end{cases}<br>$$</p>
<p>令$\frac{\partial f(w)}{\partial w_k} = 0$ 得到</p>
<p>$$<br>\hat{w_k} = \begin{cases}<br>(p_k + \lambda/2)/z_k &amp; p_k &lt; -\lambda/2 \\<br>0 &amp; -\lambda/2 \le p_k \le \lambda/2 \\<br>(p_k - \lambda/2)/z_k &amp; p_k &gt; \lambda/2<br>\end{cases}<br>$$</p>
<p>通过上面的公式我们便可以每次选取一维进行优化并不断跌打得到最优回归系数。</p>
<h4 id="LASSO的Python实现"><a href="#LASSO的Python实现" class="headerlink" title="LASSO的Python实现"></a>LASSO的Python实现</h4><p>根据上面代码我们实现梯度下降法并使用其获取LASSO回归系数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">lasso_regression</span><span class="params">(X, y, lambd=<span class="number">0.2</span>, threshold=<span class="number">0.1</span>)</span>:</span></div><div class="line">    <span class="string">''' 通过坐标下降(coordinate descent)法获取LASSO回归系数</span></div><div class="line">    '''</div><div class="line">    <span class="comment"># 计算残差平方和</span></div><div class="line">    rss = <span class="keyword">lambda</span> X, y, w: (y - X*w).T*(y - X*w)</div><div class="line"></div><div class="line">    <span class="comment"># 初始化回归系数w.</span></div><div class="line">    m, n = X.shape</div><div class="line">    w = np.matrix(np.zeros((n, <span class="number">1</span>)))</div><div class="line">    r = rss(X, y, w)</div><div class="line"></div><div class="line">    <span class="comment"># 使用坐标下降法优化回归系数w</span></div><div class="line">    niter = itertools.count(<span class="number">1</span>)</div><div class="line"></div><div class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> niter:</div><div class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</div><div class="line">            <span class="comment"># 计算常量值z_k和p_k</span></div><div class="line">            z_k = (X[:, k].T*X[:, k])[<span class="number">0</span>, <span class="number">0</span>]</div><div class="line">            p_k = <span class="number">0</span></div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</div><div class="line">                p_k += X[i, k]*(y[i, <span class="number">0</span>] - sum([X[i, j]*w[j, <span class="number">0</span>] <span class="keyword">for</span> j <span class="keyword">in</span> range(n) <span class="keyword">if</span> j != k]))</div><div class="line"></div><div class="line">            <span class="keyword">if</span> p_k &lt; -lambd/<span class="number">2</span>:</div><div class="line">                w_k = (p_k + lambd/<span class="number">2</span>)/z_k</div><div class="line">            <span class="keyword">elif</span> p_k &gt; lambd/<span class="number">2</span>:</div><div class="line">                w_k = (p_k - lambd/<span class="number">2</span>)/z_k</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                w_k = <span class="number">0</span></div><div class="line"></div><div class="line">            w[k, <span class="number">0</span>] = w_k</div><div class="line"></div><div class="line">        r_prime = rss(X, y, w)</div><div class="line">        delta = abs(r_prime - r)[<span class="number">0</span>, <span class="number">0</span>]</div><div class="line">        r = r_prime</div><div class="line">        print(<span class="string">'Iteration: &#123;&#125;, delta = &#123;&#125;'</span>.format(it, delta))</div><div class="line"></div><div class="line">        <span class="keyword">if</span> delta &lt; threshold:</div><div class="line">            <span class="keyword">break</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> w</div></pre></td></tr></table></figure>
<p>我们选取$\lambda = 10$, 收敛阈值为0.1来获取回归系数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="string">'__main__'</span> == __name__:</div><div class="line">    X, y = load_data(<span class="string">'abalone.txt'</span>)</div><div class="line">    X, y = standarize(X), standarize(y)</div><div class="line">    w = lasso_regression(X, y, lambd=<span class="number">10</span>)</div><div class="line"></div><div class="line">    y_prime = X*w</div><div class="line">    <span class="comment"># 计算相关系数</span></div><div class="line">    corrcoef = get_corrcoef(np.array(y.reshape(<span class="number">1</span>, <span class="number">-1</span>)),</div><div class="line">                            np.array(y_prime.reshape(<span class="number">1</span>, <span class="number">-1</span>)))</div><div class="line">    print(<span class="string">'Correlation coefficient: &#123;&#125;'</span>.format(corrcoef))</div></pre></td></tr></table></figure>
<p>迭代了150步收敛到0.1，计算相对比较耗时:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Iteration: <span class="number">146</span>, delta = <span class="number">0.1081124857935265</span></div><div class="line">Iteration: <span class="number">147</span>, delta = <span class="number">0.10565615985365184</span></div><div class="line">Iteration: <span class="number">148</span>, delta = <span class="number">0.10326058648411163</span></div><div class="line">Iteration: <span class="number">149</span>, delta = <span class="number">0.10092418256476776</span></div><div class="line">Iteration: <span class="number">150</span>, delta = <span class="number">0.09864540659987142</span></div><div class="line">Correlation coefficient: <span class="number">0.7255254877587117</span></div></pre></td></tr></table></figure></p>
<h4 id="LASSO回归系数轨迹"><a href="#LASSO回归系数轨迹" class="headerlink" title="LASSO回归系数轨迹"></a>LASSO回归系数轨迹</h4><p>类似岭轨迹，我们也可以改变$\lambda$的值得到不同的回归系数，通过作图可以看到回归系数的轨迹</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ntest = <span class="number">30</span></div><div class="line"></div><div class="line"><span class="comment"># 绘制轨迹</span></div><div class="line">ws = lasso_traj(X, y, ntest)</div><div class="line">fig = plt.figure()</div><div class="line">ax = fig.add_subplot(<span class="number">111</span>)</div><div class="line"></div><div class="line">lambdas = [i<span class="number">-10</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(ntest)]</div><div class="line">ax.plot(lambdas, ws)</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p>得到的轨迹图如下:</p>
<p><img src="/assets/images/blog_img/2017-10-27-机器学习实践-岭回归和LASSO回归/lasso_traj.png" alt=""></p>
<p>通过与岭轨迹图进行对比发现，随着$\lambda$的增大，系数逐渐趋近于0，但是岭回归没有系数真正为0，而lasso中不断有系数变为0.迭代过程中输出如下图:</p>
<p><img src="/assets/images/blog_img/2017-10-27-机器学习实践-岭回归和LASSO回归/lasso_traj_data.png" alt=""></p>
<h3 id="逐步向前回归"><a href="#逐步向前回归" class="headerlink" title="逐步向前回归"></a>逐步向前回归</h3><p>LASSO计算复杂度相对较高，本部分稍微介绍一下逐步向前回归，他属于一种贪心算法，给定初始系数向量，然后不断迭代遍历每个系数，增加或减小一个很小的数，看看代价函数是否变小，如果变小就保留，如果变大就舍弃，然后不断迭代直到回归系数达到稳定。</p>
<p>下面给出实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">stagewise_regression</span><span class="params">(X, y, eps=<span class="number">0.01</span>, niter=<span class="number">100</span>)</span>:</span></div><div class="line">    <span class="string">''' 通过向前逐步回归获取回归系数</span></div><div class="line">    '''</div><div class="line">    m, n = X.shape</div><div class="line">    w = np.matrix(np.zeros((n, <span class="number">1</span>)))</div><div class="line">    min_error = float(<span class="string">'inf'</span>)</div><div class="line">    all_ws = np.matrix(np.zeros((niter, n)))</div><div class="line"></div><div class="line">    <span class="comment"># 计算残差平方和</span></div><div class="line">    rss = <span class="keyword">lambda</span> X, y, w: (y - X*w).T*(y - X*w)</div><div class="line"></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(niter):</div><div class="line">        print(<span class="string">'&#123;&#125;: w = &#123;&#125;'</span>.format(i, w.T[<span class="number">0</span>, :]))</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</div><div class="line">            <span class="keyword">for</span> sign <span class="keyword">in</span> [<span class="number">-1</span>, <span class="number">1</span>]:</div><div class="line">                w_test = w.copy()</div><div class="line">                w_test[j, <span class="number">0</span>] += eps*sign</div><div class="line">                test_error = rss(X, y, w_test)</div><div class="line">                <span class="keyword">if</span> test_error &lt; min_error:</div><div class="line">                    min_error = test_error</div><div class="line">                    w = w_test</div><div class="line">        all_ws[i, :] = w.T</div><div class="line"></div><div class="line">    <span class="keyword">return</span> all_ws</div></pre></td></tr></table></figure></p>
<p>我们去变化量为0.005，迭代步数为1000次，得到回归系数随着迭代次数的变化曲线:</p>
<p><img src="/assets/images/blog_img/2017-10-27-机器学习实践-岭回归和LASSO回归/stage_traj.png" alt=""></p>
<p>逐步回归算法的主要有点在于他可以帮助人们理解现有的模型并作出改进。当构建了一个模型后，可以运行逐步回归算法找出重要的特征，即使停止那些不重要特征的收集。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/assets/images/blog_img/2017-10-27-机器学习实践-岭回归和LASSO回归/bias_var.png" alt=""></p>
<p>本文介绍了两种回归中的缩减方法，岭回归和LASSO。两种回归均是在标准线性回归的基础上加上正则项来减小模型的方差。这里其实便涉及到了权衡偏差(Bias)和方差(Variance)的问题。方差针对的是模型之间的差异，即不同的训练数据得到模型的区别越大说明模型的方差越大。而偏差指的是模型预测值与样本数据之间的差异。所以为了在过拟合和欠拟合之前进行权衡，我们需要确定适当的模型复杂度来使得总误差最小。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Machine Learning in Action》</li>
<li><a href="https://www.zhihu.com/question/27068705" target="_blank" rel="external">机器学习中的Bias(偏差)，Error(误差)，和Variance(方差)有什么区别和联系？</a></li>
<li><a href="http://blog.csdn.net/u012151283/article/details/77487729" target="_blank" rel="external">Lasso回归的坐标下降法推导</a></li>
<li><a href="https://www.zhihu.com/question/37069477" target="_blank" rel="external">数据什么时候需要做中心化和标准化处理？</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MachineLearning </tag>
            
            <tag> LinearRegression </tag>
            
            <tag> RidgeRegression </tag>
            
            <tag> LASSORegression </tag>
            
            <tag> StageWiseRegression </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习算法实践-标准与局部加权线性回归]]></title>
      <url>http://pytlab.github.io/2017/10/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5-%E6%A0%87%E5%87%86%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8A%A0%E6%9D%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近开始总结学习回归相关的东东了，与分类的目标变量是标称型不同，回归是对连续型数据进预测。当然还是从最简单的线性回归开始，本文主要介绍无偏差的标准线性回归和有偏局部加权线性回归的理论基础以及相应的Python实现。</p>
<h2 id="标准线性回归"><a href="#标准线性回归" class="headerlink" title="标准线性回归"></a>标准线性回归</h2><p>标准线性回归的理论知识很简单，我们既可以写出它的标量表达式也可以写成矩阵的形式，其中矩阵的形式也可以通过投影矩阵进行推到得到。本部分就对标准线性回归的表达式进行下简单的推导。</p>
<a id="more"></a>
<p>给定一组数据其中包括特征矩阵$X$, 目标变量向量$y$:<br>$$<br>y = \left[ \begin{matrix}<br>y_1 \\<br>y_2 \\<br>: \\<br>y_m<br>\end{matrix} \right]<br>$$</p>
<p>$$<br>X = \left[ \begin{matrix}<br>1 &amp; x_{11} &amp; x_{12} &amp; … &amp; x_{1n} \\<br>1 &amp; x_{21} &amp; x_{22} &amp; … &amp; x_{2n} \\<br>: &amp; : &amp; : &amp; … &amp; : &amp; \\<br>1 &amp; x_{n1} &amp; x_{n2} &amp; … &amp; x_{nn} \\<br>\end{matrix} \right]<br>$$<br>其中$X$第一列为截距项，我们做线性回归是为了得到一个最优回归系数向量$w$使得当我们给定一个$x$能够通过$y=xw$预测$y$的值。其中</p>
<p>$$<br>w = \left[ \begin{matrix}<br>w_0 \\<br>w_1 \\<br>w_2 \\<br>: \\<br>w_n<br>\end{matrix} \right]<br>$$</p>
<h3 id="最小二乘法获取回归系数"><a href="#最小二乘法获取回归系数" class="headerlink" title="最小二乘法获取回归系数"></a>最小二乘法获取回归系数</h3><p>那么怎样的$w$才是最优的呢？在标准线性回归中我们需要找到是误差最小的$w$, 即预测的$y$值与真实的$y$值之间的差值，为了避免简单累加造成的正负差值相互抵消，这里采用了平方误差:<br>$$<br>f(w) = \sum_{i=1}^{m} (y_i - x_{i}^{T}w)^2<br>$$</p>
<p>对于上述式子$f(w)$可以通过梯度下降等方法得到最优解。但是使用矩阵表示将会是的求解和程序更为简单:<br>$$<br>f(w) = (y - Xw)^{T}(y - Xw)<br>$$<br>将$f(w)$对$w$求导可得:<br>$$<br>\frac{\partial f(w)}{\partial w} = -2X^{T}(y - Xw)<br>$$<br>使其等于0，便可得到:<br>$$<br>X^{T}(y - Xw) = 0 \\<br>X^{T}y = X^{T}Xw \\<br>\hat{w} = (X^{T}X)^{-1}X^{T}y \\<br>$$</p>
<h3 id="通过投影矩阵获取回归系数"><a href="#通过投影矩阵获取回归系数" class="headerlink" title="通过投影矩阵获取回归系数"></a>通过投影矩阵获取回归系数</h3><p>除了通过最小平方差的方法推导得到$w$的表达式，我们还可以通过投影矩阵(Projection Matrix)来得到。</p>
<p>我们知道如果我们能够求得一个$w$使得$Xw = y$肯定是最好的，但是实际情况中$y$一般并不在矩阵$X$的列空间中，也就是此方程无解，于是我们希望通过将向量$y$投影到$X$的列空间中得到投影矩阵$p$, 然后求解$Xw = p$来获取一个最接近的一个解, 矩阵$X$的投影矩阵形式为<br>$$P = X(X^{T}X)^{-1}X^{T}$$<br>于是得到$y$在$X$列空间的投影为<br>$$P\cdot y = X(X^{T}X)^{-1}X^{T}y$$<br>此时方程$Xw = p$是有解的，得到最接近$Xw = y$的解为:<br>$$<br>\hat{w} = (X^{T}X)^{-1}X^{T}y<br>$$</p>
<h3 id="标准线性回归的Python实现"><a href="#标准线性回归的Python实现" class="headerlink" title="标准线性回归的Python实现"></a>标准线性回归的Python实现</h3><p>通过矩阵形式我么可以很方便的通过Numpy的接口进行矩阵运算获取线性回归系数向量$\hat{w}$, 实现如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">std_linreg</span><span class="params">(X, Y)</span>:</span></div><div class="line">    xTx = X.T*X</div><div class="line">    <span class="keyword">if</span> np.linalg.det(xTx) == <span class="number">0</span>:</div><div class="line">        print(<span class="string">'xTx is a singular matrix'</span>)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    <span class="keyword">return</span> xTx.I*X.T*Y</div></pre></td></tr></table></figure></p>
<p>通过对现有数据进行标准线性回归并绘制回归直线得到如下图(完整代码和数据见: <a href="https://github.com/PytLab/MLBox/tree/master/linear_regression" target="_blank" rel="external">https://github.com/PytLab/MLBox/tree/master/linear_regression</a>)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">w = [<span class="number">3.00774324</span>, <span class="number">1.69532264</span>]</div></pre></td></tr></table></figure>
<p><img src="/assets/images/blog_img/2017-10-24-机器学习算法实践-标准与局部加权线性回归/std_linear_regression.png" alt=""></p>
<h3 id="相关系数-Correlation-Coefficient-计算"><a href="#相关系数-Correlation-Coefficient-计算" class="headerlink" title="相关系数(Correlation Coefficient)计算"></a>相关系数(Correlation Coefficient)计算</h3><p>如何判断获得的模型预测能力的好坏呢？我们需要计算模型计算得到的$y$的值向量与实际$y$值向量的匹配程度, 也就是计算相关系数Correlation Coefficient。</p>
<p>相关系数的计算公式:<br>$$<br>r(X, Y) = \frac{Cov(X, Y)}{\sigma_{X}\sigma_{Y}}<br>$$<br>也就是两个数据序列的协方差并除上各自的标准差，本质上就是一种剔除了两个变量量纲影响、标准化后的特殊协方差。</p>
<p>而协方差便是衡量两个变量变化趋势是否相似的一种方法，是同向变化(同时变大或变小)还是反向变化(一个变大一个变小), 同向或者反向的程度如何，计算公式如下:</p>
<p>$$<br>Cov(X, Y) = E[(X - E[X])(Y - E[Y])] = E[XY] - E[X]E[Y]<br>$$ </p>
<p>通过公式可以看出，如果对于向量中的每个$x, y$同时大于或同时小于各自的期望值，协方差为正，相反则为负。可见如果协方差越大相似程度就越高，协方差越小相似程度就越小。也可以看到如果$X, Y$相同，协方差就是方差，也就是方差是一种特殊情况下的协方差。</p>
<p>关于协方差与相关系数的通俗解释可以参考知乎上的回答:<a href="https://www.zhihu.com/question/20852004" target="_blank" rel="external">如何通俗易懂地解释「协方差」与「相关系数」的概念？
</a></p>
<p>虽然Numpy中有计算协方差的接口<code>numpy.corrcoef</code>，是分别对两两向量进行比较并计算协方差，得到协方差矩阵。为了练习，我还是稍微自己计算了下协方差并只计算两列不同数据之间的相关系数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_corrcoef</span><span class="params">(X, Y)</span>:</span></div><div class="line">    <span class="comment"># X Y 的协方差</span></div><div class="line">    cov = np.mean(X*Y) - np.mean(X)*np.mean(Y)</div><div class="line">    <span class="keyword">return</span> cov/(np.var(X)*np.var(Y))**<span class="number">0.5</span></div></pre></td></tr></table></figure>
<p>通过对上面得到的线性回归模型得到的预测的值与实际的值进行相关系数计算可以得到相关系数为<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Correlation coeffient: <span class="number">0.9864735622335125</span></div></pre></td></tr></table></figure></p>
<h2 id="局部加权线性回归-Local-Weighted-Linear-Regression"><a href="#局部加权线性回归-Local-Weighted-Linear-Regression" class="headerlink" title="局部加权线性回归(Local Weighted Linear Regression)"></a>局部加权线性回归(Local Weighted Linear Regression)</h2><p>上面的数据点是通过公式$y = 3 + 1.7x + 0.1sin(30x)$添加噪声生成的数据，而标准的线性回归是一种无偏差估计，在计算所有点的时候都是无偏差的计算误差并通过优化方法优化误差，如果针对不同的点能够对误差进行调整便可以一定程度上避免标准线性回归带来的欠拟合现象。</p>
<p>也就是引入偏差来降低预测的均方误差，本部分总结下局部加权线性回归的方法。当我们获取某个$x$的预测值的时候，我们需要计算回归系数$w$，但是如果针对样本中的数据，距离$x$越近我们就给个越大的权重，如果距离越远就给一个小的权重，这样就会使得针对$x$的预测值$y_predict$能够更贴合样本数据。</p>
<p>当我们需要对数据点$x$相应的目标值进行预测的时候，我们需要给样本中的每个点赋予一个权重值$w_i$(为了区分权重和回归系数，在这里用$\theta$表示回归系数，$w$表示权重), 那么平方误差的表达式就变成:</p>
<p>$$<br>f(\theta) = \sum_{i=1}^{m}w_{i}(y_i - x_{i}^{T}\theta)^{2}<br>$$</p>
<p>通过矩阵可以表示成:<br>$$<br>f(\theta) = (y - X\theta)^{T}W(y - X\theta)<br>$$<br>$f(\theta)$对$\theta$求导等于0得到:<br>$$<br>\frac{\partial f(w)}{\partial w} = -2X^{T}W(y - X\theta) = 0 \\<br>X^{T}Wy = X^{T}WX\theta \\<br>\theta = (X^{T}WX)^{-1}X^{T}Wy<br>$$</p>
<p>通过上面的公式，对于任意给定的未知数据可以计算出对应的回归系数$\theta$，并得到相应的预测值$y_{predict}$, 其中$W$是一个对角矩阵，对角线上的元素$w_{ii}$对应样本点$x_i$的权重值。</p>
<h3 id="使用高斯核来赋值权重"><a href="#使用高斯核来赋值权重" class="headerlink" title="使用高斯核来赋值权重"></a>使用高斯核来赋值权重</h3><p>那么权重的表达式又是怎样的呢，我们需要距离给定$x$的样本点的权重越高，LWRL使用核来对附近的点赋予更高的权重，最常用的是高斯核函数，对应表达式如下:<br>$$<br>w_{ii} = exp(\frac{\vert x_i - x \vert}{-2k^2})<br>$$<br>通过公式可以看到如果$x_i$距离$x$的距离越小，$w_{ii}$就会越大，其中参数$k$决定了权重的大小。k越大权重的差距就越小，k越小权重的差距就很大，仅有局部的点参与进回归系数的求取，其他距离较远的权重都趋近于零。如果k去进入无穷大，所有的权重都趋近于1，$W$也就近似等于单位矩阵，局部加权线性回归变成标准的无偏差线性回归，会造成欠拟合的现象；当k很小的时候，距离较远的样本点无法参与回归参数的求取，会造成过拟合的现象。</p>
<h3 id="LWLR的Python实现"><a href="#LWLR的Python实现" class="headerlink" title="LWLR的Python实现"></a>LWLR的Python实现</h3><p>本部分对局部加权线性回归进行Python实现，对于给定数据求取相应回归系数:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">lwlr</span><span class="params">(x, X, Y, k)</span>:</span></div><div class="line">    <span class="string">''' 局部加权线性回归，给定一个点，获取相应权重矩阵并返回回归系数</span></div><div class="line">    '''</div><div class="line">    m = X.shape[<span class="number">0</span>]</div><div class="line"></div><div class="line">    <span class="comment"># 创建针对x的权重矩阵</span></div><div class="line">    W = np.matrix(np.zeros((m, m)))</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</div><div class="line">        xi = np.array(X[i][<span class="number">0</span>])</div><div class="line">        x = np.array(x)</div><div class="line">        W[i, i] = exp((np.linalg.norm(x - xi))/(<span class="number">-2</span>*k**<span class="number">2</span>))</div><div class="line"></div><div class="line">    <span class="comment"># 获取此点相应的回归系数</span></div><div class="line"></div><div class="line">    xWx = X.T*W*X</div><div class="line">    <span class="keyword">if</span> np.linalg.det(xWx) == <span class="number">0</span>:</div><div class="line">        print(<span class="string">'xWx is a singular matrix'</span>)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    w = xWx.I*X.T*W*Y</div><div class="line"></div><div class="line">    <span class="keyword">return</span> w</div></pre></td></tr></table></figure></p>
<p>我们对上部分使用的数据进行回归并绘制回归曲线:</p>
<h4 id="当k-0-5-基本上就是无偏差的标准线性回归"><a href="#当k-0-5-基本上就是无偏差的标准线性回归" class="headerlink" title="当k = 0.5, 基本上就是无偏差的标准线性回归"></a>当k = 0.5, 基本上就是无偏差的标准线性回归</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Correlation coefficient: <span class="number">0.9869292425124014</span></div></pre></td></tr></table></figure>
<p><img src="/assets/images/blog_img/2017-10-24-机器学习算法实践-标准与局部加权线性回归/lwlr_k05.png" alt=""></p>
<h4 id="当k-0-1-可以较好的反应数据的潜在规律"><a href="#当k-0-1-可以较好的反应数据的潜在规律" class="headerlink" title="当k = 0.1, 可以较好的反应数据的潜在规律"></a>当k = 0.1, 可以较好的反应数据的潜在规律</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Correlation coefficient: <span class="number">0.997890402610583</span></div></pre></td></tr></table></figure>
<p><img src="/assets/images/blog_img/2017-10-24-机器学习算法实践-标准与局部加权线性回归/lwlr_k01.png" alt=""></p>
<h4 id="当k-0-03-拟合的曲线较多的考虑了噪声数据导致过拟合的现象"><a href="#当k-0-03-拟合的曲线较多的考虑了噪声数据导致过拟合的现象" class="headerlink" title="当k = 0.03, 拟合的曲线较多的考虑了噪声数据导致过拟合的现象"></a>当k = 0.03, 拟合的曲线较多的考虑了噪声数据导致过拟合的现象</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Correlation coefficient: <span class="number">0.9995975498285312</span></div></pre></td></tr></table></figure>
<p><img src="/assets/images/blog_img/2017-10-24-机器学习算法实践-标准与局部加权线性回归/lwlr_k003.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文总结了标准线性回归以及局部加权线性回归的基础知识，并对两张回归方式给与了Python的实现。可见局部加权线性回归在取得适当的$k$，便可以较好的发现数据的内在潜质，但是局部加权线性回归有个缺点就是类似kNN一样，每计算一个点的预测值就需要利用所有数据样本进行计算，如果数据量很大，计算量会是一个问题。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Machine Learning in Action》</li>
<li><a href="https://www.zhihu.com/question/20852004" target="_blank" rel="external">如何通俗易懂地解释「协方差」与「相关系数」的概念？</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MachineLearning </tag>
            
            <tag> LinearRegression </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习算法实践-Platt SMO和遗传算法优化SVM]]></title>
      <url>http://pytlab.github.io/2017/10/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5-Platt-SMO%E5%92%8C%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96SVM/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前实现了简单的SMO算法来优化SVM的对偶问题，其中在选取$\alpha$的时候使用的是两重循环通过完全随机的方式选取，具体的实现参考《<a href="http://pytlab.github.io/2017/09/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5-SVM%E4%B8%AD%E7%9A%84SMO%E7%AE%97%E6%B3%95/">机器学习算法实践-SVM中的SMO算法</a>》。</p>
<p>本文在之前简化版SMO算法的基础上实现了使用启发式选取$\alpha$对的方式的Platt SMO算法来优化SVM。另外由于最近自己也实现了一个<a href="https://github.com/PytLab/gaft" target="_blank" rel="external">遗传算法框架GAFT</a>，便也尝试使用遗传算法对于SVM的原始形式进行了优化。</p>
<ul>
<li>对于本文算法的相应实现，参考:<a href="https://github.com/PytLab/MLBox/tree/master/svm" target="_blank" rel="external">https://github.com/PytLab/MLBox/tree/master/svm</a></li>
<li>遗传算法框架GAFT项目地址: <a href="https://github.com/PytLab/gaft" target="_blank" rel="external">https://github.com/PytLab/gaft</a></li>
</ul>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="SMO中启发式选择变量"><a href="#SMO中启发式选择变量" class="headerlink" title="SMO中启发式选择变量"></a>SMO中启发式选择变量</h3><p>在SMO算法中，我们每次需要选取一对$\alpha$来进行优化，通过启发式的选取我们可以更高效的选取待优化的变量使得目标函数下降的最快。</p>
<p>针对第一个$\alpha_1$和第二个$\alpha_2$ Platt SMO采取不同的启发式手段。</p>
<h4 id="第一个变量的选择"><a href="#第一个变量的选择" class="headerlink" title="第一个变量的选择"></a>第一个变量的选择</h4><p>第一个变量的选择为外循环，与之前便利整个$\alpha$列表不同，在这里我们在<strong>整个样本集</strong>和<strong>非边界样本集</strong>间进行交替:</p>
<ol>
<li><p>首先我们对整个训练集进行遍历, 检查是否违反KKT条件，如果改点的$\alpha_i$和$x_i, y_i$违反了KKT条件则说明改点需要进行优化。<br>Karush-Kuhn-Tucker(KKT)条件是正定二次规划问题最优点的充分必要条件。针对SVM对偶问题，KKT条件非常简单:<br>$$<br>\begin{cases}<br>\alpha_i = 0 \Longleftrightarrow y_i(w^{T}x_i + b) \ge 1 \\<br>\alpha_i = C \Longleftrightarrow y_i(w^{T}x_i + b) \le 1 \\<br>0 &lt; \alpha_i &lt; C \Longleftrightarrow y_i(w^{T}x_i + b) = 1<br>\end{cases}<br>$$</p>
</li>
<li><p>在遍历了整个训练集并优化了相应的$\alpha$后第二轮迭代我们仅仅需要遍历其中的非边界$\alpha$. 所谓的非边界$\alpha$就是指那些不等于边界0或者C的$\alpha$值。 同样这些点仍然需要检查是否违反KKT条件并进行优化.</p>
</li>
</ol>
<p>之后就是不断地在两个数据集中来回交替，最终所有的$\alpha$都满足KKT条件的时候，算法中止。</p>
<p>为了能够快速选取有最大步长的$\alpha$，我们需要对所有数据对应的误差进行缓存，因此特地写了个<code>SVMUtil</code>类来保存svm中重要的变量以及一些辅助方法:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SVMUtil</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    Struct to save all important values in SVM.</div><div class="line">    '''</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, dataset, labels, C, tolerance=<span class="number">0.001</span>)</span>:</span></div><div class="line">        self.dataset, self.labels, self.C = dataset, labels, C</div><div class="line"></div><div class="line">        self.m, self.n = np.array(dataset).shape</div><div class="line">        self.alphas = np.zeros(self.m)</div><div class="line">        self.b = <span class="number">0</span></div><div class="line">        self.tolerance = tolerance</div><div class="line">        <span class="comment"># Cached errors ,f(x_i) - y_i</span></div><div class="line">        self.errors = [self.get_error(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(self.m)]</div><div class="line"></div><div class="line">    <span class="comment"># 其他方法...</span></div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>下面为第一个变量选择交替遍历的大致代码，相应完整的Python实现(完整实现见<a href="https://github.com/PytLab/MLBox/blob/master/svm/svm_platt_smo.py" target="_blank" rel="external">https://github.com/PytLab/MLBox/blob/master/svm/svm_platt_smo.py</a>):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (it &lt; max_iter):</div><div class="line">    pair_changed = <span class="number">0</span></div><div class="line">    <span class="keyword">if</span> entire:</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(svm_util.m):</div><div class="line">            pair_changed += examine_example(i, svm_util)</div><div class="line">            print(<span class="string">'Full set - iter: &#123;&#125;, pair changed: &#123;&#125;'</span>.format(i, pair_changed))</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        alphas = svm_util.alphas</div><div class="line">        non_bound_indices = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(svm_util.m)</div><div class="line">                             <span class="keyword">if</span> alphas[i] &gt; <span class="number">0</span> <span class="keyword">and</span> alphas[i] &lt; C]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> non_bound_indices:</div><div class="line">            pair_changed += examine_example(i, svm_util)</div><div class="line"></div><div class="line">    ...</div><div class="line">...</div></pre></td></tr></table></figure></p>
<h4 id="第二个变量的选择"><a href="#第二个变量的选择" class="headerlink" title="第二个变量的选择"></a>第二个变量的选择</h4><p>SMO中的第二个变量的选择过程为内循环，当我们已经选取第一个$\alpha_1$之后，我们希望我们选取的第二个变量$\alpha_2$优化后能有较大的变化。根据我们之前推导的式子$\alpha_{2}^{new, unclipped} = \alpha_{2}^{old} + \frac{y_{2}(E_{1} - E_{2})}{\eta}$ 可以知道，新的$\alpha_2$的变化依赖于$\lvert E_1 - E_2 \rvert$, 当$E_1$为正时， 那么选择最小的$E_i$作为$E_2$，通常将每个样本的$E_i$缓存到一个列表中，通过在列表中选择具有$\lvert E_1 - E_2 \rvert$的$\alpha_2$来近似最大化步长。</p>
<p>有时候按照上述的启发式方式仍不能够是的函数值有足够的下降，这是按下述步骤进行选择:</p>
<ol>
<li>在非边界数据集上选择能够使函数值足够下降的样本作为第二个变量</li>
<li>如果非边界数据集上没有，则在整个数据仅上进行第二个变量的选择</li>
<li>如果仍然没有则重新选择第一个$\alpha_1$</li>
</ol>
<p>第二个变量选取的Python实现:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_j</span><span class="params">(i, svm_util)</span>:</span></div><div class="line">    <span class="string">''' 通过最大化步长的方式来获取第二个alpha值的索引.</span></div><div class="line">    '''</div><div class="line">    errors = svm_util.errors</div><div class="line">    valid_indices = [i <span class="keyword">for</span> i, a <span class="keyword">in</span> enumerate(svm_util.alphas) <span class="keyword">if</span> <span class="number">0</span> &lt; a &lt; svm_util.C]</div><div class="line"></div><div class="line">    <span class="keyword">if</span> len(valid_indices) &gt; <span class="number">1</span>:</div><div class="line">        j = <span class="number">-1</span></div><div class="line">        max_delta = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> valid_indices:</div><div class="line">            <span class="keyword">if</span> k == i:</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            delta = abs(errors[i] - errors[j])</div><div class="line">            <span class="keyword">if</span> delta &gt; max_delta:</div><div class="line">                j = k</div><div class="line">                max_delta = delta</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        j = select_j_rand(i, svm_util.m)</div><div class="line">    <span class="keyword">return</span> j</div></pre></td></tr></table></figure></p>
<h4 id="KKT条件允许一定的误差"><a href="#KKT条件允许一定的误差" class="headerlink" title="KKT条件允许一定的误差"></a>KKT条件允许一定的误差</h4><p>在Platt论文中的KKT条件的判断中有一个<code>tolerance</code>允许一定的误差，相应的Python实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">r = E_i*y_i</div><div class="line"></div><div class="line"><span class="comment"># 是否违反KKT条件</span></div><div class="line"><span class="keyword">if</span> (r &lt; -tolerance <span class="keyword">and</span> alpha &lt; C) <span class="keyword">or</span> (r &gt; tolerance <span class="keyword">and</span> alpha &gt; <span class="number">0</span>):</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>关于Platt SMO的完整实现详见:<a href="https://github.com/PytLab/MLBox/blob/master/svm/svm_platt_smo.py" target="_blank" rel="external">https://github.com/PytLab/MLBox/blob/master/svm/svm_platt_smo.py</a></p>
<p>针对之前的数据集我们使用Platt SMO进行优化可以得到：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">w = [<span class="number">0.8289668843516077</span>, <span class="number">-0.26578914269411114</span>]</div><div class="line">b = <span class="number">-3.9292583040559448</span></div></pre></td></tr></table></figure></p>
<p>将分割线和支持向量可视化：</p>
<p><img src="/assets/images/blog_img/2017-10-15-机器学习算法实践-Platt-SMO和遗传算法优化SVM/platt_smo.png" alt=""></p>
<p>可见通过Platt SMO优化出来的支持向量与简化版的SMO算法有些许不同。</p>
<h3 id="使用遗传算法优化SVM"><a href="#使用遗传算法优化SVM" class="headerlink" title="使用遗传算法优化SVM"></a>使用遗传算法优化SVM</h3><p>由于最近自己写了个遗传算法框架，遗传算法作为一个启发式无导型的搜索算法非常易用，于是我就尝试使用遗传算法来优化SVM。</p>
<p>使用遗传算法优化，我们就可以直接优化SVM的最初形式了也就是最直观的形式:<br>$$<br>arg \max \limits_{w, b} \{ \min \limits_{n} (y_{i} \cdot (w^{T}x + b)) \cdot \frac{1}{\lVert w \rVert} \}<br>$$</p>
<p>顺便再安利下自己的遗传算法框架，在此框架的帮助下，优化SVM算法我们只需要写几十行的Python代码即可。其中最主要的就是编写适应度函数，根据上面的公式我们需要计算数据集中每个点到分割线的距离并返回<strong>最小</strong>的距离即可，然后放到遗传算法中进行进化迭代。</p>
<p>遗传算法框架GAFT项目地址: <a href="https://github.com/PytLab/gaft" target="_blank" rel="external">https://github.com/PytLab/gaft</a> , 使用方法详见README。</p>
<p>Ok， 我们开始构建种群用于进化迭代。</p>
<h4 id="创建个体与种群"><a href="#创建个体与种群" class="headerlink" title="创建个体与种群"></a>创建个体与种群</h4><p>对于二维数据点，我们需要优化的参数只有三个也就是$[w_1, w_2]$和$b$, 个体的定义如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">indv_template = GAIndividual(ranges=[(<span class="number">-2</span>, <span class="number">2</span>), (<span class="number">-2</span>, <span class="number">2</span>), (<span class="number">-5</span>, <span class="number">5</span>)],</div><div class="line">                             encoding=<span class="string">'binary'</span>,</div><div class="line">                             eps=[<span class="number">0.001</span>, <span class="number">0.001</span>, <span class="number">0.005</span>])</div></pre></td></tr></table></figure>
<p>种群大小这里取600，创建种群<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">population = GAPopulation(indv_template=indv_template, size=<span class="number">600</span>).init()</div></pre></td></tr></table></figure></p>
<h4 id="创建遗传算子和GA引擎"><a href="#创建遗传算子和GA引擎" class="headerlink" title="创建遗传算子和GA引擎"></a>创建遗传算子和GA引擎</h4><p>这里没有什么特别的，直接使用框架中内置的算子就好了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">selection = RouletteWheelSelection()</div><div class="line">crossover = UniformCrossover(pc=<span class="number">0.8</span>, pe=<span class="number">0.5</span>)</div><div class="line">mutation = FlipBitBigMutation(pm=<span class="number">0.1</span>, pbm=<span class="number">0.55</span>, alpha=<span class="number">0.6</span>)</div><div class="line"></div><div class="line">engine = GAEngine(population=population, selection=selection,</div><div class="line">                  crossover=crossover, mutation=mutation,</div><div class="line">                  analysis=[ConsoleOutput, FitnessStore])</div></pre></td></tr></table></figure></p>
<h4 id="适应度函数"><a href="#适应度函数" class="headerlink" title="适应度函数"></a>适应度函数</h4><p>这一部分只要把上面svm初始形式描述出来就好了，只需要三行代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@engine.fitness_register</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fitness</span><span class="params">(indv)</span>:</span></div><div class="line">    w, b = indv.variants[: <span class="number">-1</span>], indv.variants[<span class="number">-1</span>]</div><div class="line">    min_dis = min([y*(np.dot(w, x) + b) <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(dataset, labels)])</div><div class="line">    <span class="keyword">return</span> float(min_dis)</div></pre></td></tr></table></figure></p>
<h4 id="开始迭代"><a href="#开始迭代" class="headerlink" title="开始迭代"></a>开始迭代</h4><p>这里迭代300代种群<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="string">'__main__'</span> == __name__:</div><div class="line">    engine.run(<span class="number">300</span>)</div></pre></td></tr></table></figure></p>
<h4 id="绘制遗传算法优化的分割线"><a href="#绘制遗传算法优化的分割线" class="headerlink" title="绘制遗传算法优化的分割线"></a>绘制遗传算法优化的分割线</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">variants = engine.population.best_indv(engine.fitness).variants</div><div class="line">w = variants[: <span class="number">-1</span>]</div><div class="line">b = variants[<span class="number">-1</span>]</div><div class="line"></div><div class="line"><span class="comment"># 分类数据点</span></div><div class="line">classified_pts = &#123;<span class="string">'+1'</span>: [], <span class="string">'-1'</span>: []&#125;</div><div class="line"><span class="keyword">for</span> point, label <span class="keyword">in</span> zip(dataset, labels):</div><div class="line">    <span class="keyword">if</span> label == <span class="number">1.0</span>:</div><div class="line">        classified_pts[<span class="string">'+1'</span>].append(point)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        classified_pts[<span class="string">'-1'</span>].append(point)</div><div class="line"></div><div class="line">fig = plt.figure()</div><div class="line">ax = fig.add_subplot(<span class="number">111</span>)</div><div class="line"></div><div class="line"><span class="comment"># 绘制数据点</span></div><div class="line"><span class="keyword">for</span> label, pts <span class="keyword">in</span> classified_pts.items():</div><div class="line">    pts = np.array(pts)</div><div class="line">    ax.scatter(pts[:, <span class="number">0</span>], pts[:, <span class="number">1</span>], label=label)</div><div class="line"></div><div class="line"><span class="comment"># 绘制分割线</span></div><div class="line">x1, _ = max(dataset, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</div><div class="line">x2, _ = min(dataset, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</div><div class="line">a1, a2 = w</div><div class="line">y1, y2 = (-b - a1*x1)/a2, (-b - a1*x2)/a2</div><div class="line">ax.plot([x1, x2], [y1, y2])</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p>得到的分割曲线如下图：</p>
<p><img src="/assets/images/blog_img/2017-10-15-机器学习算法实践-Platt-SMO和遗传算法优化SVM/svm_ga.png" alt=""></p>
<p>完整的代码详见: <a href="https://github.com/PytLab/MLBox/blob/master/svm/svm_ga.py" target="_blank" rel="external">https://github.com/PytLab/MLBox/blob/master/svm/svm_ga.py</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对SVM的优化进行了介绍，主要实现了Platt SMO算法优化SVM模型，并尝试使用遗传算法框架GAFT对初始SVM进行了优化。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.researchgate.net/publication/2624239_Sequential_Minimal_Optimization_A_Fast_Algorithm_for_Training_Support_Vector_Machines?enrichId=rgreq-2d15adb4fdbd3450fc47381a44207c68-XXX&amp;enrichSource=Y292ZXJQYWdlOzI2MjQyMzk7QVM6OTc2NzgyNzY5NTYxNjBAMTQwMDI5OTcyNDA4Mg%3D%3D&amp;el=1_x_3&amp;_esc=publicationCoverPdf" target="_blank" rel="external">Sequential Minimal Optimization: A Fast Algorithm for Training Support Vector Machines</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MachineLearning </tag>
            
            <tag> GeneticAlgorithm </tag>
            
            <tag> SVM </tag>
            
            <tag> SMO </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[遗传算法框架GAFT优化小记]]></title>
      <url>http://pytlab.github.io/2017/10/08/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6GAFT%E4%BC%98%E5%8C%96%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间一直在用自己写的遗传算法框架测试算法在优化力场参数的效果，但是跑起来效率很慢，因为适应度函数需要调用多次力场程序计算能量，但是还是比我预想中的慢我也没有及时对程序进行profiling和优化。直到放假前在github有个使用gaft做SVM参数优化的童鞋开了个<a href="https://github.com/PytLab/gaft/issues/2" target="_blank" rel="external">issue</a>中说道在gaft优化的过程中会大量调用适应度函数，这才使我在国庆放假期间对gaft进行了profiling找到程序瓶颈并针对性的优化。</p>
<p>本文就记录下自己gaft做profiling并优化的过程以及优化的效果。</p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="对GAFT进行性能分析-Profiling"><a href="#对GAFT进行性能分析-Profiling" class="headerlink" title="对GAFT进行性能分析(Profiling)"></a>对GAFT进行性能分析(Profiling)</h3><p>关于如何对Python程序进行性能分析生成分析报告并可视化分析报告，我在之前的一篇博客里《<a href="http://pytlab.github.io/2016/12/20/Python%E4%BC%98%E5%8C%96%E7%AC%AC%E4%B8%80%E6%AD%A5-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%AE%9E%E8%B7%B5/">Python优化第一步: 性能分析实践</a>》进行了详细的介绍，这里我就直接分析了。</p>
<p>为了能针对gaft中不同的函数进行分析，借助Python内置的<code>cProfile</code>和<code>pstats</code>模块我写了个装饰器方便分析并生成不同的分析统计文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_profile</span><span class="params">(filename, sortby=<span class="string">'tottime'</span>)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    Constructor for function profiling decorator.</div><div class="line">    '''</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_do_profile</span><span class="params">(func)</span>:</span></div><div class="line">        <span class="string">'''</span></div><div class="line">        Function profiling decorator.</div><div class="line">        '''</div><div class="line"><span class="meta">        @wraps(func)</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">profiled_func</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">            <span class="string">'''</span></div><div class="line">            Decorated function.</div><div class="line">            '''</div><div class="line">            <span class="comment"># Flag for doing profiling or not.</span></div><div class="line">            DO_PROF = os.getenv(<span class="string">'PROFILING'</span>)</div><div class="line"></div><div class="line">            <span class="keyword">if</span> DO_PROF:</div><div class="line">                profile = cProfile.Profile()</div><div class="line">                profile.enable()</div><div class="line">                result = func(*args, **kwargs)</div><div class="line">                profile.disable()</div><div class="line">                ps = pstats.Stats(profile).sort_stats(sortby)</div><div class="line">                ps.dump_stats(filename)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                result = func(*args, **kwargs)</div><div class="line">            <span class="keyword">return</span> result</div><div class="line">        <span class="keyword">return</span> profiled_func</div><div class="line"></div><div class="line">    <span class="keyword">return</span> _do_profile</div></pre></td></tr></table></figure>
<p>对上面的带参数的装饰器我在这里稍微解释下，装饰器构造器<code>do_profile</code>的两个参数<code>filename</code>和<code>sortby</code>分别指定分析结果报告的文件名以及统计结果的排序方式。它会对需要进行性能分析的函数进行装饰，然后在函数运行完后在当前目录生成结果报告。例如我需要对gaft中遗传算法迭代主循环进行分析，则需要:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@do_profile(filename='gaft_run.prof')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, ng=<span class="number">100</span>)</span>:</span></div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>同时为了方便，我还需要一个环境变量<code>PROFILING</code>来启动分析:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PROFILING=y</div></pre></td></tr></table></figure></p>
<h3 id="分析结果"><a href="#分析结果" class="headerlink" title="分析结果"></a>分析结果</h3><p>这里为了方便查看函数的相互调用关系，我是用了pyprof2calltree 然后使用Mac上的QCacheGrind来可视化分析结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pyprof2calltree -i gaft_run.prof -k</div></pre></td></tr></table></figure>
<p>将Python的profiling文件转换并直接调用QCacheGrind便可以方便的查看分析相关信息。</p>
<p><img src="/assets/images/blog_img/2017-10-08-遗传算法框架GAFT优化小记/original.png" alt=""></p>
<p>通过调用关系图可以看到，gaft的初始版本的<code>min</code>,<code>max</code>,<code>mean</code>等函数多次调用<code>best_indv</code>和<code>worst_indv</code>会多次调用适应度函数来相互比较，而通常情况下用户自定义的适应度函数都是需要额外去调用外部程序的，一般都比较费时。所以必须要通过优化<code>best_indv</code>和<code>worst_indv</code>对<code>fitness</code>的调用次数才能提升gaft的效率。</p>
<h3 id="优化GAFT"><a href="#优化GAFT" class="headerlink" title="优化GAFT"></a>优化GAFT</h3><h4 id="函数返回值缓存"><a href="#函数返回值缓存" class="headerlink" title="函数返回值缓存"></a>函数返回值缓存</h4><p>从之前我写的<code>best_indv</code>中可以看到，我将<code>fitness</code>作为<code>key</code>用于获取最大值，Python内置的<code>max</code>函数会内部调用<code>fitness</code>进行相互比较来获取最大值，这个时候便对<code>fitness</code>进行了多余的调用，因为在遗传算法中，每一代的population中的个体是不会发生变化的我们只需要在每一次迭代的一开始调用<code>fitness</code>n次就好了(n为种群大小)，每一代中再次需要用到适应度值的地方直接获取。这样需要我们对种群中的个体进行惰性求值，也就是对所有的fitness的值进行缓存。这种操作我在优化自己的催化动力学程序的时候也使用过，叫做<strong>函数返回值缓存</strong>.</p>
<p>但是在gaft中这种缓存有稍微麻烦一点，因为缓存并不是缓存一次就可以一直用了，它会随着条件的变化需要重新计算种群中所有个体的适应度然后重新缓存。</p>
<h4 id="重新计算适应度值需要同时满足的条件"><a href="#重新计算适应度值需要同时满足的条件" class="headerlink" title="重新计算适应度值需要同时满足的条件"></a>重新计算适应度值需要同时满足的条件</h4><ol>
<li>种群中的所有个体没有发生任何变化 (如果变化了那肯定要重新计算适应度值了)。</li>
<li>已有缓存的适应度值 (如果是第一次那肯定需要计算一次所有个体的适应度值)。</li>
<li>计算适应度值的适应度函数与之前比较没有发生变化(如果计算适应度函数都改变了，那当然需要重新估计适应度值了)。</li>
</ol>
<h4 id="函数返回值缓存描述符"><a href="#函数返回值缓存描述符" class="headerlink" title="函数返回值缓存描述符"></a>函数返回值缓存描述符</h4><p>为此我写了个装饰器来缓存函数的返回值:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memoized</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    Descriptor for population statistical varibles caching.</div><div class="line">    '''</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></div><div class="line">        self.func = func</div><div class="line">        self.result = <span class="keyword">None</span></div><div class="line">        self.fitness = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, cls)</span>:</span></div><div class="line">        self.instance = instance</div><div class="line">        <span class="keyword">return</span> self</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, fitness)</span>:</span></div><div class="line">        <span class="keyword">if</span> ((<span class="keyword">not</span> self.instance._updated)         <span class="comment"># population not changed</span></div><div class="line">                <span class="keyword">and</span> (self.result <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>)    <span class="comment"># result already cached</span></div><div class="line">                <span class="keyword">and</span> (fitness == self.fitness)):  <span class="comment"># fitness not changed</span></div><div class="line">            <span class="comment"># Return cached result directly.</span></div><div class="line">            <span class="keyword">return</span> self.result</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="comment"># Update fitness function.</span></div><div class="line">            self.fitness = fitness</div><div class="line">            <span class="comment"># Update and memoize result.</span></div><div class="line">            self.result = self.func(self.instance, fitness)</div><div class="line">            <span class="comment"># Recover flag.</span></div><div class="line">            self.instance._updated = <span class="keyword">False</span></div><div class="line">            <span class="keyword">return</span> self.result</div></pre></td></tr></table></figure>
<h4 id="动态监视种群的变化"><a href="#动态监视种群的变化" class="headerlink" title="动态监视种群的变化"></a>动态监视种群的变化</h4><p>好了上面我们可以通过描述符来缓存函数返回值，但是一旦种群不满足上述的三个条件就需要重新计算适应度值，那我们如何监控种群的变化呢？</p>
<p>我在<code>GAPopulation</code>中添加了一个标记<code>_updated</code>用于标记种群是否已经发生了变化, 然后我们的任务就是在其他能够影响到种群的地方试图去更新这个flag。</p>
<p><strong>如何能更Pythonic的更新这个标记呢？</strong></p>
<p>所谓的种群发生变化，也是就种群中的个体列表发生了变化，种群中的个体我都放在了一个列表中，我需要监控这个列表是否发生变化以便更新flag，具体又是那些变化呢？</p>
<ol>
<li>列表整体是否发生了变化(赋值操作)</li>
<li>列表中的元素是否发生变化(对列表中的元素赋值操作，列表的<code>append</code>, <code>extend</code>操作等)</li>
</ol>
<p><strong>好了我们要具体怎么实现呢？</strong></p>
<ol>
<li><p>对于第一种，由于Python中无法进行赋值运算符重载，但是我们可以通过描述符的<code>__set__</code>来处理:</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GAIndividuals</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    Descriptor for all individuals in population.</div><div class="line">    '''</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line">        self.name = <span class="string">'_&#123;&#125;'</span>.format(name)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></div><div class="line">        <span class="keyword">return</span> instance.__dict__[self.name]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></div><div class="line">        instance.__dict__[self.name] = value</div><div class="line">        <span class="comment"># Update flag.</span></div><div class="line">        instance._updated = <span class="keyword">True</span></div></pre></td></tr></table></figure>
</li>
<li><p>对于第二种情况，我们需要对Python的List类型的相应方法进行override</p>
<p> 但是嘞，即使重写了list的接口，又如何更新population中的变量呢？这个时候就需要用闭包了。在<code>GAPopulation</code>的构造函数<code>__init__</code>中定义list的派生类，并立即实例化，这时候派生类的便可以获取population对象了，于是<code>GAPopulation</code>的构造函数可以这些写:</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, indv_template, size=<span class="number">100</span>)</span>:</span></div><div class="line"></div><div class="line">    <span class="comment"># ...</span></div><div class="line"></div><div class="line">    <span class="comment"># Flag for monitoring changes of population.</span></div><div class="line">    self._updated = <span class="keyword">False</span></div><div class="line"></div><div class="line">    <span class="comment"># Container for all individuals.</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">IndvList</span><span class="params">(list)</span>:</span></div><div class="line">        <span class="string">'''</span></div><div class="line">        A proxy class inherited from built-in list to contain all</div><div class="line">        individuals which can update the population._updated flag</div><div class="line">        automatically when its content is changed.</div><div class="line">        '''</div><div class="line">        <span class="comment"># <span class="doctag">NOTE:</span> Use 'this' here to avoid name conflict.</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(this, *args)</span>:</span></div><div class="line">            super(this.__class__, this).__init__(*args)</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(this, key, value)</span>:</span></div><div class="line">            <span class="string">'''</span></div><div class="line">            Override __setitem__ in built-in list type.</div><div class="line">            '''</div><div class="line">            old_value = this[key]</div><div class="line">            <span class="keyword">if</span> old_value == value:</div><div class="line">                <span class="keyword">return</span></div><div class="line">            super(this.__class__, self).__setitem__(key, value)</div><div class="line">            <span class="comment"># Update population flag.</span></div><div class="line">            self._updated = <span class="keyword">True</span></div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(this, item)</span>:</span></div><div class="line">            <span class="string">'''</span></div><div class="line">            Override append method of built-in list type.</div><div class="line">            '''</div><div class="line">            super(this.__class__, this).append(item)</div><div class="line">            <span class="comment"># Update population flag.</span></div><div class="line">            self._updated = <span class="keyword">True</span></div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">extend</span><span class="params">(this, iterable_item)</span>:</span></div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> iterable_item:</div><div class="line">                <span class="keyword">return</span></div><div class="line">            super(this.__class__, this).extend(iterable_item)</div><div class="line">            <span class="comment"># Update population flag.</span></div><div class="line">            self._updated = <span class="keyword">True</span></div><div class="line"></div><div class="line">    self._individuals = IndvList()</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="优化效果"><a href="#优化效果" class="headerlink" title="优化效果"></a>优化效果</h3><p>通过上面对代码的优化，我们看看我们优化的效果如何，使用分析描述符来分析<code>GAEngine.run</code>跑一代种群的情况，其中种群大小为10。如下图为cProfile生成的分析报告对比:</p>
<p><img src="/assets/images/blog_img/2017-10-08-遗传算法框架GAFT优化小记/time.png" alt=""></p>
<p>可以看到优化后的跑一代种群的时间缩短为将近原来的<strong>1/7</strong>! 优化效果还是很明显的。</p>
<p>然后看一看调用关系图:</p>
<p><img src="/assets/images/blog_img/2017-10-08-遗传算法框架GAFT优化小记/optimized.png" alt=""></p>
<p><code>energy_fitness</code>的调用次数从3807降到了621次！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文记录了遗传算法框架GAFT的一次profiling和优化过程，通过缓存值的方式极大的减少了适值函数的调用次数，在时间上，跑一代种群的效率提升了7倍左右。</p>
]]></content>
      
        <categories>
            
            <category> 代码作品 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> GeneticAlgorithm </tag>
            
            <tag> gaft </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[遗传算法中适值函数的标定与大变异算法]]></title>
      <url>http://pytlab.github.io/2017/09/23/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E4%B8%AD%E9%80%82%E5%80%BC%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%87%E5%AE%9A%E4%B8%8E%E5%A4%A7%E5%8F%98%E5%BC%82%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文尝试对遗传算法中不同适值函数的标定(Scaling)方法进行下总结，并针对常用的线性标定和动态线性标定进行了Python实现，以装饰器的形式添加到遗传算法框架GAFT中，这样在使用GAFT运行遗传算法迭代的时候可以更加Pythonic的给自定义的适值函数进行标定。最后针对能够防止早熟情况的大变异算法进行了相应的实现。</p>
<p>目前(动态)线性标定装饰器以及大变异算子均已添加到GAFT中，gaft项目链接:</p>
<ul>
<li>GitHub: <a href="https://github.com/PytLab/gaft" target="_blank" rel="external">https://github.com/PytLab/gaft</a></li>
<li>PyPI: <a href="https://pypi.python.org/pypi/gaft" target="_blank" rel="external">https://pypi.python.org/pypi/gaft</a></li>
</ul>
<a id="more"></a>
<h2 id="适值函数的标定"><a href="#适值函数的标定" class="headerlink" title="适值函数的标定"></a>适值函数的标定</h2><h3 id="选择压力"><a href="#选择压力" class="headerlink" title="选择压力"></a>选择压力</h3><blockquote>
<p>The tendency to select the best member of the current generation is known as selective pressure.</p>
</blockquote>
<p>选择压力也就是种群中最好个体与最坏个体被选中概率的差值，这个差距越大，选中好个体的趋势就越大，则成为选择压力大。</p>
<h3 id="适值函数的标定-1"><a href="#适值函数的标定-1" class="headerlink" title="适值函数的标定"></a>适值函数的标定</h3><p>一般情况下，直接拿目标函数作为适值函数十分的方便，但是很多情况下却不能这么做，例如对于求最小值问题，我们必须将目标函数取反才能作为适值函数(这是最简单的情况)。</p>
<p>当我们遗传算法中不同个体适值函数的值相对差别很小的时候，我们根据适应度值的大小进行个体选择的选择压力(Selective pressure)就会变小，选优的能力弱化，这个时候我们需要对原始的适值函数进行标定(Scaling)是的他们<strong>相对</strong>差别增大，进而增大选择压力，增强算法的选优能力。</p>
<p>例如:<br>$$<br>\left[\begin{matrix}<br>f_1 = 1001 \\<br>f_2 = 1002 \\<br>f_3 = 999 \\<br>f_4 = 997 \\<br>\end{matrix} \right] \xrightarrow{scaling} \left[\begin{matrix}<br>f_1’ = f_1 - f_4 = 4 \\<br>f_2’ = f_2 - f_4 = 5 \\<br>f_3’ = f_3 - f_4 = 2 \\<br>f_4’ = f_4 - f_4 = 0<br>\end{matrix} \right]<br>$$</p>
<h3 id="局部搜索、广域搜索与选择压力的关系"><a href="#局部搜索、广域搜索与选择压力的关系" class="headerlink" title="局部搜索、广域搜索与选择压力的关系"></a>局部搜索、广域搜索与选择压力的关系</h3><p>在遗传算法中，局部搜索同广域搜索其实相互矛盾的，注重局部搜索则会陷入局部最优，但是注重广域搜索会导致算法精确开发能力不强。因此需要综合两者考虑，我们可以在搜索刚刚开始的时候使用较小的选择压力来广域搜索，随着迭代的进行可以动态的增大选择压力来使算法偏向于局部搜索。</p>
<h2 id="几种不同的适值函数标定方法"><a href="#几种不同的适值函数标定方法" class="headerlink" title="几种不同的适值函数标定方法"></a>几种不同的适值函数标定方法</h2><p>对目标函数的标定方法一般有:线性标定、动态线性标定、幂律标定、对数标定等</p>
<h3 id="线性标定"><a href="#线性标定" class="headerlink" title="线性标定"></a>线性标定</h3><p>线性标定的形式:<br>$$<br>f’ = af + b<br>$$<br>其中$f’$为标定后的适值函数，$f$为原始的目标函数。</p>
<h4 id="求最大值"><a href="#求最大值" class="headerlink" title="求最大值"></a>求最大值</h4><p>对于求目标函数的最大值的时候, 即 $arg \max f(x)$</p>
<p>我们取$a = 1, b = -f_{min} + \xi$, 其中$\xi$是一个较小的数，目的是使得种群中最差个体也有被选中的机会，不然自身减掉$f - f_{min} = 0$, $\xi$的存在可以增加种群的多样性。</p>
<p>最终的适值函数表达式:<br>$$f’ = f(x) - f_{min} + \xi$$</p>
<h4 id="求最小值"><a href="#求最小值" class="headerlink" title="求最小值"></a>求最小值</h4><p>当我们需要求目标函数最小值的时候，$arg \min f(x)$，我们需要对目标函数进行取反操作, 即<br>$a = -1, b = f_{max} - f(x) + \xi$</p>
<p>最终的适值函数表达式:<br>$$f’ = f_{max} - f(x) + \xi$$</p>
<h4 id="GAFT中添加对于目标函数的标定"><a href="#GAFT中添加对于目标函数的标定" class="headerlink" title="GAFT中添加对于目标函数的标定"></a>GAFT中添加对于目标函数的标定</h4><p>由于适值函数标定并不针对某个目标函数，我便想通过装饰器的方式来方便给任何自定义的fitness函数进行标定。对于基本的线性标定，我在<code>GAEngine</code>中添加了个带参数的装饰器:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_scaling</span><span class="params">(self, target=<span class="string">'max'</span>, ksi=<span class="number">0.5</span>)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    A decorator constructor for fitness function linear scaling.</div><div class="line"></div><div class="line">    :param target: The optimization target, maximization or minimization.</div><div class="line">    :type target: str, 'max' or 'min'</div><div class="line"></div><div class="line">    :param ksi: Selective pressure adjustment value.</div><div class="line">    :type ksi: float</div><div class="line"></div><div class="line">    Linear Scaling:</div><div class="line">        1. arg max f(x), then f' = f - min&#123;f(x)&#125; + ksi;</div><div class="line">        2. arg min f(x), then f' = max&#123;f(x)&#125; - f(x) + ksi;</div><div class="line">    '''</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_linear_scaling</span><span class="params">(fn)</span>:</span></div><div class="line">        <span class="comment"># For original fitness calculation.</span></div><div class="line">        self.ori_fitness = fn</div><div class="line"></div><div class="line"><span class="meta">        @wraps(fn)</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_fn_with_linear_scaling</span><span class="params">(indv)</span>:</span></div><div class="line">            <span class="comment"># Original fitness value.</span></div><div class="line">            f = fn(indv)</div><div class="line"></div><div class="line">            <span class="comment"># Determine the value of a and b.</span></div><div class="line">            <span class="keyword">if</span> target == <span class="string">'max'</span>:</div><div class="line">                f_prime = f - self.ori_fmin + ksi</div><div class="line">            <span class="keyword">elif</span> target == <span class="string">'min'</span>:</div><div class="line">                f_prime = self.ori_fmax - f + ksi</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">raise</span> ValueError(<span class="string">'Invalid target type(&#123;&#125;)'</span>.format(target))</div><div class="line">            <span class="keyword">return</span> f_prime</div><div class="line"></div><div class="line">        <span class="keyword">return</span> _fn_with_linear_scaling</div><div class="line"></div><div class="line">    <span class="keyword">return</span> _linear_scaling</div></pre></td></tr></table></figure></p>
<p>这个时候如果我们在定义了一个自己的目标函数以后，想对其进行线性标定便可以使用engine的这个装饰器对函数进行修饰即可, 像下面这样:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Create a GA engine...</span></div><div class="line"></div><div class="line"><span class="comment"># 先标定，后注册到引擎中</span></div><div class="line"><span class="meta">@engine.fitness_register</span></div><div class="line"><span class="meta">@engine.linear_scaling(target='min', ksi=0.5)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fitness</span><span class="params">(indv)</span>:</span></div><div class="line">    x, = indv.variants</div><div class="line">    <span class="keyword">return</span> x + <span class="number">10</span>*sin(<span class="number">5</span>*x) + <span class="number">7</span>*cos(<span class="number">4</span>*x)</div></pre></td></tr></table></figure></p>
<p>其中装饰器中的参数分别为:</p>
<ul>
<li><code>target</code>: 优化目标函数到最小值还是最大值，值可以是:<code>&#39;max&#39;</code>或者<code>&#39;min&#39;</code></li>
<li><code>ksi</code>: 即公式中$\xi$</li>
</ul>
<h3 id="动态线性标定"><a href="#动态线性标定" class="headerlink" title="动态线性标定"></a>动态线性标定</h3><p>动态线性标定是遗传算法中最常用的标定方法，他是基于上面提到的线性标定，在线性标定中的$\xi$在动态线性标定中并不是一成不变的，而是随着迭代次数的增加而变化。</p>
<p>动态线性标定的函数表达式:<br>$$f’ = a^{k}f + b^{k}$$<br>其中，$k$为迭代指标，表示$\xi$会随着迭代数而不同。</p>
<h4 id="求最大值-1"><a href="#求最大值-1" class="headerlink" title="求最大值"></a>求最大值</h4><p>当我们的优化目标是目标函数的最大值，这是我们取$a^{k} = 1, b^{k} = -f_{min} + \xi^{k}$, 这是的函数表达为:<br>$$f’ = f - f_{min} + \xi^{k}$$</p>
<h4 id="求最小值-1"><a href="#求最小值-1" class="headerlink" title="求最小值"></a>求最小值</h4><p>求最小值的时候需要取反操作，这时取$a^{k} = -1, b^{k} = f_{max} + \xi^{k}$, 最终函数表达式:<br>$$f’ = f_{max} - f + \xi^{k}$$</p>
<h4 id="关于-xi-k"><a href="#关于-xi-k" class="headerlink" title="关于$\xi^{k}$"></a>关于$\xi^{k}$</h4><p>动态线性标定中的$\xi^{k}$作用同线性标定中的$\xi$为<strong>选择压力调节值</strong>, 它的存在使得种群中最坏的个体仍有被选中的机会，但是动态标定中的$\xi^{k}$的值会随着$k$增大而减小。</p>
<p>$\xi^{k}$的取值: $\xi^{0} = M, \xi^{k} = \xi^{k-1}\cdot r, r \in \left[0.9, 0.999\right]$, 我们通过调节$M$和$r$来调节$\xi^{k}$</p>
<p>通过可以动态变化的$\xi^{k}$，我们可以使广域搜索范围宽保持种群的多样性，局部搜索保持收敛性，即，开始时希望选择小，迭代到后面希望选择压力逐渐变大.</p>
<h4 id="GAFT中添加给目标函数添加动态线性标定"><a href="#GAFT中添加给目标函数添加动态线性标定" class="headerlink" title="GAFT中添加给目标函数添加动态线性标定"></a>GAFT中添加给目标函数添加动态线性标定</h4><p>与上面线性标定的方法相同，GAFT中同样使用了标定装饰器来装饰用户自定义的目标函数，实现代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dynamic_linear_scaling</span><span class="params">(self, target=<span class="string">'max'</span>, ksi0=<span class="number">2</span>, r=<span class="number">0.9</span>)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    A decorator constructor for fitness dynamic linear scaling.</div><div class="line"></div><div class="line">    :param target: The optimization target, maximization or minimization.</div><div class="line">    :type target: str, 'max' or 'min'</div><div class="line"></div><div class="line">    :param ksi0: Initial selective pressure adjustment value, default value</div><div class="line">                 is 2</div><div class="line">    :type ksi0: float</div><div class="line"></div><div class="line">    :param r: The reduction factor for selective pressure adjustment value,</div><div class="line">              ksi^(k-1)*r is the adjustment value for generation k, default</div><div class="line">              value is 0.9</div><div class="line">    :type r: float in range [0.9, 0.999]</div><div class="line"></div><div class="line">    Dynamic Linear Scaling:</div><div class="line">        For maximizaiton, f' = f(x) - min&#123;f(x)&#125; + ksi^k, k is generation number.</div><div class="line">    '''</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_dynamic_linear_scaling</span><span class="params">(fn)</span>:</span></div><div class="line">        <span class="comment"># For original fitness calculation.</span></div><div class="line">        self.ori_fitness = fn</div><div class="line"></div><div class="line"><span class="meta">        @wraps(fn)</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_fn_with_dynamic_linear_scaling</span><span class="params">(indv)</span>:</span></div><div class="line">            f = fn(indv)</div><div class="line">            k = self.current_generation + <span class="number">1</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> target == <span class="string">'max'</span>:</div><div class="line">                f_prime = f - self.ori_fmin + ksi0*(r**k)</div><div class="line">            <span class="keyword">elif</span> target == <span class="string">'min'</span>:</div><div class="line">                f_prime = self.ori_fmax - f + ksi0*(r**k)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">raise</span> ValueError(<span class="string">'Invalid target type(&#123;&#125;)'</span>.format(target))</div><div class="line">            <span class="keyword">return</span> f_prime</div><div class="line"></div><div class="line">        <span class="keyword">return</span> _fn_with_dynamic_linear_scaling</div><div class="line"></div><div class="line">    <span class="keyword">return</span> _dynamic_linear_scaling</div></pre></td></tr></table></figure></p>
<p>这里充分的利用Python的闭包，在engine中获取当前种群最大值与最小值的相关数据。</p>
<p>在脚本中修饰目标函数便可以这样:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@engine.fitness_register</span></div><div class="line"><span class="meta">@engine.dynamic_linear_scaling(target='max', ksi0=2, r=0.9)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fitness</span><span class="params">(indv)</span>:</span></div><div class="line">    x, = indv.variants</div><div class="line">    <span class="keyword">return</span> x + <span class="number">10</span>*sin(<span class="number">5</span>*x) + <span class="number">7</span>*cos(<span class="number">4</span>*x)</div></pre></td></tr></table></figure></p>
<h3 id="其他标定方法"><a href="#其他标定方法" class="headerlink" title="其他标定方法"></a>其他标定方法</h3><p>这里简要的介绍下其他标定方法。</p>
<h4 id="幂律标定"><a href="#幂律标定" class="headerlink" title="幂律标定"></a>幂律标定</h4><ul>
<li>函数表达式: $f’ = f^{\alpha}$</li>
<li>$\alpha$的取值, $\alpha &gt; 1$增大选择压力, $\alpha &lt; 1$减小选择压力</li>
</ul>
<h4 id="对数标定"><a href="#对数标定" class="headerlink" title="对数标定"></a>对数标定</h4><ul>
<li>函数表达式: $f’ = aLnf + b$</li>
<li>作用: 缩小目标函数之间的差别</li>
</ul>
<h4 id="指数标定"><a href="#指数标定" class="headerlink" title="指数标定"></a>指数标定</h4><ul>
<li>函数表达式: $f’ = ae^{bf} + c$</li>
<li>作用: 扩大目标函数间的差别</li>
</ul>
<h4 id="窗口技术"><a href="#窗口技术" class="headerlink" title="窗口技术"></a>窗口技术</h4><ul>
<li>函数表达式: $f’ = af - f_w$</li>
<li>$f_w$为前$W$代中的目标函数最小值，他考虑了各代$f_{min}$的波动，这样$f_w$具有记忆性</li>
</ul>
<h2 id="大变异算法"><a href="#大变异算法" class="headerlink" title="大变异算法"></a>大变异算法</h2><p>众所周知，简单的遗传算法存在“早熟”的问题，也就是算法过早的收敛到一个非全局最优点，出现此问题的主要原因是一种被称为“顶端优势”的现象存在，即当算法进行到某一代时，在种群中某个个体的适应度远远大于任何一个个体的适应度，导致选择算法总是会选到此个体生成子代个体，极限情况下就是所有个体都来自统一祖先，即”早熟”。除了对目标函数进行标定，我们可以通过大变异算法来避免早熟。</p>
<p>大致思路: 当某代中所有个体集中在一起时，我们以一个远大于通常变异概率的概率执行一次变异操作，具有大变异概率的变异操作能够随机、独立的产生许多新的个体，从而是整个种群脱了“早熟”。</p>
<h3 id="如何判断种群个体的集中程度"><a href="#如何判断种群个体的集中程度" class="headerlink" title="如何判断种群个体的集中程度"></a>如何判断种群个体的集中程度</h3><p>通常采取比较种群中所有个体的适应度值的平均值$f_{avg}$与最大值$f_{max}$的接近程度来判断，如果最大值与平均值越接近说明个体就越集中。</p>
<h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><p>当某一代的最大适应度$f_{max}$与平均适应度值$f_{avg}$满足:<br>$$\alpha \cdot f_{max} &lt; f_{avg}$$</p>
<p>其中，$0.5 &lt; \alpha &lt; 1$, 被称为密集因子，表征个体集中程度。随后，我们以一个大变异概率进行一次变异操作(通常大5倍以上), 即“打散”。</p>
<h3 id="大变异操作的两个参数"><a href="#大变异操作的两个参数" class="headerlink" title="大变异操作的两个参数"></a>大变异操作的两个参数</h3><ol>
<li>密集因子$\alpha$: 决定大变异操作在整个过程中所占的比重，其数值约接近$0.5$，大变异操作越频繁</li>
<li>大变异概率: 概率越大，大变异算法的稳定性就越好，但是收敛速度可能会降低，当大变异概率的数值为0.5的时候，大变异操作就近似退化为随机搜索</li>
</ol>
<h3 id="GAFT中的大变异算子"><a href="#GAFT中的大变异算子" class="headerlink" title="GAFT中的大变异算子"></a>GAFT中的大变异算子</h3><p>大变异操作与具体的变异算子实现无关，这里我还是依据内置的<code>FlipBitMutation</code>算子为基础, 具体的代码实现参见<a href="https://github.com/PytLab/gaft/blob/master/gaft/operators/mutation/flip_bit_mutation.py。" target="_blank" rel="external">https://github.com/PytLab/gaft/blob/master/gaft/operators/mutation/flip_bit_mutation.py。</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlipBitBigMutation</span><span class="params">(FlipBitMutation)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pm, pbm, alpha)</span>:</span></div><div class="line">        <span class="string">'''</span></div><div class="line">        Mutation operator using Flip Bit mutation implementation with adaptive</div><div class="line">        big mutation rate to overcome premature or local-best solution.</div><div class="line"></div><div class="line">        :param pm: The probability of mutation (usually between 0.001 ~ 0.1)</div><div class="line">        :type pm: float in (0.0, 1.0]</div><div class="line"></div><div class="line">        :param pbm: The probability of big mutation, usually more than 5 times</div><div class="line">                    bigger than pm.</div><div class="line">        :type pbm: float</div><div class="line"></div><div class="line">        :param alpha: intensive factor</div><div class="line">        :type alpha: float, in range (0.5, 1)</div><div class="line">        '''</div><div class="line">        super(self.__class__, self).__init__(pm)</div><div class="line"></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0.0</span> &lt; pbm &lt; <span class="number">1.0</span>):</div><div class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Invalid big mutation probability'</span>)</div><div class="line">        <span class="keyword">if</span> pbm &lt; <span class="number">5</span>*pm:</div><div class="line">            self.logger.warning(<span class="string">'Relative low probability for big mutation'</span>)</div><div class="line">        self.pbm = pbm</div><div class="line"></div><div class="line">        <span class="comment"># Intensive factor.</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0.5</span> &lt; alpha &lt; <span class="number">1.0</span>):</div><div class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Invalid intensive factor, should be in (0.5, 1.0)'</span>)</div><div class="line">        self.alpha = alpha</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mutate</span><span class="params">(self, individual, engine)</span>:</span></div><div class="line">        <span class="string">'''</span></div><div class="line">        Mutate the individual with adaptive big mutation rate.</div><div class="line">        '''</div><div class="line">        pm = self.pm</div><div class="line"></div><div class="line">        <span class="keyword">if</span> engine.fmax*self.alpha &lt; engine.fmean:</div><div class="line">            self.pm = self.pbm</div><div class="line">            self.logger.info(<span class="string">'Big mutation probabilty: &#123;&#125; -&gt; &#123;&#125;'</span>.format(pm, self.pm))</div><div class="line"></div><div class="line">        <span class="comment"># Mutate with big probability.</span></div><div class="line">        individual = super(self.__class__, self).mutate(individual, engine)</div><div class="line"></div><div class="line">        <span class="comment"># Recover probability.</span></div><div class="line">        self.pm = pm</div><div class="line"></div><div class="line">        <span class="keyword">return</span> individual</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文尝试对遗传算法中不同适值函数的标定(Scaling)方法进行下总结，并针对常用的线性标定和动态线性标定进行了Python实现，以装饰器的形式添加到遗传算法框架GAFT中，这样在使用GAFT运行遗传算法迭代的时候可以更加Pythonic的给自定义的适值函数进行标定。最后针对能够防止早熟情况的大变异算法进行了相应的实现。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《MATLAB最优化计算(第三版)》</li>
<li>马钧水, 刘贵忠, 贾玉兰. 改进遗传算法搜索性能的大变异操作[J]. 控制理论与应用, 1998(3):404-408.</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 代码作品 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> GeneticAlgorithm </tag>
            
            <tag> gaft </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[遗传算法中几种不同选择算子]]></title>
      <url>http://pytlab.github.io/2017/09/19/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E4%B8%AD%E5%87%A0%E7%A7%8D%E4%B8%8D%E5%90%8C%E9%80%89%E6%8B%A9%E7%AE%97%E5%AD%90%E7%9A%84%E6%AF%94%E8%BE%83/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文对遗传算法中的几种选择策略进行了总结, 其中包括:</p>
<ol>
<li>Proportionate Roulette Wheel Selection</li>
<li>Linear Ranking Selection</li>
<li>Exponential Ranking Selection</li>
<li>Tournament Selection</li>
</ol>
<p>对于每种选择策略我都使用Python进行了相应的实现并以内置插件的形式整合进了本人所写的遗传算法框架GAFT中。对需要使用遗传算法优化问题以及学习遗传算法的童鞋可以作为参考.</p>
<p>项目链接:</p>
<ul>
<li>GitHub: <a href="https://github.com/PytLab/gaft" target="_blank" rel="external">https://github.com/PytLab/gaft</a></li>
<li>PyPI: <a href="https://pypi.python.org/pypi/gaft" target="_blank" rel="external">https://pypi.python.org/pypi/gaft</a></li>
</ul>
<a id="more"></a>
<h2 id="遗传算法中的选择算子"><a href="#遗传算法中的选择算子" class="headerlink" title="遗传算法中的选择算子"></a>遗传算法中的选择算子</h2><p>遗传算法(genetic algorithms, GAs)是一种自适应的启发式搜索算法, 它模仿达尔文进化论中的“适者生存”的原则, 最终获取优化目标的最优解。下图描述了一个简单的遗传算法流程:</p>
<p><img src="/assets/images/blog_img/2017-09-19-遗传算法中几种不同选择算子的比较/flowchart.png" alt=""></p>
<p>对于种群中需要进行杂交的物种选择方法有很多，而且选择一种合适的选择策略对于遗传算法整体性能的影响将是很大的。如果一个选择算法选择多样性降低，便会导致种群过早的收敛到局部最优点而不是我们想要的全局最优点，也就是所谓的”早熟”。而选择策略过于发散则会导致算法难以收敛到最优点。因此在这两点中我们需要进行平衡才能使遗传算法以一种高效的方式收敛到全局最优点。</p>
<h2 id="GAFT框架中的算子插件"><a href="#GAFT框架中的算子插件" class="headerlink" title="GAFT框架中的算子插件"></a>GAFT框架中的算子插件</h2><p>GAFT是我根据自己需求开发的一个遗传算法框架，相关介绍的博客可以参见《<a href="http://pytlab.org/2017/07/23/gaft-%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8EPython%E7%9A%84%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/" target="_blank" rel="external">GAFT-一个使用Python实现的遗传算法框架</a>》,《<a href="http://pytlab.org/2017/08/02/%E4%BD%BF%E7%94%A8MPI%E5%B9%B6%E8%A1%8C%E5%8C%96%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/" target="_blank" rel="external">使用MPI并行化遗传算法框架GAFT</a>》。该框架提供了插件接口，用户可以通过自定义算子以及on-the-fly分析插件来放到gaft框架中运行遗传算法流程对目标问题进行优化。</p>
<p>本部分我稍微介绍下gaft关于遗传算子相关接口规范，以及编写能用于gaft的算子的编写方法。</p>
<p>在gaft中遗传算子的编写都是需要继承框架内置的基类，然后根据基类提供的接口，实现自己的算子。其中基类的定义都在<a href="https://github.com/PytLab/gaft/tree/master/gaft/plugin_interfaces/operators" target="_blank" rel="external"><code>/gaft/plugin_interfaces/operators/</code></a>目录下，下面我以选择算子为例，介绍下接口。</p>
<p>gaft中选择算子的基类为<code>GASelection</code>，其中在遗传算法流程中会调用该类实例的<code>select</code>方法，进而根据算子中的相关选择策略完成从种群中选取一对物种作为父亲和母亲产生子代。基类的定义为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GASelection</span><span class="params">(metaclass=SelectionMeta)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    Class for providing an interface to easily extend the behavior of selection</div><div class="line">    operation.</div><div class="line">    '''</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(self, population, fitness)</span>:</span></div><div class="line">        <span class="string">'''</span></div><div class="line">        Called when we need to select parents from a population to later breeding.</div><div class="line"></div><div class="line">        :param population: The current population.</div><div class="line">        :type population: GAPopulation</div><div class="line"></div><div class="line">        :return parents: Two selected individuals for crossover.</div><div class="line">        :type parents: Tuple of tow GAIndividual objects.</div><div class="line">        '''</div><div class="line">        <span class="keyword">raise</span> NotImplementedError</div></pre></td></tr></table></figure></p>
<p><code>select</code>的方法的参数为当前种群<code>population</code>以及相应的适应度函数<code>fitness</code>，其中<code>population</code>需要是<code>GAPopulation</code>对象，<code>fitness</code>也必须是callable的对象。</p>
<p>当然，这些在Python这种动态类型语言中貌似看起来有些鸡肋，但是为了能够更加规范使用者，我<strong>利用Python的元类在实例化类对象的时候对接口的实现以及接口的参数类型加以限制</strong>。具体的实现都在<a href="https://github.com/PytLab/gaft/blob/master/gaft/plugin_interfaces/metaclasses.py" target="_blank" rel="external"><code>/gaft/plugin_interfaces/metaclasses.py</code></a>中，有兴趣的童鞋可以看看实现方法。</p>
<p>具体自定义算子的编写方法我将在下一部分同选择策略一起贴出来。</p>
<h2 id="不同的选择策略"><a href="#不同的选择策略" class="headerlink" title="不同的选择策略"></a>不同的选择策略</h2><p>本部分我主要对四种不同的选择策略进行总结并加以gaft插件形式的Python实现。</p>
<p>选择算子决定了哪些个体将会从种群中被选择出来用于繁衍下一代种群中的新个体。其主要的原则就是:</p>
<blockquote>
<p>the better is an individual; the higher is its chance of being a parent</p>
</blockquote>
<p>选择算子在遗传算法迭代中将适应度函数引入进来，因为适应度函数式标定一个个体是否足够“好”的重要标准。但是选择过程又不能仅仅完全依赖于适应度函数，因为一个种群中的最优物种并不一定是在全局最优点附近。因此我们也应该给相对来说并那么“好”的个体一点机会让他们繁衍后代, 避免“早熟”。</p>
<h3 id="Proportionate-Roulette-Wheel-Selection"><a href="#Proportionate-Roulette-Wheel-Selection" class="headerlink" title="Proportionate Roulette Wheel Selection"></a>Proportionate Roulette Wheel Selection</h3><p>此轮盘赌选择策略，是最基本的选择策略之一，种群中的个体被选中的概率与个体相应的适应度函数的值成正比。我们需要将种群中所有个体的适应度值进行累加然后归一化，最终通过随机数对随机数落在的区域对应的个体进行选取，类似赌场里面的旋转的轮盘。</p>
<p><img src="/assets/images/blog_img/2017-09-19-遗传算法中几种不同选择算子的比较/roulette_wheel_selection.png" alt=""></p>
<p>每个个体$a_{i}$被选中的概率为:<br>$$<br>P_{select}(a_i) = \frac{f(a_i)}{\sum_{i=1}^{n}f(a_i)}<br>$$</p>
<p>好了，下面可以将此算法写成一个可以gaft中执行的算子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</div><div class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_right</div><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> accumulate</div><div class="line"></div><div class="line"><span class="keyword">from</span> ...plugin_interfaces.operators.selection <span class="keyword">import</span> GASelection</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouletteWheelSelection</span><span class="params">(GASelection)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">'''</span></div><div class="line">        Selection operator with fitness proportionate selection(FPS) or</div><div class="line">        so-called roulette-wheel selection implementation.</div><div class="line">        '''</div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(self, population, fitness)</span>:</span></div><div class="line">        <span class="string">'''</span></div><div class="line">        Select a pair of parent using FPS algorithm.</div><div class="line">        '''</div><div class="line">        <span class="comment"># Normalize fitness values for all individuals.</span></div><div class="line">        fit = [fitness(indv) <span class="keyword">for</span> indv <span class="keyword">in</span> population.individuals]</div><div class="line">        min_fit = min(fit)</div><div class="line">        fit = [(i - min_fit) <span class="keyword">for</span> i <span class="keyword">in</span> fit]</div><div class="line"></div><div class="line">        <span class="comment"># Create roulette wheel.</span></div><div class="line">        sum_fit = sum(fit)</div><div class="line">        wheel = list(accumulate([i/sum_fit <span class="keyword">for</span> i <span class="keyword">in</span> fit]))</div><div class="line"></div><div class="line">        <span class="comment"># Select a father and a mother.</span></div><div class="line">        father_idx = bisect_right(wheel, random())</div><div class="line">        father = population[father_idx]</div><div class="line">        mother_idx = (father_idx + <span class="number">1</span>) % len(wheel)</div><div class="line">        mother = population[mother_idx]</div><div class="line"></div><div class="line">        <span class="keyword">return</span> father, mother</div></pre></td></tr></table></figure>
<p>过程主要分为下面几个:</p>
<ol>
<li>继承<code>GASelection</code>类</li>
<li>实现<code>select</code>方法</li>
<li><code>select</code>的参数为<code>GAPopulation</code>实例和适应度函数</li>
<li>根据算法选择出两个需要繁衍的物种并返回即可</li>
</ol>
<h3 id="Tournament-Selection"><a href="#Tournament-Selection" class="headerlink" title="Tournament Selection"></a>Tournament Selection</h3><p>由于算法执行的效率以及易实现的的特点，锦标赛选择算法是遗传算法中最流行的选择策略。在本人的实际应用中的确此策略比基本的轮盘赌效果要好些。他的策略也很直观，就是我们再整个种群中抽取$n$个个体，让他们进行竞争(锦标赛)，抽取其中的最优的个体。参加锦标赛的个体个数成为tournament size。通常当$n = 2$便是最常使用的大小，也称作Binary Tournament Selection.</p>
<p>Tournament Selection的优势:</p>
<ol>
<li>更小的复杂度$O(n)$</li>
<li>易并行化处理</li>
<li>不易陷入局部最优点</li>
<li>不需要对所有的适应度值进行排序处理</li>
</ol>
<p>下图显示了$n = 3$的Tournament Selection的过程:</p>
<p><img src="/assets/images/blog_img/2017-09-19-遗传算法中几种不同选择算子的比较/tournament_selection.png" alt=""></p>
<p>可以开始写成自定义算子在gaft运行了:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> random <span class="keyword">import</span> sample</div><div class="line"></div><div class="line"><span class="keyword">from</span> ...plugin_interfaces.operators.selection <span class="keyword">import</span> GASelection</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TournamentSelection</span><span class="params">(GASelection)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, tournament_size=<span class="number">2</span>)</span>:</span></div><div class="line">        <span class="string">'''</span></div><div class="line">        Selection operator using Tournament Strategy with tournament size equals</div><div class="line">        to two by default.</div><div class="line">        '''</div><div class="line">        self.tournament_size = tournament_size</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(self, population, fitness)</span>:</span></div><div class="line">        <span class="string">'''</span></div><div class="line">        Select a pair of parent using Tournament strategy.</div><div class="line">        '''</div><div class="line">        <span class="comment"># Competition function.</span></div><div class="line">        complete = <span class="keyword">lambda</span> competitors: max(competitors, key=fitness)</div><div class="line"></div><div class="line">        <span class="comment"># Check validity of tournament size.</span></div><div class="line">        <span class="keyword">if</span> self.tournament_size &gt;= len(population):</div><div class="line">            msg = <span class="string">'Tournament size(&#123;&#125;) is larger than population size(&#123;&#125;)'</span></div><div class="line">            <span class="keyword">raise</span> ValueError(msg.format(self.tournament_size, len(population)))</div><div class="line"></div><div class="line">        <span class="comment"># Pick winners of two groups as parent.</span></div><div class="line">        competitors_1 = sample(population.individuals, self.tournament_size)</div><div class="line">        competitors_2 = sample(population.individuals, self.tournament_size)</div><div class="line">        father, mother = complete(competitors_1), complete(competitors_2)</div><div class="line"></div><div class="line">        <span class="keyword">return</span> father, mother</div></pre></td></tr></table></figure></p>
<h3 id="Linear-Ranking-Selection"><a href="#Linear-Ranking-Selection" class="headerlink" title="Linear Ranking Selection"></a>Linear Ranking Selection</h3><p>下面两个介绍的选择策略都是基于排序的选择策略，上面提到的第一种基本轮盘赌选择算法，有一个缺点，就是如果一个个体的适应度值为0的话，则被选中的概率将会是0, 这个个体将不能产生后代。于是我们需要一种基于排序的算法，来给每个个体安排相应的选中概率。</p>
<p>在Linear Ranking Selection中，种群中的个体首先根据适应度的值进行排序，然后给所有个体赋予一个序号，最好的个体为$N$, 被选中的概率为$P_{max}$, 最差的个体序号为$1$, 被选中的概率为$P_{min}$，于是其他的在他们中间的个体的概率便可以根据如下公式得到:<br>$$<br>P_i = P_{min} + (P_{max} - P_{min})\frac{i - 1}{N - 1}<br>$$</p>
<p>实现代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</div><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> accumulate</div><div class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_right</div><div class="line"></div><div class="line"><span class="keyword">from</span> ...plugin_interfaces.operators.selection <span class="keyword">import</span> GASelection</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearRankingSelection</span><span class="params">(GASelection)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pmin=<span class="number">0.1</span>, pmax=<span class="number">0.9</span>)</span>:</span></div><div class="line">        <span class="string">'''</span></div><div class="line">        Selection operator using Linear Ranking selection method.</div><div class="line"></div><div class="line">        Reference: Baker J E. Adaptive selection methods for genetic</div><div class="line">        algorithms[C]//Proceedings of an International Conference on Genetic</div><div class="line">        Algorithms and their applications. 1985: 101-111.</div><div class="line">        '''</div><div class="line">        <span class="comment"># Selection probabilities for the worst and best individuals.</span></div><div class="line">        self.pmin, self.pmax = pmin, pmax</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(self, population, fitness)</span>:</span></div><div class="line">        <span class="string">'''</span></div><div class="line">        Select a pair of parent individuals using linear ranking method.</div><div class="line">        '''</div><div class="line">        <span class="comment"># Individual number.</span></div><div class="line">        NP = len(population)</div><div class="line"></div><div class="line">        <span class="comment"># Add rank to all individuals in population.</span></div><div class="line">        sorted_indvs = sorted(population.individuals, key=fitness, reverse=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">        <span class="comment"># Assign selection probabilities linearly.</span></div><div class="line">        <span class="comment"># <span class="doctag">NOTE:</span> Here the rank i belongs to &#123;1, ..., N&#125;</span></div><div class="line">        p = <span class="keyword">lambda</span> i: (self.pmin + (self.pmax - self.pmin)*(i<span class="number">-1</span>)/(NP<span class="number">-1</span>))</div><div class="line">        probabilities = [self.pmin] + [p(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, NP)] + [self.pmax]</div><div class="line"></div><div class="line">        <span class="comment"># Normalize probabilities.</span></div><div class="line">        psum = sum(probabilities)</div><div class="line">        wheel = list(accumulate([p/psum <span class="keyword">for</span> p <span class="keyword">in</span> probabilities]))</div><div class="line"></div><div class="line">        <span class="comment"># Select parents.</span></div><div class="line">        father_idx = bisect_right(wheel, random())</div><div class="line">        father = population[father_idx]</div><div class="line">        mother_idx = (father_idx + <span class="number">1</span>) % len(wheel)</div><div class="line">        mother = population[mother_idx]</div><div class="line"></div><div class="line">        <span class="keyword">return</span> father, mother</div></pre></td></tr></table></figure></p>
<h3 id="Exponential-Ranking-Selection"><a href="#Exponential-Ranking-Selection" class="headerlink" title="Exponential Ranking Selection"></a>Exponential Ranking Selection</h3><p>类似上面的Linear Ranking选择策略，这种指数排序便是在确定每个个体的选择概率的时候使用了指数形式的表达式, 其中$c$为底数，满足$0 &lt; c &lt; 1$:<br>$$<br>P_i = \frac{c^{N - i}}{\sum_{j=1}^{N} c^{N-j}}<br>$$</p>
<p>实现代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</div><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> accumulate</div><div class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_right</div><div class="line"></div><div class="line"><span class="keyword">from</span> ...plugin_interfaces.operators.selection <span class="keyword">import</span> GASelection</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExponentialRankingSelection</span><span class="params">(GASelection)</span>:</span> </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, base=<span class="number">0.5</span>)</span>:</span></div><div class="line">        <span class="string">'''</span></div><div class="line">        Selection operator using Exponential Ranking selection method.</div><div class="line"></div><div class="line">        :param base: The base of exponent</div><div class="line">        :type base: float in range (0.0, 1.0)</div><div class="line">        '''</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0.0</span> &lt; base &lt; <span class="number">1.0</span>):</div><div class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'The base of exponent c must in range (0.0, 1.0)'</span>)</div><div class="line"></div><div class="line">        self.base = base</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(self, population, fitness)</span>:</span></div><div class="line">        <span class="string">'''</span></div><div class="line">        Select a pair of parent individuals using exponential ranking method.</div><div class="line">        '''</div><div class="line">        <span class="comment"># Individual number.</span></div><div class="line">        NP = len(population)</div><div class="line"></div><div class="line">        <span class="comment"># <span class="doctag">NOTE:</span> Here the rank i belongs to &#123;1, ..., N&#125;</span></div><div class="line">        p = <span class="keyword">lambda</span> i: self.base**(NP - i)</div><div class="line">        probabilities = [p(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, NP + <span class="number">1</span>)]</div><div class="line"></div><div class="line">        <span class="comment"># Normalize probabilities.</span></div><div class="line">        psum = sum(probabilities)</div><div class="line">        wheel = list(accumulate([p/psum <span class="keyword">for</span> p <span class="keyword">in</span> probabilities]))</div><div class="line"></div><div class="line">        <span class="comment"># Select parents.</span></div><div class="line">        father_idx = bisect_right(wheel, random())</div><div class="line">        father = population[father_idx]</div><div class="line">        mother_idx = (father_idx + <span class="number">1</span>) % len(wheel)</div><div class="line">        mother = population[mother_idx]</div><div class="line"></div><div class="line">        <span class="keyword">return</span> father, mother</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对于遗传算法中四种不同的选择策略进行了介绍和总结，同时对于本文所写的遗传算法框架的自定义算子接口进行了简要的介绍，针对本文中的选择策略分别根据接口的要求实现了相应的算子，这些算子也作为GAFT框架的内置算子放入到GAFT中，对于使用GAFT的童鞋可以直接拿来使用。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>Shukla, Anupriya, Hari Mohan Pandey, and Deepti Mehrotra. “Comparative review of selection techniques in genetic algorithm.” Futuristic Trends on Computational Analysis and Knowledge Management (ABLAZE), 2015 International Conference on. IEEE, 2015.</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 代码作品 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> GeneticAlgorithm </tag>
            
            <tag> gaft </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[递归式求解-主方法]]></title>
      <url>http://pytlab.github.io/2017/09/10/%E9%80%92%E5%BD%92%E5%BC%8F%E6%B1%82%E8%A7%A3-%E4%B8%BB%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>本文对递归式求解中很重要的主方法进行介绍总结。</p>
<h3 id="主方法"><a href="#主方法" class="headerlink" title="主方法"></a>主方法</h3><p>主方法为如下形式的递归式提供了一种”菜谱式”的求解方法:<br>$$T(n) = aT(n/b) + f(n)$$<br>其中$a \ge 1, b \gt 1$是常数，$f(n)$是渐进正数。</p>
<p>上式描述了这样的一个算法运行时间: 他将原问题的规模为$n$的问题划分为$a$个小的子问题，每个子问题的规模为原来的$\frac{1}{b}$. $a$个子问题递归的进行求解，每个花费时间为$T(n/b)$。子问题合并的代价为$f(n)$</p>
<a id="more"></a>
<h3 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h3><p>这里我将书上的定义直接贴上来了。</p>
<p>主方法依赖主定理:</p>
<p>令$a \ge 1$和$b \gt 1$是常数，$f(n)$是一个函数，$T(n)$是定义在非负整数上的递归式:<br>$$T(n) = aT(n/b) + f(n)$$<br>其中我们将忽略舍入问题$n/b$解释为$\lfloor n/b \rfloor$和$\lceil n/b \rceil$, 那么$T(n)$有如下渐进界:</p>
<ol>
<li>若对某个常数$\epsilon &gt; 0$有$f(n)=O(n^{\log_{b}a - \epsilon})$, $T(n) = \Theta(n^{\log_{b}a})$</li>
<li>若$f(n) = \Theta(n^{\log_{b}a})$, 则$T(n) = \Theta(n^{b}a lgn)$</li>
<li>若对某个常数$\epsilon &gt; 0$有$f(n) = \Omega(n^{log_{b}a + \epsilon})$, 且对某个常数$c &lt; 1$和所有足够大的$n$y有$af(n/b) \le cf(n)$, 则$T(n) = \Theta(f(n))$</li>
</ol>
<h3 id="主定理的直观理解"><a href="#主定理的直观理解" class="headerlink" title="主定理的直观理解"></a>主定理的直观理解</h3><p>主定理其实主要是比较两个函数$f(n)$和$n^{\log_{b}a}$, 其中较大的那个决定最终递归式的渐近解。</p>
<ol>
<li>若$n^{\log_{b}a} &gt; f(n)$, 则就是情况1, 解就直接是$T(n) = \Theta(n^{\log_{b}a})$</li>
<li>若$n^{\log_{b}a} = f(n)$, 则就是情况2, 解就需要在$f(n)$的基础上乘上个对数因子$lgn$, $T(n) = \Theta(n^{\log_{b}a}lgn)$</li>
<li>若$n^{\log_{b}a} &lt; f(n)$, 则就是情况3, 解为$T(n) = \Theta(f(n))$</li>
</ol>
<h3 id="主定理的细节理解"><a href="#主定理的细节理解" class="headerlink" title="主定理的细节理解"></a>主定理的细节理解</h3><h4 id="多项式意义上大于"><a href="#多项式意义上大于" class="headerlink" title="多项式意义上大于"></a>多项式意义上大于</h4><p>主定理中，除了渐进大于(小于)以外，还有一个重要的概念就是<strong>多项式意义的大于(小于)</strong>(polynomially larger/smaller)</p>
<p>多项式大于意味着函数的比值会渐进的落在两个多项式之间。$f(n)$多项式意义上大于$g(n)$，当且仅当存在两个广义的多项式(分数指数也是可以的)$p(n), q(n)$使得如下不等式渐进成立:<br>$$p(n) \le \frac{f(n)}{g(n)} &lt; q(n)$$</p>
<p>例如对于两个函数$n^2$和$\frac{n}{lgn}$, 我们有$\frac{n^2}{nlgn} = \frac{n}{lgn}$,<br>$$n^{\frac{1}{3}} \le \frac{n}{lgn} \le n$$<br>则函数$n^2$多项式意义上大于$nlgn$.</p>
<h4 id="主定理中的细节"><a href="#主定理中的细节" class="headerlink" title="主定理中的细节"></a>主定理中的细节</h4><p>除了像上一部分那样有个大致的“大于”，“小于”的直观理解外，我们要理解定义中的具体细节，其实就是多项式大于/小于的应用。</p>
<ol>
<li>第一种情况中，我们需要$f(n)$多项式意义上小于$n^{\log_{b}a}$， 即$f(n)$渐进小于$n^{\log_{b}a - \epsilon}$。 $f(n)$必须渐近小于$n^{\log_{b}a}$, 同时要相差一个因子$n^{\epsilon}$, 其中$\epsilon$是大于0的常数。</li>
<li>第二种情况中，除了多项式意义上的大于以外，而且还要满足“正则”条件$af(n/b) \le cf(n)$</li>
</ol>
<p>但是主方法中的三种情况并不能覆盖所有此形式的情况。情况1和情况2之间有一定的间隙，即$f(n)$渐近小于$n^{\log_{b}a}$d但不是多项式意义上的小于。同样的情况2和情况3也有类似的间隙。<strong>如果$f(n)$满足的条件正好落在间隙中，或者不满足情况3中的“正则”条件</strong>，就不能通过主方法来求解了。</p>
<p>例如求解如下递归式的时候:<br>$$T(n) = 2T(n/2) + nlgn$$</p>
<p>我们按照主方法，$a = 2, b = 2, f(n) = nlgn$</p>
<p>$$<br>n^{\log_{b}a} = n^{\log_{2}2} = n<br>$$</p>
<p>我们可以看到$f(n) = nlgn$ 渐近大于 $n^{\log_{b}a} = n$, 但是我们需要的是多项式意义上的大于即<br>$$<br>nlgn &gt; n \cdot n^{\epsilon}, \epsilon &gt; 0<br>$$<br>但是对于任意$\epsilon &gt; 0$都无法满足$lgn$渐近大于$n^{\epsilon}$, 于是它并不是多项式意义上的大于，此递归式无法使用主方法来求解。</p>
<h3 id="使用主方法的例子"><a href="#使用主方法的例子" class="headerlink" title="使用主方法的例子"></a>使用主方法的例子</h3><p>对于矩阵乘法的Strassen方法递归式:<br>$$<br>T(n) = 7T(n/2) + \Theta(n^2)<br>$$</p>
<p>有$a = 7, b = 2, f(n) = \Theta(n^2)$, 因此$n^{\log_{b}a} = n^{\log_{2}7}$, 由于$2.8 &lt; lg7 &lt; 2.81$, 对于$\epsilon = 0.8$, 就有$f(n) = \Theta(n^2)$多项式意义上大于$O(n^{lg7})$, 于是我们便可以得到最终的解为:<br>$$<br>T(n) = \Theta(n^{lg7})<br>$$</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习算法实践-SVM中的SMO算法]]></title>
      <url>http://pytlab.github.io/2017/09/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5-SVM%E4%B8%AD%E7%9A%84SMO%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前两篇关于SVM的文章分别总结了SVM基本原理和核函数以及软间隔原理，本文我们就针对前面推导出的SVM对偶问题的一种高效的优化方法-序列最小优化算法(Sequential Minimal Optimization, SMO)的原理进行总结并进行相应的Python实现。</p>
<h2 id="坐标上升算法-Coordiante-Ascent"><a href="#坐标上升算法-Coordiante-Ascent" class="headerlink" title="坐标上升算法(Coordiante Ascent)"></a>坐标上升算法(Coordiante Ascent)</h2><p>在SMO算法之前，还是需要总结下坐标上升算法，因为SMO算法的思想与坐标上升算法的思想类似。</p>
<p>坐标上升算法每次通过更新多元函数中的一维，经过多次迭代直到收敛来达到优化函数的目的。简单的讲就是不断地选中一个变量做一维最优化直到函数达到局部最优点。</p>
<a id="more"></a>
<p>假设我们需要求解的问题形式为(类似我们SVM的对偶形式):<br>$$\max \limits_{\alpha} W(\alpha_{1}, \alpha_{2}, …, \alpha_{N})$$</p>
<h3 id="算法过程伪码"><a href="#算法过程伪码" class="headerlink" title="算法过程伪码:"></a>算法过程伪码:</h3><p><img src="/assets/images/blog_img/2017-09-01-机器学习算法实践-SVM中的SMO算法/coord_ascent_algo.png" alt=""></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>若我们的优化目标为一个二元函数:<br>$$<br>arg \min \limits_{x_{1}, x_{2}} f(x_{1}, x_{2}) = -x_{1}^{2} - 3x_{2}^{2} + 2x_{1}x_{2} + 6<br>$$</p>
<p>我们先给一个$(x_{1}, x_{2})$的初值然后开始迭代。</p>
<ol>
<li><p>先固定$x_{1}$，把$f$看做$x_{2}$的一元函数求最优值，可以简单的进行求导获取解析解:<br>$$<br>\frac{\partial{f}}{\partial{x_{1}}} = -2x_{1} + 2x_{2} = 0 \rightarrow x_{1} = x_{2}<br>$$</p>
</li>
<li><p>在固定$x_{2}$, 把$f$看成$x_{1}$的一元函数求最优值，得到$x_{1}$的解析解:<br>$$<br>\frac{\partial{f}}{\partial{x_{2}}} = -6x_{2} + 2x_{1} \rightarrow x_{2} = \frac{1}{3}x_{1}<br>$$</p>
</li>
</ol>
<p>安装上面两个过程不断交替的优化$x_{1}$和$x_{2}$，直到函数收敛。</p>
<p>通过下面的图就可以看出，优化的过程，因为每次只优化一个变量，每次迭代的方向都是沿着坐标轴方向的。</p>
<p><img src="/assets/images/blog_img/2017-09-01-机器学习算法实践-SVM中的SMO算法/coord_ascent_pic.png" alt=""></p>
<p>因为每次只是做一维优化，所以每个循环中的优化过程的效率是很高的, 但是迭代的次数会比较多。</p>
<h2 id="序列最小优化算法-SMO"><a href="#序列最小优化算法-SMO" class="headerlink" title="序列最小优化算法(SMO)"></a>序列最小优化算法(SMO)</h2><h3 id="SMO算法介绍"><a href="#SMO算法介绍" class="headerlink" title="SMO算法介绍"></a>SMO算法介绍</h3><p>SMO的思想类似坐标上升算法，我们需要优化一系列的$\alpha$的值，我们每次选择尽量少的$\alpha$来优化，不断迭代直到函数收敛到最优值。</p>
<p>来到SVM的对偶问题上，对偶形式:<br>$$arg \max \limits_{\alpha} \sum_{i=1}^{N} \alpha_{i} - \frac{1}{2}\sum_{i=1}^{N}\sum_{j=1}^{N}y_{i}y_{j}\alpha_{i}\alpha_{j}\langle x_{i}, x_{j} \rangle$$</p>
<p>subject to $\alpha_{i} \ge 0$ ; $\sum_{i=1}^{N}\alpha_{i}y_{i}=0$</p>
<p>其中我们需要对$(\alpha_{1}, \alpha_{2}, …, \alpha_{N})$进行优化，但是这个凸二次优化问题的其他求解算法的复杂度很高，但是Platt提出的SMO算法可以高效的求解上述对偶问题，他把原始问题的求解$N$个参数二次规划问题分解成多个二次规划问题求解，每个字问题只需要求解2各参数，节省了时间成本和内存需求。</p>
<p>与坐标上升算法不同的是，我们在SMO算法中我们每次需要选择<strong>一对</strong>变量$(\alpha_{i}, \alpha_{j})$, 因为在SVM中，我们的$\alpha$并不是完全独立的，而是具有约束的:<br>$$\sum_{i=1}^{N}\alpha_{i}y_{i} = 0$$</p>
<p>因此一个$\alpha$改变，另一个也要随之变化以满足条件。</p>
<h3 id="SMO算法原理"><a href="#SMO算法原理" class="headerlink" title="SMO算法原理"></a>SMO算法原理</h3><h4 id="获得没有修剪的原始解"><a href="#获得没有修剪的原始解" class="headerlink" title="获得没有修剪的原始解"></a>获得没有修剪的原始解</h4><p>假设我们选取的两个需要优化的参数为$\alpha_{1}, \alpha_{2}$, 剩下的$\alpha_{3}, \alpha_{4}, …, \alpha_{N}$则固定，作为常数处理。将SVM优化问题进行展开就可以得到(把与$\alpha_{1}, \alpha_{2}$无关的项合并成常数项$C$): </p>
<p>$$<br>W(\alpha_{1}, \alpha_{2}) = \alpha_{1} + \alpha_{2} - \frac{1}{2}K_{1,1}y_{1}^{2}\alpha_{1}^{2} - \frac{1}{2}K_{2,2}y_{2}^{2}\alpha_{2}^{2} - K_{1,2}y_{1}y_{2}\alpha_{1}\alpha_{2} - y_{1}\alpha_{1}\sum_{i=3}^{N}\alpha_{i}y_{i}K_{i,1} - y_{2}\alpha_{2}\sum_{i=3}^{N}\alpha_{i}y_{i}K_{i, 2} + C<br>$$</p>
<p>于是就是一个二元函数的优化:</p>
<p>$$<br>arg \max \limits_{\alpha_{1}, \alpha_{2}} W(\alpha_{1}, \alpha_{2})<br>$$</p>
<p>根据约束条件$\sum_{i=1}^{N}\alpha_{i}y_{i} = 0$可以得到$\alpha_{1}与\alpha_{2}$的关系:</p>
<p>$$<br>\alpha_{1}y_{1} + \alpha_{2}y_{2} = -\sum_{i=3}^{N}\alpha_{i}y_{i} = \zeta<br>$$</p>
<p>两边同时乘上$y_{1}$, 由于$y_{i}y_{i} = 1$得到:</p>
<p>$$\alpha_{1} = \zeta y_{1} - \alpha_{2}y_{1}y_{2}$$</p>
<p>令$v_{1} = \sum_{i=3}^{N}\alpha_{i}y_{i}K_{i, 1}$, $v_{2} = \sum_{i=3}^{N}\alpha_{i}y_{i}K_{i, 2}$，$\alpha_{1}$的表达式代入得到:</p>
<p>$$<br>W(\alpha_{2}) = -\frac{1}{2}K_{1, 1}(\zeta - \alpha_{2}y_{2})^{2} - \frac{1}{2}K_{2, 2}\alpha_{2}^{2} - y_{2}(\zeta - \alpha_{2}y_{2})\alpha_{2}K_{1, 2} - v_{1}(\zeta - \alpha_{2}y_{2}) - v_{2}y_{2}\alpha_{2} + \alpha_{1} + \alpha_{2} + C<br>$$</p>
<p>后面我们需要对这个一元函数进行求极值，$W$对$\alpha$的一阶导数为0得到:</p>
<p>$$<br>\frac{\partial{W(\alpha_{2})}}{\partial{\alpha_{2}}} = -(K_{1, 1} + K_{2, 2} - 2K_{1, 2})\alpha_{2} + K_{1, 1}\zeta y_{2} - K_{1, 2}\zeta y_{2} + v_{1}y_{2} - v_{2}y_{2} - y_{1}y_{2} + y_{2}^{2} = 0<br>$$</p>
<p>下面我们稍微对上式进行下变形，使得$\alpha_{2}^{new}$能够用更新前的$\alpha_{2}^{old}$表示，而不是使用不方便计算的$\zeta$。</p>
<p>因为SVM对数据点的预测值为: $f(x) = \sum_{i=1}^{N}\alpha_{i}y_{i} K(x_{i}, x) + b$</p>
<p>则$v_{1}$以及$v_{2}$的值可以表示成:</p>
<p>$$<br>v_{1} = \sum_{i=3}^{N}\alpha_{i}y_{i}K_{1, i} = f(x_{1}) - \alpha_{1}y_{1}K_{1, 1} - \alpha_{2}y_{2}K_{1, 2} - b<br>$$</p>
<p>$$<br>v_{2} = \sum_{i=3}^{N}\alpha_{i}y_{i}K_{2, i} = f(x_{2}) - \alpha_{1}y_{1}K_{1, 2} - \alpha_{2}y_{2}K_{2, 2} - b<br>$$</p>
<p>已知$\alpha_{1} = (\zeta - \alpha_{2}y_{2})y_{2}$, 可得到:<br>$$<br>v_{1} - v_{2} = f(x_{1}) - f(x_{2}) - K_{1, 1}\zeta + K_{1, 2}\zeta + (K_{1, 1} + K_{2, 2} - 2K_{1, 2})\alpha_{2}y_{2}<br>$$</p>
<p>将$v_{1} - v_{2}$的表达式代入到$\frac{\partial{W(\alpha_{2})}}{\partial{\alpha_{2}}}$中可以得到:</p>
<p>$$<br>\frac{\partial{W(\alpha_{2})}}{\partial{\alpha_{2}}} = -(K_{1, 1}) + K_{2, 2} - 2K_{1, 2})\alpha_{2}^{new} +(K_{1, 1}) + K_{2, 2} - 2K_{1, 2})\alpha_{2}^{old} + y_{2}\left[ y_{2} - y_{1} + f(x_{1}) - f(x_{2}) \right]<br>$$</p>
<p>我们记$E_{i}$为SVM预测值与真实值的误差: $E_{i} = f(x_{i}) - y_{i}$</p>
<p>令$\eta = K_{1, 1} + K_{2, 2} - 2K_{1, 2}$得到最终的一阶导数表达式:</p>
<p>$$<br>\frac{\partial{W(\alpha_{2})}}{\partial{\alpha_{2}}} = -\eta \alpha_{2}^{new} + \eta \alpha_{2}^{old} + y_{2}(E_{1} - E_{2}) = 0<br>$$</p>
<p>得到:<br>$$<br>\alpha_{2}^{new} = \alpha_{2}^{old} + \frac{y_{2}(E_{1} - E_{2})}{\eta}<br>$$</p>
<p>这样我们就得到了通过旧的$\alpha_{2}$获取新的$\alpha_{2}$的表达式, $\alpha_{1}^{new}$便可以通过$\alpha_{2}^{new}$得到。</p>
<h4 id="对原始解进行修剪"><a href="#对原始解进行修剪" class="headerlink" title="对原始解进行修剪"></a>对原始解进行修剪</h4><p>上面我们通过对一元函数求极值的方式得到的最优$\alpha_{i}, \alpha_{j}$是未考虑约束条件下的最优解，我们便更正我们上部分得到的$\alpha_{2}^{new}$为$\alpha_{2}^{new, unclipped}$, 即:<br>$$<br>\alpha_{2}^{new, unclipped} = \alpha_{2}^{old} + \frac{y_{2}(E_{1} - E_{2})}{\eta}<br>$$</p>
<p>但是在SVM中我们的$\alpha_{i}$是有约束的，即:<br>$\alpha_{1}y_{1} + \alpha_{2}y_{2} = -\sum_{i=3}^{N}\alpha_{i}y_{i} = \zeta$<br>$0 \le \alpha_{i} \le C$</p>
<p>此约束为方形约束(Bosk constraint), 在二维平面中我们可以看到这是个限制在方形区域中的直线（见下图）。</p>
<p><img src="/assets/images/blog_img/2017-09-01-机器学习算法实践-SVM中的SMO算法/bosk_constraint.png" alt=""></p>
<ol>
<li><p>(如左图) 当$y_{1} \ne y_{2}$时，线性限制条件可以写成: $\alpha_{1} - \alpha_{2} = k$，根据$k$的正负可以得到不同的上下界，因此统一表示成:</p>
<ul>
<li>下界: $L = \max(0, \alpha_{2}^{old} - \alpha_{1}^{old})$</li>
<li>上界: $H = \min(C, C + \alpha_{2}^{old} - \alpha_{1}^{old})$</li>
</ul>
</li>
<li><p>(如右图) 当$y_{1} = y_{2}$时，限制条件可写成: $\alpha_{1} + \alpha_{2} = k$, 上下界表示成:</p>
<ul>
<li>下界: $L = \max(0, \alpha_{1}^{old} + \alpha_{2}^{old} - C)$</li>
<li>上界: $H = \min(C, \alpha_{2}^{old} + \alpha_{1}^{old})$</li>
</ul>
</li>
</ol>
<p>根据得到的上下界，我们可以得到修剪后的$\alpha_{2}^{new}$:<br>$$<br>\alpha_{2}^{new} =<br>\begin{cases}<br>H &amp; \alpha_{2}^{new, unclipped} &gt; H \\<br>\alpha_{2}^{new, unclipped} &amp; L \le \alpha_{2}^{new, unclipped} \le H \\<br>L &amp; \alpha_{2}^{new, unclipped} &lt; L<br>\end{cases}<br>$$</p>
<p>得到了$\alpha_{2}^{new}$我们便可以根据$\alpha_{1}^{old}y_{1} + \alpha_{2}^{old}y_{2} = \alpha_{1}^{new}y_{1} + \alpha_{2}^{new}y_{2}$得到$\alpha_{1}^{new}$:<br>$$<br>\alpha_{1}^{new} = \alpha_{1}^{old} + y_{1}y_{2}(\alpha_{2}^{old} - \alpha_{2}^{new})<br>$$</p>
<p>OK， 这样我们就知道如何将选取的一对$\alpha_{i}, \alpha_{j}$进行优化更新了。</p>
<h4 id="更新阈值-b"><a href="#更新阈值-b" class="headerlink" title="更新阈值$b$"></a>更新阈值$b$</h4><p>当我们更新了一对$\alpha_{i}, \alpha_{j}$之后都需要重新计算阈值$b$，因为$b$关系到我们$f(x)$的计算，关系到下次优化的时候误差$E_{i}$的计算。</p>
<p>为了使得被优化的样本都满足KKT条件，</p>
<p>当$\alpha_{1}^{new}$不在边界，即$0 &lt; \alpha_{1}^{new} &lt; C$, 根据KKT条件可知相应的数据点为支持向量，满足$y_{1}(w^{T}x_{1} + b) = 1$, 两边同时乘上$y_{1}$得到$\sum_{i=1}^{N}\alpha_{i}y_{i}K_{i, 1} + b = y_{1}$, 进而得到$b_{1}^{new}$的值:<br>$$<br>b_{1}^{new} = y_{1} - \sum_{i=3}^{N}\alpha_{i}y_{i}K_{i, 1} - \alpha_{1}^{new}y_{1}K_{1, 1} - \alpha_{2}^{new}y_{2}K_{2, 1}<br>$$</p>
<p>其中上式的前两项可以写成:<br>$$<br>y_{1} - \sum_{i=3}^{N}\alpha_{i}y_{i}K_{i, 1} = -E_{1} + \alpha_{1}^{old}y_{1}K_{1, 1} + \alpha_{2}^{old}y_{2}K_{2, 1} + b^{old}<br>$$</p>
<p>代入$b_{new}$的表达式中得到:<br>$$<br>b_{1}^{new} = -E_{1} - y_{1}K_{1, 1}(\alpha_{1}^{new} - \alpha_{1}^{old}) - y_{2}K_{2, 1}(\alpha_{2}^{new} - \alpha_{2}^{old}) + b^{old}<br>$$</p>
<p>当$0 &lt; \alpha_{2}^{new} &lt; C$, 可以得到$b_{2}^{new}$的表达式(推导同上):</p>
<p>$$<br>b_{2}^{new} = -E_{2} - y_{1}K_{1, 2}(\alpha_{1}^{new} - \alpha_{1}^{old}) - y_{2}K_{2, 2}(\alpha_{2}^{new} - \alpha_{2}^{old}) + b^{old}<br>$$</p>
<p>当$b_{1}$和$b_{2}$都有效的时候他们是相等的, 即$b^{new} = b_{1}^{new} = b_{2}^{new}$。</p>
<p>当两个乘子$\alpha_{1}, \alpha_{2}$都在边界上，且$L \ne H$时，$b1, b2$之间的值就是和KKT条件一直的阈值。SMO选择他们的中点作为新的阈值: </p>
<p>$$b^{new} = \frac{b_{1}^{new} + b_{2}^{new}}{2}$$</p>
<h2 id="简化版SMO算法实现"><a href="#简化版SMO算法实现" class="headerlink" title="简化版SMO算法实现"></a>简化版SMO算法实现</h2><p>这里我主要针对SMO中已选取的一对$\alpha_{i}, \alpha_{j}$值的优化过程进行下Python实现，其中$\alpha_{i}, \alpha_{j}$的选取直接使用傻瓜的遍历方式，并使用100数据点进行训练。</p>
<p>首先是一些辅助函数，用来帮助加载数据，修剪$\alpha$的值以及随机选取$\alpha$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">(filename)</span>:</span></div><div class="line">    dataset, labels = [], []</div><div class="line">    <span class="keyword">with</span> open(filename, <span class="string">'r'</span>) <span class="keyword">as</span> f:</div><div class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</div><div class="line">            x, y, label = [float(i) <span class="keyword">for</span> i <span class="keyword">in</span> line.strip().split()]</div><div class="line">            dataset.append([x, y])</div><div class="line">            labels.append(label)</div><div class="line">    <span class="keyword">return</span> dataset, labels</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">clip</span><span class="params">(alpha, L, H)</span>:</span></div><div class="line">    <span class="string">''' 修建alpha的值到L和H之间.</span></div><div class="line">    '''</div><div class="line">    <span class="keyword">if</span> alpha &lt; L:</div><div class="line">        <span class="keyword">return</span> L</div><div class="line">    <span class="keyword">elif</span> alpha &gt; H:</div><div class="line">        <span class="keyword">return</span> H</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> alpha</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_j</span><span class="params">(i, m)</span>:</span></div><div class="line">    <span class="string">''' 在m中随机选择除了i之外剩余的数</span></div><div class="line">    '''</div><div class="line">    l = list(range(m))</div><div class="line">    seq = l[: i] + l[i+<span class="number">1</span>:]</div><div class="line">    <span class="keyword">return</span> random.choice(seq)</div></pre></td></tr></table></figure>
<p>为了能在最后绘制SVM分割线，我们需要根据获取的$\alpha$，数据点以及标签来获取$w$的值:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_w</span><span class="params">(alphas, dataset, labels)</span>:</span></div><div class="line">    <span class="string">''' 通过已知数据点和拉格朗日乘子获得分割超平面参数w</span></div><div class="line">    '''</div><div class="line">    alphas, dataset, labels = np.array(alphas), np.array(dataset), np.array(labels)</div><div class="line">    yx = labels.reshape(<span class="number">1</span>, <span class="number">-1</span>).T*np.array([<span class="number">1</span>, <span class="number">1</span>])*dataset</div><div class="line">    w = np.dot(yx.T, alphas)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> w.tolist()</div></pre></td></tr></table></figure></p>
<p>简化版SMO算法的实现,即便没有添加启发式的$\alpha$选取，SMO算法仍然有比较多的公式需要实现，我本人按照上文的推导进行实现的时候就因为写错了一个下标算法一直跑不出想要的结果。</p>
<p>此实现主要包含两重循环，外层循环是控制最大迭代步数，此迭代步数是在每次有优化一对$\alpha$之后进行判断所选取的$\alpha$是否已被优化，如果没有则进行加一，如果连续$max_iter$步数之后仍然没有$\alpha$被优化，则我们就认为所有的$\alpha$基本已经被优化，优化便可以终止了.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_smo</span><span class="params">(dataset, labels, C, max_iter)</span>:</span></div><div class="line">    <span class="string">''' 简化版SMO算法实现，未使用启发式方法对alpha对进行选择.</span></div><div class="line"></div><div class="line">    :param dataset: 所有特征数据向量</div><div class="line">    :param labels: 所有的数据标签</div><div class="line">    :param C: 软间隔常数, 0 &lt;= alpha_i &lt;= C</div><div class="line">    :param max_iter: 外层循环最大迭代次数</div><div class="line">    '''</div><div class="line">    dataset = np.array(dataset)</div><div class="line">    m, n = dataset.shape</div><div class="line">    labels = np.array(labels)</div><div class="line"></div><div class="line">    <span class="comment"># 初始化参数</span></div><div class="line">    alphas = np.zeros(m)</div><div class="line">    b = <span class="number">0</span></div><div class="line">    it = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></div><div class="line">        <span class="string">"SVM分类器函数 y = w^Tx + b"</span></div><div class="line">        <span class="comment"># Kernel function vector.</span></div><div class="line">        x = np.matrix(x).T</div><div class="line">        data = np.matrix(dataset)</div><div class="line">        ks = data*x</div><div class="line"></div><div class="line">        <span class="comment"># Predictive value.</span></div><div class="line">        wx = np.matrix(alphas*labels)*ks</div><div class="line">        fx = wx + b</div><div class="line"></div><div class="line">        <span class="keyword">return</span> fx[<span class="number">0</span>, <span class="number">0</span>]</div><div class="line"></div><div class="line">    all_alphas, all_bs = [], []</div><div class="line"></div><div class="line">    <span class="keyword">while</span> it &lt; max_iter:</div><div class="line">        pair_changed = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</div><div class="line">            a_i, x_i, y_i = alphas[i], dataset[i], labels[i]</div><div class="line">            fx_i = f(x_i)</div><div class="line">            E_i = fx_i - y_i</div><div class="line"></div><div class="line">            j = select_j(i, m)</div><div class="line">            a_j, x_j, y_j = alphas[j], dataset[j], labels[j]</div><div class="line">            fx_j = f(x_j)</div><div class="line">            E_j = fx_j - y_j</div><div class="line"></div><div class="line">            K_ii, K_jj, K_ij = np.dot(x_i, x_i), np.dot(x_j, x_j), np.dot(x_i, x_j)</div><div class="line">            eta = K_ii + K_jj - <span class="number">2</span>*K_ij</div><div class="line">            <span class="keyword">if</span> eta &lt;= <span class="number">0</span>:</div><div class="line">                print(<span class="string">'WARNING  eta &lt;= 0'</span>)</div><div class="line">                <span class="keyword">continue</span></div><div class="line"></div><div class="line">            <span class="comment"># 获取更新的alpha对</span></div><div class="line">            a_i_old, a_j_old = a_i, a_j</div><div class="line">            a_j_new = a_j_old + y_j*(E_i - E_j)/eta</div><div class="line"></div><div class="line">            <span class="comment"># 对alpha进行修剪</span></div><div class="line">            <span class="keyword">if</span> y_i != y_j:</div><div class="line">                L = max(<span class="number">0</span>, a_j_old - a_i_old)</div><div class="line">                H = min(C, C + a_j_old - a_i_old)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                L = max(<span class="number">0</span>, a_i_old + a_j_old - C)</div><div class="line">                H = min(C, a_j_old + a_i_old)</div><div class="line"></div><div class="line">            a_j_new = clip(a_j_new, L, H)</div><div class="line">            a_i_new = a_i_old + y_i*y_j*(a_j_old - a_j_new)</div><div class="line"></div><div class="line">            <span class="keyword">if</span> abs(a_j_new - a_j_old) &lt; <span class="number">0.00001</span>:</div><div class="line">                <span class="comment">#print('WARNING   alpha_j not moving enough')</span></div><div class="line">                <span class="keyword">continue</span></div><div class="line"></div><div class="line">            alphas[i], alphas[j] = a_i_new, a_j_new</div><div class="line"></div><div class="line">            <span class="comment"># 更新阈值b</span></div><div class="line">            b_i = -E_i - y_i*K_ii*(a_i_new - a_i_old) - y_j*K_ij*(a_j_new - a_j_old) + b</div><div class="line">            b_j = -E_j - y_i*K_ij*(a_i_new - a_i_old) - y_j*K_jj*(a_j_new - a_j_old) + b</div><div class="line"></div><div class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt; a_i_new &lt; C:</div><div class="line">                b = b_i</div><div class="line">            <span class="keyword">elif</span> <span class="number">0</span> &lt; a_j_new &lt; C:</div><div class="line">                b = b_j</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                b = (b_i + b_j)/<span class="number">2</span></div><div class="line"></div><div class="line">            all_alphas.append(alphas)</div><div class="line">            all_bs.append(b)</div><div class="line"></div><div class="line">            pair_changed += <span class="number">1</span></div><div class="line">            print(<span class="string">'INFO   iteration:&#123;&#125;  i:&#123;&#125;  pair_changed:&#123;&#125;'</span>.format(it, i, pair_changed))</div><div class="line"></div><div class="line">        <span class="keyword">if</span> pair_changed == <span class="number">0</span>:</div><div class="line">            it += <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            it = <span class="number">0</span></div><div class="line">        print(<span class="string">'iteration number: &#123;&#125;'</span>.format(it))</div><div class="line"></div><div class="line">    <span class="keyword">return</span> alphas, b</div></pre></td></tr></table></figure>
<p>Ok, 下面我们就用训练数据对SVM进行优化, 并对最后优化的分割线以及数据点进行可视化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="string">'__main__'</span> == __name__:</div><div class="line">    <span class="comment"># 加载训练数据</span></div><div class="line">    dataset, labels = load_data(<span class="string">'testSet.txt'</span>)</div><div class="line">    <span class="comment"># 使用简化版SMO算法优化SVM</span></div><div class="line">    alphas, b = simple_smo(dataset, labels, <span class="number">0.6</span>, <span class="number">40</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 分类数据点</span></div><div class="line">    classified_pts = &#123;<span class="string">'+1'</span>: [], <span class="string">'-1'</span>: []&#125;</div><div class="line">    <span class="keyword">for</span> point, label <span class="keyword">in</span> zip(dataset, labels):</div><div class="line">        <span class="keyword">if</span> label == <span class="number">1.0</span>:</div><div class="line">            classified_pts[<span class="string">'+1'</span>].append(point)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            classified_pts[<span class="string">'-1'</span>].append(point)</div><div class="line"></div><div class="line">    fig = plt.figure()</div><div class="line">    ax = fig.add_subplot(<span class="number">111</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 绘制数据点</span></div><div class="line">    <span class="keyword">for</span> label, pts <span class="keyword">in</span> classified_pts.items():</div><div class="line">        pts = np.array(pts)</div><div class="line">        ax.scatter(pts[:, <span class="number">0</span>], pts[:, <span class="number">1</span>], label=label)</div><div class="line"></div><div class="line">    <span class="comment"># 绘制分割线</span></div><div class="line">    w = get_w(alphas, dataset, labels)</div><div class="line">    x1, _ = max(dataset, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</div><div class="line">    x2, _ = min(dataset, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</div><div class="line">    a1, a2 = w</div><div class="line">    y1, y2 = (-b - a1*x1)/a2, (-b - a1*x2)/a2</div><div class="line">    ax.plot([x1, x2], [y1, y2])</div><div class="line"></div><div class="line">    <span class="comment"># 绘制支持向量</span></div><div class="line">    <span class="keyword">for</span> i, alpha <span class="keyword">in</span> enumerate(alphas):</div><div class="line">        <span class="keyword">if</span> abs(alpha) &gt; <span class="number">1e-3</span>:</div><div class="line">            x, y = dataset[i]</div><div class="line">            ax.scatter([x], [y], s=<span class="number">150</span>, c=<span class="string">'none'</span>, alpha=<span class="number">0.7</span>,</div><div class="line">                       linewidth=<span class="number">1.5</span>, edgecolor=<span class="string">'#AB3319'</span>)</div><div class="line"></div><div class="line">    plt.show()</div></pre></td></tr></table></figure>
<p>优化最后我们可以看到针对100个数据的$\alpha$只有少部分是大于零的，即对应的数据点就是支持向量:</p>
<p><img src="/assets/images/blog_img/2017-09-01-机器学习算法实践-SVM中的SMO算法/alphas.png" alt=""></p>
<p>为了能直观的显示支持向量，我将其标注了出来，最终可视化的效果如下图:</p>
<p><img src="/assets/images/blog_img/2017-09-01-机器学习算法实践-SVM中的SMO算法/simple_smo.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从坐标上升算法开始介绍，并对SMO算法的原理进行了简单的推导，针对SMO算法中对$\alpha$对的优化并使用了Python进行了简化版的SMO实现，并针对小数据集进行了训练得到了对应优化后的SVM。</p>
<p>实现代码以及训练数据链接: <a href="https://github.com/PytLab/MLBox/tree/master/svm" target="_blank" rel="external">https://github.com/PytLab/MLBox/tree/master/svm</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://blog.csdn.net/google19890102/article/details/51065297" target="_blank" rel="external">优化算法——坐标上升法</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/28299882" target="_blank" rel="external">支持向量机系列（5）——SMO算法解对偶问题</a></li>
<li>《Machine Learning in Action》</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> MachineLearning </tag>
            
            <tag> SVM </tag>
            
            <tag> SMO </tag>
            
            <tag> CoordianteAscent </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习算法实践-SVM核函数和软间隔]]></title>
      <url>http://pytlab.github.io/2017/08/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5-SVM%E6%A0%B8%E5%87%BD%E6%95%B0%E5%92%8C%E8%BD%AF%E9%97%B4%E9%9A%94/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上文中简单总结了对于线性可分数据的SVM的算法原理，本文对于非线性可分以及有噪声存在的时候我们需要对基本SVM算法的改进进行下总结其中包括:</p>
<ol>
<li>核函数在SVM算法中的使用</li>
<li>引入松弛变量和惩罚函数的软间隔分类器</li>
</ol>
<h2 id="SVM对偶问题"><a href="#SVM对偶问题" class="headerlink" title="SVM对偶问题"></a>SVM对偶问题</h2><p>这里稍微回顾下SVM最终的对偶优化问题，因为后面的改进都是在对偶问题的形式上衍生的。</p>
<a id="more"></a>
<h3 id="标准形式"><a href="#标准形式" class="headerlink" title="标准形式"></a>标准形式</h3><p>$$\min \frac{1}{2} \lVert w \rVert ^{2}$$</p>
<p>subject to $y_{i}(w^{T}x_{i} + b) \ge 1$</p>
<h3 id="对偶形式"><a href="#对偶形式" class="headerlink" title="对偶形式"></a>对偶形式</h3><p>$$arg \max \limits_{\alpha} \sum_{i=1}^{N} \alpha_{i} - \frac{1}{2}\sum_{i=1}^{N}\sum_{j=1}^{N}y_{i}y_{j}\alpha_{i}\alpha_{j}\langle x_{i}, x_{j} \rangle$$</p>
<p>subject to $\alpha_{i} \ge 0$ ; $\sum_{i=1}^{N}\alpha_{i}y_{i}=0$</p>
<p>其中$w$和$\alpha$的关系:<br>$$w = \sum_{i=1}^{N}\alpha_{i}y_{i}x_{i}$$</p>
<h3 id="SVM预测"><a href="#SVM预测" class="headerlink" title="SVM预测"></a>SVM预测</h3><p>SVM通过分割超平面$w^{T}x + b$来获取未知数据的类型，将上述$w$用$\alpha$替换得到</p>
<p>$$<br>h_{w, b}(x) = g(w^{T}x + b) = g(\sum_{i=1}^{N}\alpha_{i}y_{i} \langle x_{i}, x \rangle + b)<br>$$</p>
<p>通过$g(x)$输出+1或者-1来获取未知数据的类型预测.</p>
<h2 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h2><p>对于分线性可分的数据我们通常需要将数据映射到高维空间中使得原本在低维空间线性不可分的数据在高维空间中线性可分。例如从一维映射到4维:<br>$$<br>x \xrightarrow{\phi(x)} \left[\begin{matrix}<br>x \\<br>x^{2} \\<br>x^{3} \\<br>x^{4} \\<br>\end{matrix} \right]<br>$$</p>
<p>然后对偶形式中也有数据向量的乘积，于是便可以进行替换:<br>$$<br>\langle x_{i}, x_{j} \rangle \rightarrow \langle \phi(x_{i}), \phi(x_{j}) \rangle<br>$$</p>
<p>但是呢，有时候$\phi(x)$会使得$x$维度太高，这样计算内积的复杂度很高，计算起来就会很困难，这个时候我们便需要核函数来拯救我们的计算复杂度。</p>
<p>我们需要使用一个函数来代替向量内积,但是这个核函数是可以表示成向量内积的形式的，只不过在计算结果的时候我们直接求函数值就好了，不需要做内积运算。这样复杂度会降低:<br>$$<br>K(x, z) = \langle \phi(x), \phi(z) \rangle<br>$$</p>
<h3 id="核函数例子"><a href="#核函数例子" class="headerlink" title="核函数例子"></a>核函数例子</h3><p>这里总结下几个例子来对核函数的作用加深下理解.</p>
<p>对于$x, z \in \mathbb{R}^{n}$, 我们令核函数为:<br>$$K(x, z) = (x^{T}z)^{2} = (\sum_{i=1}^{N}x_{i}z_{i})^{2} = \sum_{i=1}^{N}\sum_{j=1}^{N} (x_{i}x_{j})(z_{i}z_{j}) = \langle \phi(x), \phi(z) \rangle$$</p>
<p>对于$x \in \mathbb{R}^{2}$, 这个时候$\phi(x)$的作用就相当于:<br>$$<br>\phi(x) = \left[ \begin{matrix}<br>x_{1}x_{1} \\<br>x_{1}x_{2} \\<br>x_{2}x_{1} \\<br>x_{2}x_{2} \\<br>\end{matrix} \right]<br>$$</p>
<p>那么我们可以分析下，如果没有引入核函数，我们需要计算维数为$n^{2}$的向量的内积，其运算时间复杂度为$O(n^{2})$。d但是通过核函数的引入我们不需要显式的计算向量内积了，而是直接计算核函数$(x^{T}z)^2$的值，计算核函数的值我们只需要计算一次维数为$n$的向量内积和一次平方运算，时间复杂度为$O(n)$。</p>
<p>可见，我们通过计算核函数，隐式的处理了一个维数很高的向量空间，降低了计算复杂度($O(n^{2} \rightarrow O(n)$)。</p>
<p>对于上面的核函数进行推广，我们可以有核函数:</p>
<p>$$<br>K(x, z) = (x^{T}z + C)^{2} = (x^{T}z)^{2} + 2C(x^{T}z) + c^{2}<br>$$</p>
<p>对于$x \in \mathbb{R}^{2}$, 这时$\phi(x)$相当于:<br>$$<br>\phi(x) = \left[ \begin{matrix}<br>x_{1}x_{1} \\<br>x_{1}x_{2} \\<br>x_{2}x_{1} \\<br>x_{2}x_{2} \\<br>\sqrt{2C}x_{1} \\<br>\sqrt{2C}x_{2} \\<br>C \\<br>\end{matrix} \right]<br>$$</p>
<p>这样我们将原本需要计算长度为$n^{2} + n + 1$的向量内积改成了直接计算两个长度为$n$的向量内积以及一个求和一次乘积运算。复杂度从$O(n^{2})$降到了$O(n)$</p>
<p>更通用的形式可以写成:</p>
<p>$$<br>K(x, z) = (x^{T}z + C)^{d}<br>$$</p>
<p>可见，在我们原始的SVM推导中，直接使用原始向量的内积便是这种形式的一种特殊形式，即$C = 0, d = 1$</p>
<p>另外，可以直观的看到，如果$\phi(x)$与$\phi(z)$的夹角比较小，则计算出来的$K(x, z)$就会比较大，相反如果$\phi(x)$与$\phi(z)$的夹角比较大，则核函数$K(x, z)$会比较小。所以核函数一定程度上是$\phi(x)$与$\phi(z)$相似度的度量。</p>
<h3 id="高斯核函数-Gaussian-kernel"><a href="#高斯核函数-Gaussian-kernel" class="headerlink" title="高斯核函数(Gaussian kernel)"></a>高斯核函数(Gaussian kernel)</h3><p>$$<br>K(x, z) = exp(-\frac{\lVert x - z \rVert^{2}}{2\sigma^{2}})<br>$$</p>
<p>通过高斯核函数的公式可以看出，如果$x$和$z$相差很小，则$K(x, z)$趋近于1, 相反如果相差很大则$K(x, z)$趋近于0。高斯核函数能够将数据映射到无限维空间，在无限维空间中，数据都是线性可分的。</p>
<h3 id="核函数的合法性"><a href="#核函数的合法性" class="headerlink" title="核函数的合法性"></a>核函数的合法性</h3><p>判定核函数的合法性需要构造一个矩阵，即核函数矩阵$K$。</p>
<p>对于一个核函数$K(x, z)$以及$m$个训练数据$\left\{ x_{1}, x_{2}, …, x_{m} \right\}$, 核函数矩阵中的元素$K_{i,j}$定义如下:</p>
<p>$$K_{i, j} = K(x_{i}, x_{j})$$</p>
<p>现在在这里简单推导下核函数有效的必要条件:</p>
<p>若$K(x, z)$有效，则矩阵元素可写成(矩阵为对称矩阵)<br>$$<br>K_{i, j} = \phi(x_{i})^{T}\phi(x_{j}) = \phi(x_{j})^{T}\phi(x_{i}) = K_{i, j}<br>$$</p>
<p>对于向量$z$, 我们有:<br>$$<br>z^{T}Kz = \sum_{i} \sum_{j} z_{i}K_{i, j}z_{j} = \sum_{i} \sum_{j}z_{i}\phi(x_{i})^{T}\phi(x_{j})z_{j} = \sum_{i} \sum_{j} z_{i} (\sum_{k}\phi(x_{i})_{k} \phi(x_{j})_{k}) z_{j}<br>$$<br>$$<br>= \sum_{k} \sum_{i} \sum_{j} z_{i} \phi(x_{i})_{k} \phi(x_{j})_{k} z_{j} = \sum_{k}(\sum_{i} z_{i}\phi(x_{i})_{k})^{2} \ge 0<br>$$</p>
<p>此为矩阵$K$为半正定矩阵的必要条件。这就证明了，矩阵$K \ge 0$是对应核函数$K$有效的必要条件。当然他也是充分条件(参考<a href="https://en.wikipedia.org/wiki/Mercer&#39;s_theorem" target="_blank" rel="external">Mercer’s theorem</a>)</p>
<p>因此通过mercer定理我们可以不需要显式的去寻找核函数对应的$\phi(x)$而是构造核函数矩阵$K$，进而判断$K$是否半正定来判断核函数的有效性。</p>
<h2 id="L1软间隔SVM-L1-soft-margin-SVM"><a href="#L1软间隔SVM-L1-soft-margin-SVM" class="headerlink" title="L1软间隔SVM(L1 soft margin SVM)"></a>L1软间隔SVM(L1 soft margin SVM)</h2><p>通过核函数将数据映射到高维空间能够增加数据线性可分的可能性，但是对于含有噪声的数据，优化出来的SVM可能不是我们最想要的，我们并不希望SVM会被噪声影响，因此我们可以通过引入松弛变量来使我们优化SVM时忽略掉噪声的影响，仅仅考虑那些真正有效的数据。</p>
<p>对于原始SVM标砖形式的约束条件:<br>$$<br>y_{i}(w^{T}x_{i} + b) \ge 1<br>$$<br>意味着所有数据点距离分割平面的距离都大于1.</p>
<p>但有的时候具有噪声，完全按照原始的约束条件，可能会是SVM发生较大的误差，如下图:</p>
<p><img src="/assets/images/blog_img/2017-08-30-机器学习算法实践-SVM核函数和软间隔/soft_margin.png" alt=""></p>
<p>为了能让SVM忽略某些噪声，我们可以引入一个松弛变量$\xi_{i} \ge 0$来允许错误的分类发生，也就是允许有间隔小于1的数据点出现, 即:</p>
<p>$$<br>y_{i}(w^{T}x_{i} + b) \ge 1 - \xi_{i}<br>$$</p>
<p>但是只松弛约束条件可不行，我们同样要限制这种松弛，这时候我们需要在目标函数上加一个惩罚函数。<br>原始的目标函数为:<br>$$<br>arg \min \limits_{w, b} \frac{1}{2} \lVert w \rVert^{2}<br>$$</p>
<p>加入惩罚后:<br>$$<br>arg \min \limits_{w, b, \xi} \frac{1}{2} \lVert w \rVert^{2} + C\sum_{i=1}^{N}\xi_{i}<br>$$<br>其中$C$为惩罚因子来衡量惩罚的程度, C越大表明离群点越不被希望出现。</p>
<p>于是加上惩罚函数的SVM优化问题就变为:<br>$$<br>arg \min \limits_{w, b, \xi} \frac{1}{2} \lVert w \rVert^{2} + C\sum_{i=1}^{N}\xi_{i}<br>$$<br>subject to $y_{i}(w^{T} + b) \ge 1 - \xi_{i}$, $\xi_{i} \ge 0, i = 1, …, N$</p>
<p>然后我们求此问题的对偶问题，方法与原始SVM推导方法相同，使用拉格朗日乘子法，然后获取$w$的表达式，回代最后获得对偶形式:<br>$$<br>arg \max \limits_{\alpha} [\sum_{i=1}^{N}{\alpha_{i}} - \frac{1}{2}\sum_{i=1}^{N}\sum_{j=1}^{N}y_{i}y_{j}\alpha_{i}\alpha_{j}\langle x_{i}, x_{j} \rangle]<br>$$</p>
<p>subject to $0 \le \alpha_{i} \le C$, $\sum_{i=1}^{m}\alpha_{i}y_{i} = 0$</p>
<p>可见，软间隔SVM的目标函数形式同硬间隔的形式相同，唯一不同的就在于$\alpha_{i}$的范围。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对SVM中的核函数以及软间隔的原理进行了总结，对于非线性可分以及含有噪声的数据我们可以通过以上两种方法获得合适的分类器。后面将对目标函数的优化方法进行总结。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MachineLearning </tag>
            
            <tag> SVM </tag>
            
            <tag> KernelFunction </tag>
            
            <tag> SoftMargin </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习算法实践-支持向量机(SVM)算法原理]]></title>
      <url>http://pytlab.github.io/2017/08/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA-SVM-%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于SVM的算法实践我打算分成多个部分进行总结。本文为第一部分主要介绍SVM的原理以及相关算法的简单推导，其中包括SVM原理，最初表达式，标准形式以及对偶形式(二次规划问题)，形式变化过程中涉及到求解有约束优化问题的拉格朗日乘子法以及KKT条件等。</p>
<h2 id="什么是支持向量机"><a href="#什么是支持向量机" class="headerlink" title="什么是支持向量机"></a>什么是支持向量机</h2><p>对于线性可分两类数据，支持向量机就是条<strong>直线</strong>(对于高维数据点就是一个<strong>超平面</strong>), 两类数据点中的的分割线有无数条，SVM就是这无数条中最完美的一条，怎么样才算最完美呢？就是这条线距离两类数据点越远，则当有新的数据点的时候我们使用这条线将其分类的结果也就越可信。例如下图中的三条直线都可以将A中的数据分类，那条可以有最优的分类能力呢？</p>
<ol>
<li>我们需要线找到数据点中距离分割超平面距离<strong>最近的点</strong>(找最小)</li>
<li>然后尽量使得距离超平面最近的点的距离的绝对值尽量的<strong>大</strong>(求最大)</li>
</ol>
<a id="more"></a>
<p><img src="/assets/images/blog_img/2017-08-15-机器学习算法实践-支持向量机-SVM-算法原理/seperate_line.jpeg" alt=""></p>
<p>这里的数据点到超平面的距离就是间隔(margin), 当间隔越大，我们这条线(分类器)也就越健壮。</p>
<p>那些距离分割平面最近的点就是<strong>支持向量(Support Vectors)</strong>.</p>
<div class="alert alert-info"><i class="fa fa-info"></i>  一句话总结下就是:支持向量机就是用来分割数据点那个分割面，他的位置是由支持向量确定的(如果支持向量发生了变化，往往分割面的位置也会随之改变), 因此这个面就是一个支持向量确定的分类器即支持向量机。</div>
<h2 id="求解支持向量机"><a href="#求解支持向量机" class="headerlink" title="求解支持向量机"></a>求解支持向量机</h2><p>本部分总结如何获取数据集的最优间隔分割平面(支持向量机)。</p>
<h3 id="分割超平面"><a href="#分割超平面" class="headerlink" title="分割超平面"></a>分割超平面</h3><p>将一维直线和二维平面拓展到任意维, 分割超平面可以表示成:<br>$$<br>w^{T}x + b = 0<br>$$</p>
<p>其中$w$和$b$就是SVM的参数，不同的$w$和$b$确定不同的分割面.</p>
<p>这里我们可以回忆一下Logistic回归，在Logistic回归模型中，我们也同样将$z=w^{T}x$放入到sigmoid函数中来做极大似然估计获取最有的参数$w$，其中logistic模型中$w$中的$w_{0}$便对应着现在我们这里的截距$b$。</p>
<p>但是与Logistic回归中我们将$z=w^{T}x + b$代入到sigmoid函数中获取的值为1或者0也就是数据标签为0或1。而在SVM中我们对于二分类，不再使用0/1而是使用+1/-1作为数据类型标签。之所以使用+1/-1是为了能方便的使用间隔公式来表示数据点到分割面的间隔。</p>
<h3 id="数据点与超平面的间隔"><a href="#数据点与超平面的间隔" class="headerlink" title="数据点与超平面的间隔"></a>数据点与超平面的间隔</h3><p>根据数据点到分割超平面的距离公式:<br>$$<br>d = \frac{1}{\lVert w \rVert} |w^{T}x + b|<br>$$</p>
<p>可见，在距离公式中有两个绝对值，其中分母上是常量，分子上则是与数据点相关的，如果数据点在分割平面上方，$w^{T}x + b &gt; 0$; 数据点在分割平面下方，$w^{T}x + b &lt; 0$。</p>
<p>这样我们在表示任意数据点到分割面的距离就会很麻烦，但是我们通过将数据标签设为+1/-1来讲距离统一用一个公式表示:</p>
<p>$$<br>d = y_{i} \cdot (w^{T}x + b) \cdot \frac{1}{\lVert w \rVert}<br>$$</p>
<p>这样，当数据点在分割面上方时，$y_{i} = 1$, $d &gt; 0$且数据点距离分割面越远$d$越大;<br>当数据点在分割面下方时，$y_{i} = -1$, $d$扔大于$0$, 且数据点距离分割面越远$d$越大。</p>
<h3 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h3><p>我们现在已经有了间隔的公式，我们需要找到一组最好的$w$和$b$确定的分割超平面使得<strong>支持向量</strong>距离此平面的<strong>间隔最大</strong>。</p>
<p><img src="/assets/images/blog_img/2017-08-15-机器学习算法实践-支持向量机-SVM-算法原理/target.png" alt=""></p>
<h4 id="直接形式"><a href="#直接形式" class="headerlink" title="直接形式"></a>直接形式</h4><p>直接使用公式表示:<br>$$<br>arg \max \limits_{w, b} \{ \min \limits_{n} (y_{i} \cdot (w^{T}x + b)) \cdot \frac{1}{\lVert w \rVert} \}<br>$$</p>
<p>通俗翻译下就是现在数据点中找到距离分割平面最近的点(支持向量)，然后优化$w$和$b$来最大化支持向量到分割超平面的距离。</p>
<p>直接优化上面的式子很困难，我们需要做一些处理，使得同样的优化问题可以使我们用方便的优化算法来求解。</p>
<h4 id="等比例改变参数-w-和-b"><a href="#等比例改变参数-w-和-b" class="headerlink" title="等比例改变参数$w$和$b$"></a>等比例改变参数$w$和$b$</h4><p>首先看下分割超平面的一个性质。当我们等比例的扩大或缩小$w$和$b$并不会改变超平面的位置。例如对于位于三维空间中的二维平面$3x + 2y + z + 5 = 0$, $w=[3, 2, 1]^{T}$, $b = 5$，我们扩大或者缩小$w$和$b$并不会影响平面，即$\frac{3}{2} + y + \frac{1}{2}z = 0$与原始平面相同。</p>
<p>这样我们就可以任意等比例修改参数，来使我们优化的目标表达起来更加友好。</p>
<h4 id="几何间隔和函数间隔"><a href="#几何间隔和函数间隔" class="headerlink" title="几何间隔和函数间隔"></a>几何间隔和函数间隔</h4><ul>
<li>函数间隔(Functional Margin): $\hat{\gamma_{i}} = y_{i}(wx_{i}^{T} + b)$</li>
<li>几何间隔(Geometry Margin): $\gamma_{i} = y_{i}(\frac{wx_{i}^{T}}{\lVert w \rVert} + \frac{b}{\lVert w \rVert})$</li>
</ul>
<p>可见由于我们可以等比例的改变参数，函数间隔相当于参数都乘上了$\lVert w \rVert$.</p>
<h4 id="标准形式"><a href="#标准形式" class="headerlink" title="标准形式"></a>标准形式</h4><p>我们的优化目标是最大化数据点到超平面的间隔，这里可以把最小化的部分(寻找支持向量)放到约束条件中, 有<br>$$<br>arg \max \limits_{w, b} \frac{\hat{\gamma}}{\lVert w \rVert}<br>$$<br>subject to<br>$$<br>y_{i} \cdot (wx_{i}^{T} + b) \ge \hat{\gamma}, i = 1,2,…,k<br>$$<br>其中$\hat{\gamma}$ 是支持向量到超平面的函数间隔。</p>
<p>我们将所有参数$w$和$b$除以$\hat{\gamma}$，便有$\hat{\gamma} = \min y_{i}(wx_{i}^{T} + b) = 1$, 于是有:<br>$$<br>arg \max \limits_{w, b} \frac{1}{\lVert w \rVert}<br>$$<br>subject to<br>$$<br>y_{i} \cdot (wx_{i}^{T} + b) \ge 1, i = 1,2,…,k<br>$$</p>
<p>将最大化问题转换为求最小值:</p>
<p>$$<br>arg \min \limits_{w, b} \frac{1}{2} \lVert w \rVert ^{2}<br>$$<br>subject to<br>$$<br>-y_{i} \cdot (wx_{i}^{T} + b) \le 1, i = 1,2,…,k<br>$$</p>
<p>这便是一个线性不等式约束下的二次优化问题, 下面我本就使用拉格朗日乘子法来获取我们优化目标的对偶形式。</p>
<h4 id="通过拉格朗日乘子法和KKT条件将约束条件放入到目标函数中"><a href="#通过拉格朗日乘子法和KKT条件将约束条件放入到目标函数中" class="headerlink" title="通过拉格朗日乘子法和KKT条件将约束条件放入到目标函数中"></a>通过拉格朗日乘子法和KKT条件将约束条件放入到目标函数中</h4><p>拉格朗日乘数法是一种寻找多元函数在其变量受到一个或多个条件的约束时的极值的方法。这种方法可以将一个有n个变量与k个约束条件的最优化问题转换为一个解有n + k个变量的方程组的解的问题。这样我们可以将我们带约束的目标函数通过拉格朗日乘子法将约束放入到目标函数中方便优化。KKT条件是拉格朗日乘子法在约束条件为不等式的一种延伸。下面我就对拉格朗日乘子法和KKT条件进行下简单总结。</p>
<h3 id="拉格朗日乘子法和KKT条件"><a href="#拉格朗日乘子法和KKT条件" class="headerlink" title="拉格朗日乘子法和KKT条件"></a>拉格朗日乘子法和KKT条件</h3><p>我们从无约束优化到带有不等式约束条件逐渐介绍下几种不同类型的优化问题。</p>
<h4 id="无约束优化问题"><a href="#无约束优化问题" class="headerlink" title="无约束优化问题"></a>无约束优化问题</h4><p>对于无约束优化问题<br>$$<br>\min \limits_{x} f(x)<br>$$<br>梯度$\nabla f(x) = 0$是局部最小点的必要条件，这样，优化问题的求解变成了对该必要条件解方程组。</p>
<h4 id="带等式约束的优化问题"><a href="#带等式约束的优化问题" class="headerlink" title="带等式约束的优化问题"></a>带等式约束的优化问题</h4><p>添加了等式限制条件，优化函数为: $\min \limits_{x} f(x)$, subject to $h(x) = 0$</p>
<p>拉格朗日乘子法就是通过引入新的位置变量(拉格朗日乘子)将上式的约束条件一起放到目标函数中:<br>$$<br>L(x, \lambda) = f(x) + \lambda h(x)<br>$$<br>subject to $h(x) = 0$</p>
<p>通过求解方程组: $\nabla L(x, \lambda) = 0; h(x) = 0$便可得到局部最小值的必要条件。</p>
<h4 id="拉格朗日乘子法原理"><a href="#拉格朗日乘子法原理" class="headerlink" title="拉格朗日乘子法原理"></a>拉格朗日乘子法原理</h4><p>我在这里稍微总结下Lagrange Multiplier的原理吧.</p>
<p><img src="/assets/images/blog_img/2017-08-15-机器学习算法实践-支持向量机-SVM-算法原理/Lagrange_multiplier.png" alt=""></p>
<p>参考上图(忽略函数形式的差异)，当约束条件$h(x) = 0$与$f(x)$的等高线相切的时候，切点具有局部最优值。此时$h(x^{*})$的梯度与$f(x^{*})$梯度<strong>同向</strong>，我们可以加入一个参数$\lambda$，得到他们之间的关系:<br>$$<br>\nabla f(x^{*}) + \lambda \nabla h(x^{*}) = 0<br>$$</p>
<p>上式便是对$L(x, \lambda) = f(x) + \lambda h(x)$ 求梯度等于0的结果, 这也就是拉格朗日函数了，其中那个关联梯度方向的$\lambda$就是拉格朗日乘子.</p>
<h4 id="KKT条件"><a href="#KKT条件" class="headerlink" title="KKT条件"></a>KKT条件</h4><p>KKT条件是对于有不等式和等式约束的最优化问题具有局部最优解的必要条件。</p>
<p>因为是我们现在的SVM目标函数只有不等式约束没有等式约束，我们可以将优化问题写成:</p>
<p>$$<br>\min \limits_{x} f(x)<br>$$</p>
<p>subject to $g_{1}(x) \le 0, g_{2}(x) \le 0$ (这里我们列出两个约束条件)</p>
<p>对应的<strong>拉格朗日函数</strong>:</p>
<p>$$L(x, \mu_{1}, \mu_{2}) = f(x) + \mu_{1}g_{1}(x) + \mu_{2}g_{2}(x)$$</p>
<p>则KKT条件(具有局部最优点的必要条件)为:</p>
<ol>
<li>$\mu_{1} \ge 0, \mu_{2} \ge 0$</li>
<li>$\nabla f(x) + \mu_{1} \nabla g_{1}(x) + \mu_{2} \nabla g_{2}(x) = 0$</li>
<li>$\mu_{1}g(x) + \mu_{2}g(x) = 0$</li>
</ol>
<p>不等式约束边界与目标函数的交接点不一定是切点了，如下图，如果两个不等式同时活跃(起作用)，则约束条件与等高线相遇的点是在顶点上。</p>
<p><img src="/assets/images/blog_img/2017-08-15-机器学习算法实践-支持向量机-SVM-算法原理/kkt.png" alt=""><br>图片来源:<a href="https://www.zhihu.com/question/43830699/answer/129887370" target="_blank" rel="external">https://www.zhihu.com/question/43830699/answer/129887370</a> ，侵删</p>
<p>等式约束函数和目标函数在切点的梯度方向同向，而不等式约束则有目标函数的梯度是约束函数在最优点的负梯度的<strong>线性组合</strong>(上图的红线和绿线), 于是我们便有约束和目标函数梯度的关系:<br>$$<br>\nabla f(x^{*}) = -\mu_{1} g_{1}(x^{*}) -\mu_{2} g_{2}(x^{*})<br>$$<br>其中$\mu_{1} \ge 0$, $\mu_{2} \ge 0$。</p>
<p>当然，最优点一定是在约束条件那条线上的，也就是满足<br>$$<br>g_{1}(x^{*}) = 0, g_{2}(x^{*}) = 0<br>$$</p>
<p>但是嘞，有的时候在最优点，不是所有的约束条件都起作用的。</p>
<p>对于有约束优化:<br>$$<br>\min \limits_{x} f(x)<br>$$<br>subject to $g_{1}(x) \le 0$, $g_{2}(x) \le 0$, $g_{3}(x) \le 0$</p>
<p><img src="/assets/images/blog_img/2017-08-15-机器学习算法实践-支持向量机-SVM-算法原理/kkt2.png" alt=""><br>图片来源:<a href="https://www.zhihu.com/question/43830699/answer/129887370" target="_blank" rel="external">https://www.zhihu.com/question/43830699/answer/129887370</a> ，侵删</p>
<p>如上图所示，$g_{3}(x) \le 0$约束条件并没有起作用，因此对于有三个约束条件的问题我们的另一个必要条件还可以写成:<br>$$<br>g_{1}(x^{*}) = 0, g_{2}(x^{*}) = 0<br>$$</p>
<p>为了统一表示，我们可以写成:<br>$$<br>\mu_{1}g_{1}(x^{*}) = 0; \mu_{2}g_{2}(x^{*}) = 0; \mu_{3}g_{3}(x^{*}) = 0<br>$$</p>
<p>由于$\mu_{i} \ge 0$，</p>
<ul>
<li>当约束条件$g_{3}(x^{*})$不起作用时，$\mu_{3} = 0$，便得到了与$ g_{1}(x^{*}) = 0, g_{2}(x^{*}) = 0$相同的条件。</li>
<li>当约束条件起作用时，$\mu_{i} \gt 0$</li>
</ul>
<h3 id="继续SVM"><a href="#继续SVM" class="headerlink" title="继续SVM"></a>继续SVM</h3><h4 id="SVM的拉格朗日函数"><a href="#SVM的拉格朗日函数" class="headerlink" title="SVM的拉格朗日函数"></a>SVM的拉格朗日函数</h4><p>上面对拉格朗日乘子法和KKT条件进行了简单的总结，下面我们将其应用在SVM目标函数上。</p>
<p>我们现在求解SVM，是要进行带约束的优化问题:</p>
<p>$$<br>arg \min \limits_{w, b} \frac{1}{2} \lVert w \rVert ^{2}<br>$$<br>subject to<br>$$<br>1 - y_{i} \cdot (wx_{i}^{T} + b) \le 0, i = 1,2,…,k<br>$$</p>
<p>对应的拉格朗日函数:<br>$$<br>L(w, b, \alpha) = \frac{1}{2} \lVert w \rVert^{2} - \sum_{i=1}^{N} \alpha_{i}[y_{i}(w^{T}x_{i} + b) - 1]<br>$$<br>其中, $\alpha_{i} \ge 0$</p>
<p>令$g_{i}(w, b) = -y_{i}(w^{T}x_{i} + b) + 1$，则有$g_{i}(w, b) \le 0$.</p>
<ul>
<li>如果$\alpha_{i} \gt 0$, 根据KKT条件$\alpha_{i}g_{i}(w, b) = 0$, 推出$g_{i}(w, b) = 0$, 则约束$g_{i} \le 0$ 是一个有效约束(active constraint), 对应的$x_{i}$为支持向量</li>
<li>如果$\alpha_{i} = 0$, 即$g_{i}(w, b) \lt 0$, $g_{i}(w, b) \le 0$ 为不起作用的约束，对应的$x_{i}$不是支持向量</li>
</ul>
<p>可见，<strong>支持向量对应的约束为活动约束, 我们的目标函数是由支持向量决定的，毕竟我们就是支持向量机嘛.</strong></p>
<h4 id="对偶形式"><a href="#对偶形式" class="headerlink" title="对偶形式"></a>对偶形式</h4><p>接下来我们要获取目标函数的对偶问题，通过求解对偶问题的解来获取逼近SVM最优解的解。</p>
<p>$$<br>L(w, b, \alpha) = \frac{1}{2} \lVert w \rVert^{2} - \sum_{i=1}^{N} \alpha_{i}[y_{i}(w^{T}x_{i} + b) - 1]<br>$$</p>
<p>我们的目标是求$L(w, b, \alpha)$的最小值，因此我们先把$L$看成是$w, b$的函数，通过梯度为零获取获取极小值的必要条件:<br>$$<br>\theta_{D}(\alpha) = \min \limits_{w, b} L(w, b, \alpha)<br>$$</p>
<ol>
<li><p>对于$w$: $\nabla _{w} L(w, b, \alpha) = w - \sum_{i=1}^{N} \alpha_{i} y_{i} x_{i} = 0$，得到$w = \sum_{i=1}^{N}\alpha_{i}y_{i}x_{i}$<br> 我们可以看到，最终的参数$w$是输入向量的<strong>线性组合</strong>, $\alpha$就是其权重</p>
</li>
<li><p>对于$b$: $\frac{\partial L}{\partial b} = -\sum_{i=1}^{N} \alpha_{i} y_{i} = 0$</p>
</li>
</ol>
<p>将上面的到的式子回代，得到对偶形式:<br>$$w^{T}w = (\sum_{i=1}{N}\alpha_{i}y_{i}x_{i})^{T}(\sum_{j=1}^{N}\alpha_{i} y_{i} x_{i}) = \sum_{i=1}^{N}\sum_{j=1}^{N}y_{i}y_{j}\alpha_{i}\alpha_{j} \langle x_{i}, x_{j} \rangle$$</p>
<p>$$W(\alpha) = \sum_{i=1}^{N}{\alpha_{i}} - \frac{1}{2}\sum_{i=1}^{N}\sum_{j=1}^{N}y_{i}y_{j}\alpha_{i}\alpha_{j}\langle x_{i}, x_{j} \rangle$$</p>
<p>对偶问题:<br>$$<br>\max \limits_{\alpha} W(\alpha)<br>$$<br>subject to $\alpha_{i} \ge 0; \sum_{i=1}^{N}y_{i}\alpha_{i} = 0$</p>
<p>关于对偶问题，这里我也稍微做下简单的总结。</p>
<p>通过获取优化问题的对偶问题，我们可以通过优化对偶问题来逼近原问题的最优解。就好像我们上面的拉格朗日函数，我们先将函数看作$w, b$的函数，求最小值，然后再把函数看成拉格朗日乘子的函数，并求最大值逼近原始问题的最优解。</p>
<p>例如在SVM中的拉格朗日函数为:</p>
<p>$$<br>L(w, b, \alpha) = \frac{1}{2} \lVert w \rVert^{2} - \sum_{i=1}^{N} \alpha_{i}[y_{i}(w^{T}x_{i} + b) - 1]<br>$$</p>
<p>其中, $\sum_{i}^{N} \alpha_{i}[y_{i}(w^{T}x_{i} + b) - 1] \ge 0$ 可知，</p>
<p>$$\min L(w, b, \alpha) \le \min \frac{1}{2} \lVert w \rVert$$</p>
<p>因此我们需要求$\max \limits_{\alpha} W(\alpha)$来使得对偶问题的最大值接近原问题的最小值。</p>
<p>Ok. 最终我们的优化目标函数可以写成:<br>$$<br>arg \max \limits_{\alpha} [\sum_{i=1}^{N}{\alpha_{i}} - \frac{1}{2}\sum_{i=1}^{N}\sum_{j=1}^{N}y_{i}y_{j}\alpha_{i}\alpha_{j}\langle x_{i}, x_{j} \rangle]<br>$$</p>
<p>约束条件: $\alpha_{i} \ge 0, \sum_{i=1}^{N}y_{i}\alpha_{i} = 0$</p>
<p>它是一个线性约束条件下多变量二次函数，一旦得到$\alpha$的解，便可以根据$\alpha$和$w$关系求出$w$，进而在得到$b$，于是我们就可以得到一个最优分割超平面。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文总结了SVM中的算法原理，其中包含了SVM中涉及到的拉格朗日乘子法和KKT条件的推导。并最终获取了目标函数的对偶形式，后面我将对对偶问题的求解算法进行总结。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Machine Learning in Action》</li>
<li><a href="https://en.wikipedia.org/wiki/Lagrange_multiplier" target="_blank" rel="external">https://en.wikipedia.org/wiki/Lagrange_multiplier</a></li>
<li><a href="https://www.zhihu.com/question/43830699" target="_blank" rel="external">是否所有的优化问题都可以转化成对偶问题？</a></li>
<li><a href="https://www.zhihu.com/question/21094489" target="_blank" rel="external">支持向量机(SVM)是什么意思？</a></li>
<li><a href="https://www.zhihu.com/question/58584814" target="_blank" rel="external">如何通俗地讲解对偶问题？尤其是拉格朗日对偶lagrangian duality？</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MachineLearning </tag>
            
            <tag> SVM </tag>
            
            <tag> LagrangeMultiplier </tag>
            
            <tag> ConvexOptimization </tag>
            
            <tag> KKT </tag>
            
            <tag> DualProblem </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[150多个最好的与机器学习,自然语言处理和Python相关的教程]]></title>
      <url>http://pytlab.github.io/2017/08/12/%E8%B6%85%E8%BF%87150%E4%B8%AA%E6%9C%80%E5%A5%BD%E7%9A%84%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E5%92%8CPython%E7%9B%B8%E5%85%B3%E7%9A%84%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本文翻译自<a href="https://unsupervisedmethods.com/over-150-of-the-best-machine-learning-nlp-and-python-tutorials-ive-found-ffce2939bd78" target="_blank" rel="external">Over 150 of the Best Machine Learning, NLP, and Python Tutorials I’ve Found</a>, 首发于<a href="http://blog.jobbole.com/112185/" target="_blank" rel="external">伯乐在线</a>，未经许可禁止转载。</p>
</blockquote>
<p>机器学习已经发展了很久, 它的<a href="https://en.wikipedia.org/wiki/Machine_learning#History_and_relationships_to_other_fields" target="_blank" rel="external">历史</a>可以追溯到1959年，但是如今此领域的发展速度可以说是空前的。在最近的<a href="https://unsupervisedmethods.com/why-artificial-intelligence-is-different-from-previous-technology-waves-764d7710df8b" target="_blank" rel="external">几篇文章</a>中, 我讨论了人工智能领域为何会在现在以及不久的将来持续蓬勃发展。如今很多对机器学习感兴趣的同学都普遍表示入门很难。</p>
<a id="more"></a>
<p>在准备博士课题的期间，我尝试在网络上搜索与机器学习和自然语言处理相关的优秀资源。当我找了一个有趣的教程或者视频，从这个教程或者视频出发我又可以找到三四个更多的教程或视频，最终就会出现的画面就是我还没有开始认真研究第一个找到的教程，浏览器已经打开了20个标签等待我去浏览了。(注: <a href="https://www.tabbundler.com/" target="_blank" rel="external">Tab Bundler</a> 可以帮助让我们的标签更有条理).</p>
<p>在找到了超过25个与机器学习相关的速查表后，我写了篇<a href="http://blog.jobbole.com/112009/" target="_blank" rel="external">文章</a>, 在里面整理了所有优秀的速查表.</p>
<p>为了给后面学习的童鞋铺路，我将我找到的最好的一些教程内容整理成了一份列表。这份列表并没有包含所有网上能找到的与机器学习相关的教程，否则这份列表将会过于臃肿。我的目标就是将我在机器学习和自然语言处理领域各个方面找到的我认为最好的教程整理出来。</p>
<p>在教程中，为了能够更好的让读者理解其中的概念，我将避免罗列书中每章的详细内容，而是总结一些概念性的介绍内容。为什么不直接去买本书？当你想要对某些特定的主题或者不同方面进行了初步了解时，我相信这些教程对你可能帮助更大。</p>
<p>本文中我将分四个主题进行整理: 机器学习，自然语言处理，Python和数学。在每个主题中我将包含一个例子和多个资源。当然我不可能完全覆盖所有的主题啦。</p>
<p>在将来，我也将会整理一系列类似的资源列表，包括书籍，视频和代码项目等。因为我目前也的确正在编译这些资源。</p>
<p>如果你发现我在这里遗漏了好的教程资源，请联系告诉我。为了避免资源重复罗列，我在每个主题下只列出了5、6个教程。下面的每个链接都应该链接了和其他链接不同的资源，也会通过不同的方式（例如幻灯片代码段)或者不同的角度呈现出这些内容。</p>
<h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><ul>
<li><a href="https://medium.com/@ageitgey/machine-learning-is-fun-80ea3ec3c471" target="_blank" rel="external">Machine Learning is Fun!</a> (medium.com/@ageitgey)</li>
<li>Machine Learning Crash Course: <a href="https://ml.berkeley.edu/blog/2016/11/06/tutorial-1/" target="_blank" rel="external">Part I</a>, <a href="https://ml.berkeley.edu/blog/2016/12/24/tutorial-2/" target="_blank" rel="external">Part II</a>, <a href="https://ml.berkeley.edu/blog/2017/02/04/tutorial-3/" target="_blank" rel="external">Part III</a> (Machine Learning at Berkeley)</li>
<li><a href="https://www.toptal.com/machine-learning/machine-learning-theory-an-introductory-primer" target="_blank" rel="external">An Introduction to Machine Learning Theory and Its Applications: A Visual Tutorial with Examples</a> (toptal.com)</li>
<li><a href="https://monkeylearn.com/blog/a-gentle-guide-to-machine-learning/" target="_blank" rel="external">A Gentle Guide to Machine Learning</a> (monkeylearn.com)</li>
<li><a href="https://blogs.sas.com/content/subconsciousmusings/2017/04/12/machine-learning-algorithm-use/" target="_blank" rel="external">Which machine learning algorithm should I use?</a> (sas.com)</li>
</ul>
<h4 id="激活函数和损失函数"><a href="#激活函数和损失函数" class="headerlink" title="激活函数和损失函数"></a>激活函数和损失函数</h4><ul>
<li><a href="http://neuralnetworksanddeeplearning.com/chap1.html#sigmoid_neurons" target="_blank" rel="external">Sigmoid neurons</a> (neuralnetworksanddeeplearning.com)</li>
<li><a href="https://www.quora.com/What-is-the-role-of-the-activation-function-in-a-neural-network" target="_blank" rel="external">What is the role of the activation function in a neural network?</a> (quora.com)</li>
<li><a href="https://stats.stackexchange.com/questions/115258/comprehensive-list-of-activation-functions-in-neural-networks-with-pros-cons" target="_blank" rel="external">Comprehensive list of activation functions in neural networks with pros/cons</a> (stats.stackexchange.com)</li>
<li><a href="https://medium.com/towards-data-science/activation-functions-and-its-types-which-is-better-a9a5310cc8f" target="_blank" rel="external">Activation functions and it’s types-Which is better?</a> (medium.com)</li>
<li><a href="http://www.exegetic.biz/blog/2015/12/making-sense-logarithmic-loss/" target="_blank" rel="external">Making Sense of Logarithmic Loss</a> (exegetic.biz)</li>
<li><a href="http://cs231n.github.io/neural-networks-2/#losses" target="_blank" rel="external">Loss Functions</a> (Stanford CS231n)</li>
<li><a href="http://rishy.github.io/ml/2015/07/28/l1-vs-l2-loss/" target="_blank" rel="external">L1 vs. L2 Loss function</a> (rishy.github.io)</li>
<li><a href="http://neuralnetworksanddeeplearning.com/chap3.html#the_cross-entropy_cost_function" target="_blank" rel="external">The cross-entropy cost function</a> (neuralnetworksanddeeplearning.com)</li>
</ul>
<h4 id="偏差"><a href="#偏差" class="headerlink" title="偏差"></a>偏差</h4><ul>
<li><a href="https://stackoverflow.com/questions/2480650/role-of-bias-in-neural-networks/2499936#2499936" target="_blank" rel="external">Role of Bias in Neural Networks</a> (stackoverflow.com)</li>
<li><a href="http://makeyourownneuralnetwork.blogspot.com/2016/06/bias-nodes-in-neural-networks.html" target="_blank" rel="external">Bias Nodes in Neural Networks</a> (makeyourownneuralnetwork.blogspot.com)</li>
<li><a href="https://www.quora.com/What-is-bias-in-artificial-neural-network" target="_blank" rel="external">What is bias in artificial neural network?</a> (quora.com)</li>
</ul>
<h4 id="感知器"><a href="#感知器" class="headerlink" title="感知器"></a>感知器</h4><ul>
<li><a href="http://neuralnetworksanddeeplearning.com/chap1.html#perceptrons" target="_blank" rel="external">Perceptrons</a> (neuralnetworksanddeeplearning.com)</li>
<li><a href="http://natureofcode.com/book/chapter-10-neural-networks/#chapter10_figure3" target="_blank" rel="external">The Perception</a> (natureofcode.com)</li>
<li><a href="http://computing.dcu.ie/~humphrys/Notes/Neural/single.neural.html" target="_blank" rel="external">Single-layer Neural Networks (Perceptrons)</a> (dcu.ie)</li>
<li><a href="https://www.toptal.com/machine-learning/an-introduction-to-deep-learning-from-perceptrons-to-deep-networks" target="_blank" rel="external">From Perceptrons to Deep Networks</a> (toptal.com)</li>
</ul>
<h4 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h4><ul>
<li><a href="http://people.duke.edu/~rnau/regintro.htm" target="_blank" rel="external">Introduction to linear regression analysis</a> (duke.edu)</li>
<li><a href="http://ufldl.stanford.edu/tutorial/supervised/LinearRegression/" target="_blank" rel="external">Linear Regression</a> (ufldl.stanford.edu)</li>
<li><a href="http://ml-cheatsheet.readthedocs.io/en/latest/linear_regression.html" target="_blank" rel="external">Linear Regression</a> (readthedocs.io)</li>
<li><a href="http://ml-cheatsheet.readthedocs.io/en/latest/logistic_regression.html" target="_blank" rel="external">Logistic Regression</a> (readthedocs.io)</li>
<li><a href="http://machinelearningmastery.com/simple-linear-regression-tutorial-for-machine-learning/" target="_blank" rel="external">Simple Linear Regression Tutorial for Machine Learning</a> (machinelearningmastery.com)</li>
<li><a href="http://machinelearningmastery.com/logistic-regression-tutorial-for-machine-learning/" target="_blank" rel="external">Logistic Regression Tutorial for Machine Learning</a> (machinelearningmastery.com)</li>
<li><a href="http://ufldl.stanford.edu/tutorial/supervised/SoftmaxRegression/" target="_blank" rel="external">Softmax Regression</a> (ufldl.stanford.edu)</li>
</ul>
<h4 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h4><ul>
<li><a href="http://neuralnetworksanddeeplearning.com/chap1.html#learning_with_gradient_descent" target="_blank" rel="external">Learning with gradient descent</a> (neuralnetworksanddeeplearning.com)</li>
<li><a href="http://iamtrask.github.io/2015/07/27/python-network-part2/" target="_blank" rel="external">Gradient Descent</a> (iamtrask.github.io)</li>
<li><a href="http://www.kdnuggets.com/2017/04/simple-understand-gradient-descent-algorithm.html" target="_blank" rel="external">How to understand Gradient Descent algorithm</a> (kdnuggets.com)</li>
<li><a href="http://sebastianruder.com/optimizing-gradient-descent/" target="_blank" rel="external">An overview of gradient descent optimization algorithms</a> (sebastianruder.com)</li>
<li><a href="http://cs231n.github.io/optimization-1/" target="_blank" rel="external">Optimization: Stochastic Gradient Descent</a> (Stanford CS231n)</li>
</ul>
<h4 id="生成学习"><a href="#生成学习" class="headerlink" title="生成学习"></a>生成学习</h4><ul>
<li><a href="http://cs229.stanford.edu/notes/cs229-notes2.pdf" target="_blank" rel="external">Generative Learning Algorithms</a> (Stanford CS229)</li>
<li><a href="https://monkeylearn.com/blog/practical-explanation-naive-bayes-classifier/" target="_blank" rel="external">A practical explanation of a Naive Bayes classifier</a> (monkeylearn.com)</li>
</ul>
<h4 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h4><ul>
<li><a href="https://monkeylearn.com/blog/introduction-to-support-vector-machines-svm/" target="_blank" rel="external">An introduction to Support Vector Machines (SVM)</a> (monkeylearn.com)</li>
<li><a href="http://cs229.stanford.edu/notes/cs229-notes3.pdf" target="_blank" rel="external">Support Vector Machines</a> (Stanford CS229)</li>
<li><a href="http://cs231n.github.io/linear-classify/" target="_blank" rel="external">Linear classification: Support Vector Machine, Softmax</a> (Stanford 231n)</li>
</ul>
<h4 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h4><ul>
<li><a href="https://medium.com/@karpathy/yes-you-should-understand-backprop-e2f06eab496b" target="_blank" rel="external">Yes you should understand backprop</a> (medium.com/@karpathy)</li>
<li><a href="https://github.com/rasbt/python-machine-learning-book/blob/master/faq/visual-backpropagation.md" target="_blank" rel="external">Can you give a visual explanation for the back propagation algorithm for neural networks?</a> (github.com/rasbt)</li>
<li><a href="http://neuralnetworksanddeeplearning.com/chap2.html" target="_blank" rel="external">How the backpropagation algorithm works</a> (neuralnetworksanddeeplearning.com)</li>
<li><a href="http://www.wildml.com/2015/10/recurrent-neural-networks-tutorial-part-3-backpropagation-through-time-and-vanishing-gradients/" target="_blank" rel="external">Backpropagation Through Time and Vanishing Gradients</a> (wildml.com)</li>
<li><a href="http://machinelearningmastery.com/gentle-introduction-backpropagation-time/" target="_blank" rel="external">A Gentle Introduction to Backpropagation Through Time</a> (machinelearningmastery.com)</li>
<li><a href="http://cs231n.github.io/optimization-2/" target="_blank" rel="external">Backpropagation, Intuitions</a> (Stanford CS231n)</li>
</ul>
<h4 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h4><ul>
<li><a href="http://nikhilbuduma.com/2014/12/29/deep-learning-in-a-nutshell/" target="_blank" rel="external">Deep Learning in a Nutshell</a> (nikhilbuduma.com)</li>
<li><a href="http://ai.stanford.edu/~quocle/tutorial1.pdf" target="_blank" rel="external">A Tutorial on Deep Learning</a> (Quoc V. Le)</li>
<li><a href="http://machinelearningmastery.com/what-is-deep-learning/" target="_blank" rel="external">What is Deep Learning?</a> (machinelearningmastery.com)</li>
<li><a href="https://blogs.nvidia.com/blog/2016/07/29/whats-difference-artificial-intelligence-machine-learning-deep-learning-ai/" target="_blank" rel="external">What’s the Difference Between Artificial Intelligence, Machine Learning, and Deep Learning?</a> (nvidia.com)</li>
</ul>
<h4 id="优化和降维"><a href="#优化和降维" class="headerlink" title="优化和降维"></a>优化和降维</h4><ul>
<li><a href="https://www.knime.org/blog/seven-techniques-for-data-dimensionality-reduction" target="_blank" rel="external">Seven Techniques for Data Dimensionality Reduction</a> (knime.org)</li>
<li><a href="http://cs229.stanford.edu/notes/cs229-notes10.pdf" target="_blank" rel="external">Principal components analysis</a> (Stanford CS229)</li>
<li><a href="http://videolectures.net/site/normal_dl/tag=741100/nips2012_hinton_networks_01.pdf" target="_blank" rel="external">Dropout: A simple way to improve neural networks</a> (Hinton @ NIPS 2012)</li>
<li><a href="http://rishy.github.io/ml/2017/01/05/how-to-train-your-dnn/" target="_blank" rel="external">How to train your Deep Neural Network</a> (rishy.github.io)</li>
</ul>
<h4 id="长短期记忆-LSTM"><a href="#长短期记忆-LSTM" class="headerlink" title="长短期记忆(LSTM)"></a>长短期记忆(LSTM)</h4><ul>
<li><a href="http://machinelearningmastery.com/gentle-introduction-long-short-term-memory-networks-experts/" target="_blank" rel="external">A Gentle Introduction to Long Short-Term Memory Networks by the Experts</a> (machinelearningmastery.com)</li>
<li><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="external">Understanding LSTM Networks</a> (colah.github.io)</li>
<li><a href="http://blog.echen.me/2017/05/30/exploring-lstms/" target="_blank" rel="external">Exploring LSTMs</a> (echen.me)</li>
<li><a href="http://iamtrask.github.io/2015/11/15/anyone-can-code-lstm/" target="_blank" rel="external">Anyone Can Learn To Code an LSTM-RNN in Python</a> (iamtrask.github.io)</li>
</ul>
<h4 id="卷积神经网络-CNNs"><a href="#卷积神经网络-CNNs" class="headerlink" title="卷积神经网络(CNNs)"></a>卷积神经网络(CNNs)</h4><ul>
<li><a href="http://neuralnetworksanddeeplearning.com/chap6.html#introducing_convolutional_networks" target="_blank" rel="external">Introducing convolutional networks</a> (neuralnetworksanddeeplearning.com)</li>
<li><a href="https://medium.com/@ageitgey/machine-learning-is-fun-part-3-deep-learning-and-convolutional-neural-networks-f40359318721" target="_blank" rel="external">Deep Learning and Convolutional Neural Networks</a> (medium.com/@ageitgey)</li>
<li><a href="http://colah.github.io/posts/2014-07-Conv-Nets-Modular/" target="_blank" rel="external">Conv Nets: A Modular Perspective</a> (colah.github.io)</li>
<li><a href="http://colah.github.io/posts/2014-07-Understanding-Convolutions/" target="_blank" rel="external">Understanding Convolutions</a> (colah.github.io)</li>
</ul>
<h4 id="循环神经网络-RNNs"><a href="#循环神经网络-RNNs" class="headerlink" title="循环神经网络(RNNs)"></a>循环神经网络(RNNs)</h4><p><a href="http://www.wildml.com/2015/09/recurrent-neural-networks-tutorial-part-1-introduction-to-rnns/" target="_blank" rel="external">Recurrent Neural Networks Tutorial</a> (wildml.com)<br><a href="http://distill.pub/2016/augmented-rnns/" target="_blank" rel="external">Attention and Augmented Recurrent Neural Networks</a> (distill.pub)<br><a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/" target="_blank" rel="external">The Unreasonable Effectiveness of Recurrent Neural Networks</a> (karpathy.github.io)<br><a href="http://nikhilbuduma.com/2015/01/11/a-deep-dive-into-recurrent-neural-networks/" target="_blank" rel="external">A Deep Dive into Recurrent Neural Nets</a> (nikhilbuduma.com)</p>
<h4 id="增强学习"><a href="#增强学习" class="headerlink" title="增强学习"></a>增强学习</h4><ul>
<li><a href="https://www.analyticsvidhya.com/blog/2017/01/introduction-to-reinforcement-learning-implementation/" target="_blank" rel="external">Simple Beginner’s guide to Reinforcement Learning &amp; its implementation</a> (analyticsvidhya.com)</li>
<li><a href="https://web.mst.edu/~gosavia/tutorial.pdf" target="_blank" rel="external">A Tutorial for Reinforcement Learning</a> (mst.edu)</li>
<li><a href="http://www.wildml.com/2016/10/learning-reinforcement-learning/" target="_blank" rel="external">Learning Reinforcement Learning</a> (wildml.com)</li>
<li><a href="http://karpathy.github.io/2016/05/31/rl/" target="_blank" rel="external">Deep Reinforcement Learning: Pong from Pixels</a> (karpathy.github.io)</li>
</ul>
<h4 id="生成对抗网络-GANs"><a href="#生成对抗网络-GANs" class="headerlink" title="生成对抗网络(GANs)"></a>生成对抗网络(GANs)</h4><ul>
<li><a href="https://blogs.nvidia.com/blog/2017/05/17/generative-adversarial-network/" target="_blank" rel="external">What’s a Generative Adversarial Network?</a> (nvidia.com)</li>
<li><a href="https://medium.com/@ageitgey/abusing-generative-adversarial-networks-to-make-8-bit-pixel-art-e45d9b96cee7" target="_blank" rel="external">Abusing Generative Adversarial Networks to Make 8-bit Pixel Art</a> (medium.com/@ageitgey)</li>
<li><a href="http://blog.aylien.com/introduction-generative-adversarial-networks-code-tensorflow/" target="_blank" rel="external">An introduction to Generative Adversarial Networks (with code in TensorFlow)</a> (aylien.com)</li>
<li><a href="https://www.oreilly.com/learning/generative-adversarial-networks-for-beginners" target="_blank" rel="external">Generative Adversarial Networks for Beginners</a> (oreilly.com)</li>
</ul>
<h4 id="多任务学习"><a href="#多任务学习" class="headerlink" title="多任务学习"></a>多任务学习</h4><ul>
<li><a href="http://sebastianruder.com/multi-task/index.html" target="_blank" rel="external">An Overview of Multi-Task Learning in Deep Neural Networks</a> (sebastianruder.com)</li>
</ul>
<h3 id="自然语言处理-NLP"><a href="#自然语言处理-NLP" class="headerlink" title="自然语言处理(NLP)"></a>自然语言处理(NLP)</h3><ul>
<li><a href="http://u.cs.biu.ac.il/~yogo/nnlp.pdf" target="_blank" rel="external">A Primer on Neural Network Models for Natural Language Processing</a> (Yoav Goldberg)</li>
<li><a href="https://monkeylearn.com/blog/the-definitive-guide-to-natural-language-processing/" target="_blank" rel="external">The Definitive Guide to Natural Language Processing</a> (monkeylearn.com)</li>
<li><a href="https://blog.algorithmia.com/introduction-natural-language-processing-nlp/" target="_blank" rel="external">Introduction to Natural Language Processing</a> (algorithmia.com)</li>
<li><a href="http://www.vikparuchuri.com/blog/natural-language-processing-tutorial/" target="_blank" rel="external">Natural Language Processing Tutorial</a> (vikparuchuri.com)</li>
<li><a href="https://arxiv.org/pdf/1103.0398.pdf" target="_blank" rel="external">Natural Language Processing (almost) from Scratch</a> (arxiv.org)</li>
</ul>
<h4 id="深度学习与NLP"><a href="#深度学习与NLP" class="headerlink" title="深度学习与NLP"></a>深度学习与NLP</h4><ul>
<li><a href="https://arxiv.org/pdf/1703.03091.pdf" target="_blank" rel="external">Deep Learning applied to NLP</a> (arxiv.org)</li>
<li><a href="https://nlp.stanford.edu/courses/NAACL2013/NAACL2013-Socher-Manning-DeepLearning.pdf" target="_blank" rel="external">Deep Learning for NLP (without Magic)</a> (Richard Socher)</li>
<li><a href="http://www.wildml.com/2015/11/understanding-convolutional-neural-networks-for-nlp/" target="_blank" rel="external">Understanding Convolutional Neural Networks for NLP</a> (wildml.com)</li>
<li><a href="http://colah.github.io/posts/2014-07-NLP-RNNs-Representations/" target="_blank" rel="external">Deep Learning, NLP, and Representations</a> (colah.github.io)</li>
<li><a href="https://explosion.ai/blog/deep-learning-formula-nlp" target="_blank" rel="external">Embed, encode, attend, predict: The new deep learning formula for state-of-the-art NLP models</a> (explosion.ai)</li>
<li><a href="https://devblogs.nvidia.com/parallelforall/understanding-natural-language-deep-neural-networks-using-torch/" target="_blank" rel="external">Understanding Natural Language with Deep Neural Networks Using Torch</a> (nvidia.com)</li>
<li><a href="http://pytorch.org/tutorials/beginner/deep_learning_nlp_tutorial.html" target="_blank" rel="external">Deep Learning for NLP with Pytorch</a> (pytorich.org)</li>
</ul>
<h4 id="词向量"><a href="#词向量" class="headerlink" title="词向量"></a>词向量</h4><ul>
<li><a href="https://www.kaggle.com/c/word2vec-nlp-tutorial" target="_blank" rel="external">Bag of Words Meets Bags of Popcorn</a> (kaggle.com)</li>
<li>On word embeddings <a href="http://sebastianruder.com/word-embeddings-1/index.html" target="_blank" rel="external">Part I</a>, <a href="http://sebastianruder.com/word-embeddings-softmax/index.html" target="_blank" rel="external">Part II</a>, <a href="http://sebastianruder.com/secret-word2vec/index.html" target="_blank" rel="external">Part III</a> (sebastianruder.com)</li>
<li><a href="https://blog.acolyer.org/2016/04/21/the-amazing-power-of-word-vectors/" target="_blank" rel="external">The amazing power of word vectors</a> (acolyer.org)</li>
<li><a href="https://arxiv.org/pdf/1411.2738.pdf" target="_blank" rel="external">word2vec Parameter Learning Explained</a> (arxiv.org)</li>
<li>Word2Vec Tutorial — <a href="http://mccormickml.com/2016/04/19/word2vec-tutorial-the-skip-gram-model/" target="_blank" rel="external">The Skip-Gram Model</a>, <a href="http://mccormickml.com/2017/01/11/word2vec-tutorial-part-2-negative-sampling/" target="_blank" rel="external">Negative Sampling</a> (mccormickml.com)</li>
</ul>
<h4 id="编码器-解码器"><a href="#编码器-解码器" class="headerlink" title="编码器-解码器"></a>编码器-解码器</h4><ul>
<li><a href="http://www.wildml.com/2016/01/attention-and-memory-in-deep-learning-and-nlp/" target="_blank" rel="external">Attention and Memory in Deep Learning and NLP</a> (wildml.com)</li>
<li><a href="https://www.tensorflow.org/tutorials/seq2seq" target="_blank" rel="external">Sequence to Sequence Models</a> (tensorflow.org)</li>
<li><a href="https://papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks.pdf" target="_blank" rel="external">Sequence to Sequence Learning with Neural Networks</a> (NIPS 2014)</li>
<li><a href="https://medium.com/@ageitgey/machine-learning-is-fun-part-5-language-translation-with-deep-learning-and-the-magic-of-sequences-2ace0acca0aa" target="_blank" rel="external">Machine Learning is Fun Part 5: Language Translation with Deep Learning and the Magic of Sequences</a> (medium.com/@ageitgey)</li>
<li><a href="http://machinelearningmastery.com/how-to-use-an-encoder-decoder-lstm-to-echo-sequences-of-random-integers/" target="_blank" rel="external">How to use an Encoder-Decoder LSTM to Echo Sequences of Random Integers</a> (machinelearningmastery.com)</li>
<li><a href="https://google.github.io/seq2seq/" target="_blank" rel="external">tf-seq2seq</a> (google.github.io)</li>
</ul>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><ul>
<li><a href="http://www.kdnuggets.com/2015/11/seven-steps-machine-learning-python.html" target="_blank" rel="external">7 Steps to Mastering Machine Learning With Python</a> (kdnuggets.com)</li>
<li><a href="http://nbviewer.jupyter.org/github/rhiever/Data-Analysis-and-Machine-Learning-Projects/blob/master/example-data-science-notebook/Example%20Machine%20Learning%20Notebook.ipynb" target="_blank" rel="external">An example machine learning notebook</a> (nbviewer.jupyter.org)</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul>
<li><a href="http://machinelearningmastery.com/implement-perceptron-algorithm-scratch-python/" target="_blank" rel="external">How To Implement The Perceptron Algorithm From Scratch In Python</a> (machinelearningmastery.com)</li>
<li><a href="http://www.wildml.com/2015/09/implementing-a-neural-network-from-scratch/" target="_blank" rel="external">Implementing a Neural Network from Scratch in Python</a> (wildml.com)</li>
<li><a href="http://iamtrask.github.io/2015/07/12/basic-python-network/" target="_blank" rel="external">A Neural Network in 11 lines of Python</a> (iamtrask.github.io)</li>
<li><a href="http://www.kdnuggets.com/2016/01/implementing-your-own-knn-using-python.html" target="_blank" rel="external">Implementing Your Own k-Nearest Neighbour Algorithm Using Python</a> (kdnuggets.com)</li>
<li><a href="http://machinelearningmastery.com/memory-in-a-long-short-term-memory-network/" target="_blank" rel="external">Demonstration of Memory with a Long Short-Term Memory Network in Python</a> (machinelearningmastery.com)</li>
<li><a href="http://machinelearningmastery.com/learn-echo-random-integers-long-short-term-memory-recurrent-neural-networks/" target="_blank" rel="external">How to Learn to Echo Random Integers with Long Short-Term Memory Recurrent Neural Networks</a> (machinelearningmastery.com)</li>
<li><a href="How to Learn to Add Numbers with seq2seq Recurrent Neural Networks">How to Learn to Add Numbers with seq2seq Recurrent Neural Networks</a> (machinelearningmastery.com)</li>
</ul>
<h4 id="Numpy和Scipy"><a href="#Numpy和Scipy" class="headerlink" title="Numpy和Scipy"></a>Numpy和Scipy</h4><ul>
<li><a href="http://www.scipy-lectures.org/" target="_blank" rel="external">Scipy Lecture Notes</a> (scipy-lectures.org)</li>
<li><a href="http://cs231n.github.io/python-numpy-tutorial/" target="_blank" rel="external">Python Numpy Tutorial</a> (Stanford CS231n)</li>
<li><a href="https://engineering.ucsb.edu/~shell/che210d/numpy.pdf" target="_blank" rel="external">An introduction to Numpy and Scipy</a> (UCSB CHE210D)</li>
<li><a href="http://nbviewer.jupyter.org/gist/rpmuller/5920182#ii.-numpy-and-scipy" target="_blank" rel="external">A Crash Course in Python for Scientists</a> (nbviewer.jupyter.org)</li>
</ul>
<h4 id="scikit-learn"><a href="#scikit-learn" class="headerlink" title="scikit-learn"></a>scikit-learn</h4><ul>
<li><a href="http://nbviewer.jupyter.org/github/jakevdp/sklearn_pycon2015/blob/master/notebooks/Index.ipynb" target="_blank" rel="external">PyCon scikit-learn Tutorial Index</a> (nbviewer.jupyter.org)</li>
<li><a href="https://github.com/mmmayo13/scikit-learn-classifiers/blob/master/sklearn-classifiers-tutorial.ipynb" target="_blank" rel="external">scikit-learn Classification Algorithms</a> (github.com/mmmayo13)</li>
<li><a href="http://scikit-learn.org/stable/tutorial/index.html" target="_blank" rel="external">scikit-learn Tutorials</a> (scikit-learn.org)</li>
<li><a href="https://github.com/mmmayo13/scikit-learn-beginners-tutorials" target="_blank" rel="external">Abridged scikit-learn Tutorials</a> (github.com/mmmayo13)</li>
</ul>
<h4 id="Tensorflow"><a href="#Tensorflow" class="headerlink" title="Tensorflow"></a>Tensorflow</h4><ul>
<li><a href="https://www.tensorflow.org/tutorials/" target="_blank" rel="external">Tensorflow Tutorials</a> (tensorflow.org)</li>
<li><a href="https://medium.com/@erikhallstrm/hello-world-tensorflow-649b15aed18c" target="_blank" rel="external">Introduction to TensorFlow — CPU vs GPU</a> (medium.com/@erikhallstrm)</li>
<li><a href="https://blog.metaflow.fr/tensorflow-a-primer-4b3fa0978be3" target="_blank" rel="external">TensorFlow: A primer</a> (metaflow.fr)</li>
<li><a href="http://www.wildml.com/2016/08/rnns-in-tensorflow-a-practical-guide-and-undocumented-features/" target="_blank" rel="external">RNNs in Tensorflow</a> (wildml.com)</li>
<li><a href="http://www.wildml.com/2015/12/implementing-a-cnn-for-text-classification-in-tensorflow/" target="_blank" rel="external">Implementing a CNN for Text Classification in TensorFlow</a> (wildml.com)</li>
<li><a href="http://pavel.surmenok.com/2016/10/15/how-to-run-text-summarization-with-tensorflow/" target="_blank" rel="external">How to Run Text Summarization with TensorFlow</a> (surmenok.com)</li>
</ul>
<h4 id="PyTorch"><a href="#PyTorch" class="headerlink" title="PyTorch"></a>PyTorch</h4><ul>
<li><a href="http://pytorch.org/tutorials/" target="_blank" rel="external">PyTorch Tutorials</a> (pytorch.org)</li>
<li><a href="http://blog.gaurav.im/2017/04/24/a-gentle-intro-to-pytorch/" target="_blank" rel="external">A Gentle Intro to PyTorch</a> (gaurav.im)</li>
<li><a href="https://iamtrask.github.io/2017/01/15/pytorch-tutorial/" target="_blank" rel="external">Tutorial: Deep Learning in PyTorch</a> (iamtrask.github.io)</li>
<li><a href="https://github.com/jcjohnson/pytorch-examples" target="_blank" rel="external">PyTorch Examples</a> (github.com/jcjohnson)</li>
<li><a href="https://github.com/MorvanZhou/PyTorch-Tutorial" target="_blank" rel="external">PyTorch Tutorial</a> (github.com/MorvanZhou)</li>
<li><a href="PyTorch Tutorial for Deep Learning Researchers">PyTorch Tutorial for Deep Learning Researchers</a> (github.com/yunjey)</li>
</ul>
<h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><ul>
<li><a href="https://people.ucsc.edu/~praman1/static/pub/math-for-ml.pdf" target="_blank" rel="external">Math for Machine Learning</a> (ucsc.edu)</li>
<li><a href="http://www.umiacs.umd.edu/~hal/courses/2013S_ML/math4ml.pdf" target="_blank" rel="external">Math for Machine Learning</a> (UMIACS CMSC422)</li>
</ul>
<h4 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h4><ul>
<li><a href="https://betterexplained.com/articles/linear-algebra-guide/" target="_blank" rel="external">An Intuitive Guide to Linear Algebra</a> (betterexplained.com)</li>
<li><a href="https://betterexplained.com/articles/matrix-multiplication/" target="_blank" rel="external">A Programmer’s Intuition for Matrix Multiplication</a> (betterexplained.com)</li>
<li><a href="https://betterexplained.com/articles/cross-product/" target="_blank" rel="external">Understanding the Cross Product</a> (betterexplained.com)</li>
<li><a href="https://betterexplained.com/articles/vector-calculus-understanding-the-dot-product/" target="_blank" rel="external">Understanding the Dot Product</a> (betterexplained.com)</li>
<li><a href="http://www.cedar.buffalo.edu/~srihari/CSE574/Chap1/LinearAlgebra.pdf" target="_blank" rel="external">Linear Algebra for Machine Learning</a> (U. of Buffalo CSE574)</li>
<li><a href="https://medium.com/towards-data-science/linear-algebra-cheat-sheet-for-deep-learning-cd67aba4526c" target="_blank" rel="external">Linear algebra cheat sheet for deep learning</a> (medium.com)</li>
<li><a href="http://cs229.stanford.edu/section/cs229-linalg.pdf" target="_blank" rel="external">Linear Algebra Review and Reference</a> (Stanford CS229)</li>
</ul>
<h4 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h4><ul>
<li><a href="https://betterexplained.com/articles/understanding-bayes-theorem-with-ratios/" target="_blank" rel="external">Understanding Bayes Theorem With Ratios</a> (betterexplained.com)</li>
<li><a href="http://cs229.stanford.edu/section/cs229-prob.pdf" target="_blank" rel="external">Review of Probability Theory</a> (Stanford CS229)</li>
<li><a href="https://see.stanford.edu/materials/aimlcs229/cs229-prob.pdf" target="_blank" rel="external">Probability Theory Review for Machine Learning</a> (Stanford CS229)</li>
<li><a href="http://www.cedar.buffalo.edu/~srihari/CSE574/Chap1/Probability-Theory.pdf" target="_blank" rel="external">Probability Theory</a> (U. of Buffalo CSE574)</li>
<li><a href="http://www.cs.toronto.edu/~urtasun/courses/CSC411_Fall16/tutorial1.pdf" target="_blank" rel="external">Probability Theory for Machine Learning</a> (U. of Toronto CSC411)</li>
</ul>
<h4 id="微积分"><a href="#微积分" class="headerlink" title="微积分"></a>微积分</h4><ul>
<li><a href="https://betterexplained.com/articles/how-to-understand-derivatives-the-quotient-rule-exponents-and-logarithms/" target="_blank" rel="external">How To Understand Derivatives: The Quotient Rule, Exponents, and Logarithms</a> (betterexplained.com)</li>
<li><a href="https://betterexplained.com/articles/derivatives-product-power-chain/" target="_blank" rel="external">How To Understand Derivatives: The Product, Power &amp; Chain Rules</a> (betterexplained.com)</li>
<li><a href="https://betterexplained.com/articles/vector-calculus-understanding-the-gradient/" target="_blank" rel="external">Vector Calculus: Understanding the Gradient</a> (betterexplained.com)</li>
<li><a href="http://web.stanford.edu/class/cs224n/lecture_notes/cs224n-2017-review-differential-calculus.pdf" target="_blank" rel="external">Differential Calculus</a> (Stanford CS224n)</li>
<li><a href="http://ml-cheatsheet.readthedocs.io/en/latest/calculus.html" target="_blank" rel="external">Calculus Overview</a> (readthedocs.io)</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 译文 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> MachineLearning </tag>
            
            <tag> NLP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[递归式求解-代入法]]></title>
      <url>http://pytlab.github.io/2017/08/11/%E9%80%92%E5%BD%92%E5%BC%8F%E6%B1%82%E8%A7%A3-%E4%BB%A3%E5%85%A5%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>放假没事继续看看算导，关于求解递归式一般使用三种方法：</p>
<ol>
<li>代入法</li>
<li>递归树方法</li>
<li>主方法</li>
</ol>
<p>本文主要总结一下在使用代入法求解递归式的方法以及需要注意的点和技巧。</p>
<a id="more"></a>
<p>代入式求解递归式一般分为两步：</p>
<ol>
<li>猜测解的形式</li>
<li>使用数学归纳法求解出解中的常数$c$的范围，并进行证明</li>
</ol>
<h3 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h3><h4 id="做出合适的猜测"><a href="#做出合适的猜测" class="headerlink" title="做出合适的猜测"></a>做出合适的猜测</h4><p>虽然并没有通用的方法来猜测递归式的正确解，但我们可以根据经验来猜测似曾相识的递归式的解作为我们的猜测。例如如下递归式<br>$$<br>T(n) = 2T(\lfloor n/2 \rfloor + 17) + n<br>$$<br>当$n$足够大时，$\lfloor n/2 \rfloor$和$\lfloor n/2 + 17 \rfloor$的差距并不大，因此我们可以猜测递归式的解为$T(n) = O(nlgn)$</p>
<p>另一种做出好猜测的方法就是先证明递归式较为<strong>宽松</strong>的上界($\Omega(n)$)和下界($O(n^{2})$)，然后缩小范围最终收敛到渐进紧确界($O(nlgn)$)。</p>
<h4 id="减去低阶项"><a href="#减去低阶项" class="headerlink" title="减去低阶项"></a>减去低阶项</h4><p>有时及时猜测出了递归式解的渐进界，但是归纳证明的时候会失败，这常常是因为归纳假设不够强，无法证明出准确的界。这是可以通过在之前的猜测的基础上<strong>减去一个低阶的项</strong>，归纳证明往往能顺利进行。</p>
<p>例如如下递归式：<br>$$<br>T(n) = T(\lfloor n/2 \rfloor) + T(\lceil n/2 \rceil) + 1<br>$$</p>
<p>从递归式中我们可以看到问题的划分成两个子问题，但是子问题的规模也是原问题的1/2，因此可以猜测此递归式的渐进解为$O(n)$, 即$T(n) \le cn$</p>
<p>归纳证明:<br>$$<br>T(n) \le c\lfloor n/2 \rfloor + c\lceil n/2 \rceil + 1 = cn + 1<br>$$</p>
<p>显然无法归纳证明，这时候我们可以将猜测的解减去一个低阶项，$T(n) \le cn - d$, 这样便有<br>$$<br>T(n) \le (c\lfloor n/2 \rfloor - d) + (c\lceil n/2 \rceil -d) + 1 = cn - 2d + 1<br>$$</p>
<p>当$d \ge 1$时，便有 $T(n) \le cn - d$.</p>
<h4 id="要显式的证明不等式"><a href="#要显式的证明不等式" class="headerlink" title="要显式的证明不等式"></a>要显式的证明不等式</h4><p>这一点其实需要对渐进符号有个正确的理解，渐进符号本身便是一种满足不等式条件的函数集合，因此我们在求解递归式的时候，不能直接证明$T(n) = O(n)$, 因为这样我们并没有证明出以归纳假设<strong>严格一致</strong>的形式。例如：</p>
<p>$$<br>T(n) \le 2(c\lfloor n/2 \rfloor) + n \le cn + n = O(n)<br>$$</p>
<p>这样是错误的，我们必须要显式的的证明$T(n) \le cn$ 才行！</p>
<h4 id="改变变量"><a href="#改变变量" class="headerlink" title="改变变量"></a>改变变量</h4><p>有时候递归关系式看起来比较复杂，但是经过变量替换便可以讲一个未知的递归式变成熟悉的形式。例如：</p>
<p>$$<br>T(n) = 2T(\lfloor \sqrt{n} \rfloor) + lgn<br>$$</p>
<p>我们令$m = lgn$ 则 $\sqrt{n} = 2^{m/2}$</p>
<p>$$<br>T(2^{m}) = 2T(2^{m/2}) + m<br>$$</p>
<p>使$S(m) = T(2^{m})$, 得到</p>
<p>$$<br>S(m) = 2S(m/2) + m<br>$$</p>
<p>这样，此递归式的形式我们在熟悉不过了，我们便可以得到$S(m) = O(mlgm) = T(2^{m})$</p>
<p>令$m = lgn$代入，得到</p>
<p>$$<br>T(n) = O((lgn)(lglgn))<br>$$</p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><blockquote>
<p>证明: $T(n) = T(\lceil n/2 \rceil) + 1$ 的解为 $O(lgn)$</p>
</blockquote>
<p>根据递归关系式有:<br>$$<br>T(n) \le clg(\lceil n/2 \rceil) + 1 \le clgn + 1<br>$$<br>显然无法证明，这时我们尝试让解减去一个低阶项$d$, 即$clgn - d$</p>
<p>$$<br>T(n) \le clg(\lceil n/2 \rceil) - d + 1 \le clg(n) - d + 1<br>$$</p>
<p>取$d \ge 1$ 则有</p>
<p>$$<br>T(n) \le clgn<br>$$</p>
<p>然后是边界条件，我们这里假设$T(1) = 1$则有$T(1) \le clg1 - 1 = -1 \ne 1$ 矛盾。</p>
<p>由于渐进符号仅要求我们的$n \ge n_{0}$就可以，因此我们可以尝试下$T(2) = 2$, 这样则有, 当$c \ge 3$<br>$$<br>T(2) = 2 \le clg2 - 1 = c - 1<br>$$</p>
<p>因此完成归纳证明：对于$c \ge 3$， $n \ge 2$ 有 $T(n) \le clgn - 1$, 即$T(n) = O(lgn)$</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用MPI并行化遗传算法框架GAFT]]></title>
      <url>http://pytlab.github.io/2017/08/02/%E4%BD%BF%E7%94%A8MPI%E5%B9%B6%E8%A1%8C%E5%8C%96%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文中作者使用MPI的Python接口mpi4py来将自己的遗传算法框架GAFT进行多进程并行加速。并对加速效果进行了简单测试。</p>
<p>项目链接:</p>
<ul>
<li>GitHub: <a href="https://github.com/PytLab/gaft" target="_blank" rel="external">https://github.com/PytLab/gaft</a></li>
<li>PyPI: <a href="https://pypi.python.org/pypi/gaft" target="_blank" rel="external">https://pypi.python.org/pypi/gaft</a></li>
</ul>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>我们在用遗传算法优化目标函数的时候，函数通常都是高维函数，其导数一般比较难求取。这样我们的适应度函数计算通常都是比较费时的计算。</p>
<p>例如在使用遗传算法寻找最优结构时候通常需要调用量化软件进行第一性原理计算结构的total energy，这是非常费时的过程; 例如我们优化力场参数的时候，以力场计算出的能量同基准能量之前的误差作为适应度，也需要调用相应的力场程序获取总能量来求取，同样这个过程也是相对耗时的。</p>
<a id="more"></a>
<p>这就会导致一个问题，当我们的<strong>种群比较大</strong>的时候，我们需要利用适应度信息来产生下一代种群，这时候每一代繁殖的过程将会很耗时。但有幸的是，种群的选择交叉变异过程对于种群中的个体都是<strong>相互独立</strong>的过程，我们可以将这一部分进行并行处理来加速遗传算法的迭代。</p>
<h3 id="使用mpi4py"><a href="#使用mpi4py" class="headerlink" title="使用mpi4py"></a>使用mpi4py</h3><p>由于实验室的集群都是MPI环境，我还是选择使用MPI接口来将代码并行化，这里我还是用了MPI接口的Python版本mpi4py来将代码并行化。关于mpi4py的使用，我之前写过一篇博客专门做了介绍，可以参见<a href="http://pytlab.org/2017/02/19/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5-mpi4py%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">《Python多进程并行编程实践-mpi4py的使用》</a></p>
<h3 id="将mpi4py的接口进一步封装"><a href="#将mpi4py的接口进一步封装" class="headerlink" title="将mpi4py的接口进一步封装"></a>将mpi4py的接口进一步封装</h3><p>为了能让mpi的接口在GAFT中更方便的调用，我决定将mpi4py针对遗传算法中需要用的地方进行进一步封装，为此我单独写了个<code>MPIUtil</code>类, 详细代码参见<a href="https://github.com/PytLab/gaft/blob/master/gaft/mpiutil.py" target="_blank" rel="external">gaft/mpiutil.py</a>。</p>
<h4 id="封装通信子常用的接口"><a href="#封装通信子常用的接口" class="headerlink" title="封装通信子常用的接口"></a>封装通信子常用的接口</h4><p>例如进程同步, 获取rank，进程数，判断是否为主进程等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MPIUtil</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        logger_name = <span class="string">'gaft.&#123;&#125;'</span>.format(self.__class__.__name__)</div><div class="line">        self._logger = logging.getLogger(logger_name)</div><div class="line"></div><div class="line">    <span class="comment"># Wrapper for common MPI interfaces.</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">barrier</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> MPI_INSTALLED:</div><div class="line">            mpi_comm = MPI.COMM_WORLD</div><div class="line">            mpi_comm.barrier()</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rank</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> MPI_INSTALLED:</div><div class="line">            mpi_comm = MPI.COMM_WORLD</div><div class="line">            <span class="keyword">return</span> mpi_comm.Get_rank()</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> MPI_INSTALLED:</div><div class="line">            mpi_comm = MPI.COMM_WORLD</div><div class="line">            <span class="keyword">return</span> mpi_comm.Get_size()</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span></div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_master</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.rank == <span class="number">0</span></div></pre></td></tr></table></figure>
<h4 id="组内集合通信接口"><a href="#组内集合通信接口" class="headerlink" title="组内集合通信接口"></a>组内集合通信接口</h4><p>由于本次并行化的任务是在种群繁衍时候进行的，因此我需要将上一代种群进行划分，划分成多个子部分，然后在每个进程中对划分好的子部分进行选择交叉变异等遗传操作。在最后将每个字部分得到的子种群进行收集合并。为此写了几个划分和收集的接口:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_seq</span><span class="params">(self, sequence)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    Split the sequence according to rank and processor number.</div><div class="line">    '''</div><div class="line">    starts = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(sequence), len(sequence)//self.size)]</div><div class="line">    ends = starts[<span class="number">1</span>: ] + [len(sequence)]</div><div class="line">    start, end = list(zip(starts, ends))[self.rank]</div><div class="line"></div><div class="line">    <span class="keyword">return</span> sequence[start: end]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_size</span><span class="params">(self, size)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    Split a size number(int) to sub-size number.</div><div class="line">    '''</div><div class="line">    <span class="keyword">if</span> size &lt; self.size:</div><div class="line">        warn_msg = (<span class="string">'Splitting size(&#123;&#125;) is smaller than process '</span> +</div><div class="line">                    <span class="string">'number(&#123;&#125;), more processor would be '</span> +</div><div class="line">                    <span class="string">'superflous'</span>).format(size, self.size)</div><div class="line">        self._logger.warning(warn_msg)</div><div class="line">        splited_sizes = [<span class="number">1</span>]*size + [<span class="number">0</span>]*(self.size - size)</div><div class="line">    <span class="keyword">elif</span> size % self.size != <span class="number">0</span>:</div><div class="line">        residual = size % self.size</div><div class="line">        splited_sizes = [size // self.size]*self.size</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(residual):</div><div class="line">            splited_sizes[i] += <span class="number">1</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        splited_sizes = [size // self.size]*self.size</div><div class="line"></div><div class="line">    <span class="keyword">return</span> splited_sizes[self.rank]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_seq</span><span class="params">(self, seq)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    Gather data in sub-process to root process.</div><div class="line">    '''</div><div class="line">    <span class="keyword">if</span> self.size == <span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> seq</div><div class="line"></div><div class="line">    mpi_comm = MPI.COMM_WORLD</div><div class="line">    merged_seq= mpi_comm.allgather(seq)</div><div class="line">    <span class="keyword">return</span> list(chain(*merged_seq))</div></pre></td></tr></table></figure>
<h4 id="用于限制程序在主进程执行的装饰器"><a href="#用于限制程序在主进程执行的装饰器" class="headerlink" title="用于限制程序在主进程执行的装饰器"></a>用于限制程序在主进程执行的装饰器</h4><p>有些函数例如日志输出，数据收集的函数，我只希望在主进程执行，为了方便，写了个装饰器来限制函数在主进程中执行:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">master_only</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    Decorator to limit a function to be called</div><div class="line">    only in master process in MPI env.</div><div class="line">    '''</div><div class="line"><span class="meta">    @wraps(func)</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_call_in_master_proc</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">        <span class="keyword">if</span> mpi.is_master:</div><div class="line">            <span class="keyword">return</span> func(*args, **kwargs)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> _call_in_master_proc</div></pre></td></tr></table></figure>
<h3 id="在遗传算法主循环中添加并行"><a href="#在遗传算法主循环中添加并行" class="headerlink" title="在遗传算法主循环中添加并行"></a>在遗传算法主循环中添加并行</h3><p>主要在种群繁衍中对种群针对进程数进行划分然后并行进行遗传操作并合并子种群完成并行，代码改动很少。详见:<a href="https://github.com/PytLab/gaft/blob/master/gaft/engine.py#L67" target="_blank" rel="external">https://github.com/PytLab/gaft/blob/master/gaft/engine.py#L67</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Enter evolution iteration.</span></div><div class="line"><span class="keyword">for</span> g <span class="keyword">in</span> range(ng):</div><div class="line">    <span class="comment"># Scatter jobs to all processes.</span></div><div class="line">    local_indvs = []</div><div class="line">    local_size = mpi.split_size(self.population.size // <span class="number">2</span>)</div><div class="line"></div><div class="line">    <span class="comment"># Fill the new population.</span></div><div class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(local_size):</div><div class="line">        <span class="comment"># Select father and mother.</span></div><div class="line">        parents = self.selection.select(self.population, fitness=self.fitness)</div><div class="line">        <span class="comment"># Crossover.</span></div><div class="line">        children = self.crossover.cross(*parents)</div><div class="line">        <span class="comment"># Mutation.</span></div><div class="line">        children = [self.mutation.mutate(child) <span class="keyword">for</span> child <span class="keyword">in</span> children]</div><div class="line">        <span class="comment"># Collect children.</span></div><div class="line">        local_indvs.extend(children)</div><div class="line"></div><div class="line">    <span class="comment"># Gather individuals from all processes.</span></div><div class="line">    indvs = mpi.merge_seq(local_indvs)</div><div class="line">    <span class="comment"># The next generation.</span></div><div class="line">    self.population.individuals = indvs</div></pre></td></tr></table></figure>
<h3 id="测试加速效果"><a href="#测试加速效果" class="headerlink" title="测试加速效果"></a>测试加速效果</h3><h4 id="测试一维搜索"><a href="#测试一维搜索" class="headerlink" title="测试一维搜索"></a>测试一维搜索</h4><p>下面我针对项目中的一维优化的例子进行并行加速测试来看看加速的效果。例子代码在<a href="https://github.com/PytLab/gaft/tree/master/examples/ex01" target="_blank" rel="external">/examples/ex01/</a></p>
<p>由于自己本子核心数量有限，我把gaft安装在实验室集群上使用MPI利用多核心进行并行计算以为优化，种群大小为50，代数为100，针对不同核心数可以得到不同的优化时间和加速比。可视化如下图:</p>
<table>
<thead>
<tr>
<th style="text-align:left">核心数</th>
<th style="text-align:left">优化时间(s)</th>
<th style="text-align:left">加速比</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1.473</td>
<td style="text-align:left">1.0</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">0.877</td>
<td style="text-align:left">1.68</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">0.657</td>
<td style="text-align:left">2.24</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">0.533</td>
<td style="text-align:left">2.76</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">0.467</td>
<td style="text-align:left">3.15</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">0.540</td>
<td style="text-align:left">2.73</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">0.431</td>
<td style="text-align:left">3.42</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">0.382</td>
<td style="text-align:left">3.86</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">0.355</td>
<td style="text-align:left">4.15</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">0.317</td>
<td style="text-align:left">4.65</td>
</tr>
</tbody>
</table>
<p>核心数与优化时间的关系:</p>
<p><img src="/assets/images/blog_img/2017-08-02-使用MPI并行化遗传算法/n_vs_time_1d.png" alt=""></p>
<p>核心数与加速比:</p>
<p><img src="/assets/images/blog_img/2017-08-02-使用MPI并行化遗传算法/n_vs_speedup_1d.png" alt=""></p>
<h4 id="测试力场优化"><a href="#测试力场优化" class="headerlink" title="测试力场优化"></a>测试力场优化</h4><p>这里我对自己要研究的对象进行加速测试，这部分代码并未开源，针对每个个体的适应度计算都需要调用其他的计算程序，因此此过程相比直接有函数表达式的目标函数计算要耗时很多。</p>
<p>同样，我针对不同核心数看看使用MPI在集群上加速的效果:</p>
<table>
<thead>
<tr>
<th style="text-align:left">核心数</th>
<th style="text-align:left">优化时间(s)</th>
<th style="text-align:left">优化时间</th>
<th style="text-align:left">加速比</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">2.29e04</td>
<td style="text-align:left">6 h 21 min</td>
<td style="text-align:left">1.0</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">1.94e04</td>
<td style="text-align:left">5 h 23 min</td>
<td style="text-align:left">1.18</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">1.62e04</td>
<td style="text-align:left">4 h 30 min</td>
<td style="text-align:left">1.41</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">1.35e04</td>
<td style="text-align:left">3 h 45 min</td>
<td style="text-align:left">1.69</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left">8.73e03</td>
<td style="text-align:left">2 h 25 min</td>
<td style="text-align:left">2.62</td>
</tr>
</tbody>
</table>
<p>核心数与优化时间的关系:</p>
<p><img src="/assets/images/blog_img/2017-08-02-使用MPI并行化遗传算法/n_vs_time.png" alt=""></p>
<p>核心数与加速比:</p>
<p><img src="/assets/images/blog_img/2017-08-02-使用MPI并行化遗传算法/n_vs_speedup.png" alt=""></p>
<p>可见针对上述两个案例，MPI对遗传算法的加速还是比较理想的，程序可以扔到集群上飞起啦~~~</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要总结了使用mpi4py对遗传算法进行并行化的方法和过程，并对加速效果进行了测试，可见MPI对于遗传算法框架GAFT的加速效果还是较为理想的。带有MPI并行的遗传算法框架目前也已更新并上传至GitHub(<a href="https://github.com/PytLab/gaft" target="_blank" rel="external">https://github.com/PytLab/gaft</a>) 欢迎围观[]~(￣▽￣)~*</p>
]]></content>
      
        <categories>
            
            <category> 代码作品 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> MPI </tag>
            
            <tag> Parallel Computing </tag>
            
            <tag> mpi4py </tag>
            
            <tag> GeneticAlgorithm </tag>
            
            <tag> gaft </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[与机器学习, Python, 数学相关的速查表整理]]></title>
      <url>http://pytlab.github.io/2017/07/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-Python-%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3%E7%9A%84%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本文翻译自<a href="https://unsupervisedmethods.com/cheat-sheet-of-machine-learning-and-python-and-math-cheat-sheets-a4afe4e791b6" target="_blank" rel="external">Cheat Sheet of Machine Learning and Python (and Math) Cheat Sheets</a>，首发于<a href="http://blog.jobbole.com/112009/" target="_blank" rel="external">伯乐在线</a>, 未经许可禁止转载。</p>
</blockquote>
<p>机器学习涉及到的方面非常多。当我开始准备复习这些内容的时候，我找到了许多不同的”速查表”, 这些速查表针对某一主题都罗列出了所有我需要知道的知识重点。最终我编译了超过20份机器学习相关的速查表，其中一些是我经常用到的而且我相信其他人也会从中受益。本文整理了了27个我在网络上找到的我认为比较好的速查表。如果我有遗漏欢迎补充。</p>
<a id="more"></a>
<p>如今机器学习领域的发展相当迅速，我可以想象出来这些资源将会很快过时，但是至少在当前，在2017年6月1日，他们都是相当流行的。</p>
<p>如果你们像我一样想要一次性批量下载所有资源，我已经将<a href="https://www.dropbox.com/s/v3yg8djhdf24g6v/UnsupervisedMethods.com%20-%20Cheat%20Sheets.zip?dl=0" target="_blank" rel="external">27个速查表整理打包</a>好了，请尽情享用吧！</p>
<p>如果你喜欢本文，记得给我在下面点个赞哦。</p>
<h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>这里我从一些和机器学习算法相关的流程图和表格中选择了我认为最全面的几个并在下面罗列出来。</p>
<h4 id="Neural-Network-Architectures"><a href="#Neural-Network-Architectures" class="headerlink" title="Neural Network Architectures"></a>Neural Network Architectures</h4><p>链接: <a href="http://www.asimovinstitute.org/neural-network-zoo/" target="_blank" rel="external">http://www.asimovinstitute.org/neural-network-zoo/</a></p>
<p><img src="/assets/images/blog_img/2017-07-25-机器学习-Python-数学相关的速查表/NN.png" alt=""><br>The Neural Network Zoo</p>
<h4 id="Microsoft-Azure-Algorithm-Flowchart"><a href="#Microsoft-Azure-Algorithm-Flowchart" class="headerlink" title="Microsoft Azure Algorithm Flowchart"></a>Microsoft Azure Algorithm Flowchart</h4><p>链接: <a href="https://docs.microsoft.com/en-us/azure/machine-learning/machine-learning-algorithm-cheat-sheet" target="_blank" rel="external">https://docs.microsoft.com/en-us/azure/machine-learning/machine-learning-algorithm-cheat-sheet</a></p>
<p><img src="/assets/images/blog_img/2017-07-25-机器学习-Python-数学相关的速查表/MS.png" alt=""><br>Machine learning algorithm cheat sheet for Microsoft Azure Machine Learning Studio</p>
<h4 id="SAS-Algorithm-Flowchart"><a href="#SAS-Algorithm-Flowchart" class="headerlink" title="SAS Algorithm Flowchart"></a>SAS Algorithm Flowchart</h4><p>链接: <a href="http://blogs.sas.com/content/subconsciousmusings/2017/04/12/machine-learning-algorithm-use/" target="_blank" rel="external">http://blogs.sas.com/content/subconsciousmusings/2017/04/12/machine-learning-algorithm-use/</a></p>
<p><img src="/assets/images/blog_img/2017-07-25-机器学习-Python-数学相关的速查表/SAS.png" alt=""><br>SAS: Which machine learning algorithm should I use?</p>
<h4 id="Algorithm-Summary"><a href="#Algorithm-Summary" class="headerlink" title="Algorithm Summary"></a>Algorithm Summary</h4><p>链接: <a href="http://machinelearningmastery.com/a-tour-of-machine-learning-algorithms/" target="_blank" rel="external">http://machinelearningmastery.com/a-tour-of-machine-learning-algorithms/</a></p>
<p><img src="/assets/images/blog_img/2017-07-25-机器学习-Python-数学相关的速查表/AS.png" alt=""><br>A Tour of Machine Learning Algorithms</p>
<p><img src="/assets/images/blog_img/2017-07-25-机器学习-Python-数学相关的速查表/best.jpeg" alt=""><br>Which are the best known machine learning algorithms?</p>
<h4 id="Algorithm-Pro-Con"><a href="#Algorithm-Pro-Con" class="headerlink" title="Algorithm Pro/Con"></a>Algorithm Pro/Con</h4><p>链接: <a href="https://blog.dataiku.com/machine-learning-explained-algorithms-are-your-friend" target="_blank" rel="external">https://blog.dataiku.com/machine-learning-explained-algorithms-are-your-friend</a></p>
<p><img src="/assets/images/blog_img/2017-07-25-机器学习-Python-数学相关的速查表/CON.jpeg" alt=""></p>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>网上在线的Python资源可以说是相当的多。在这一部分，我挑选了我遇到的几个最好的速查表呈献给大家。</p>
<h4 id="ML算法"><a href="#ML算法" class="headerlink" title="ML算法"></a>ML算法</h4><p>链接: <a href="https://www.analyticsvidhya.com/blog/2015/09/full-cheatsheet-machine-learning-algorithms/" target="_blank" rel="external">https://www.analyticsvidhya.com/blog/2015/09/full-cheatsheet-machine-learning-algorithms/</a></p>
<p><img src="/assets/images/blog_img/2017-07-25-机器学习-Python-数学相关的速查表/PYALGO.png" alt=""></p>
<h4 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h4><p>链接: <a href="http://datasciencefree.com/python.pdf" target="_blank" rel="external">http://datasciencefree.com/python.pdf</a></p>
<p><img src="/assets/images/blog_img/2017-07-25-机器学习-Python-数学相关的速查表/PYBASIC.png" alt=""></p>
<p>链接: <a href="https://www.datacamp.com/community/tutorials/python-data-science-cheat-sheet-basics#gs.0x1rxEA" target="_blank" rel="external">https://www.datacamp.com/community/tutorials/python-data-science-cheat-sheet-basics#gs.0x1rxEA</a></p>
<p><img src="/assets/images/blog_img/2017-07-25-机器学习-Python-数学相关的速查表/PYBASIC2.png" alt=""></p>
<h4 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h4><p>链接: <a href="https://www.dataquest.io/blog/numpy-cheat-sheet/" target="_blank" rel="external">https://www.dataquest.io/blog/numpy-cheat-sheet/</a></p>
<p><img src="/assets/images/blog_img/2017-07-25-机器学习-Python-数学相关的速查表/NUMPY.png" alt=""></p>
<p>链接: <a href="http://datasciencefree.com/numpy.pdf" target="_blank" rel="external">http://datasciencefree.com/numpy.pdf</a></p>
<p><img src="/assets/images/blog_img/2017-07-25-机器学习-Python-数学相关的速查表/numpy-pdf.png" alt=""></p>
<p>链接: <a href="https://www.datacamp.com/community/blog/python-numpy-cheat-sheet#gs.Nw3V6CE" target="_blank" rel="external">https://www.datacamp.com/community/blog/python-numpy-cheat-sheet#gs.Nw3V6CE</a></p>
<p><img src="/assets/images/blog_img/2017-07-25-机器学习-Python-数学相关的速查表/numpy3.png" alt=""></p>
<p>链接: <a href="https://github.com/donnemartin/data-science-ipython-notebooks/blob/master/numpy/numpy.ipynb" target="_blank" rel="external">https://github.com/donnemartin/data-science-ipython-notebooks/blob/master/numpy/numpy.ipynb</a></p>
<p><img src="/assets/images/blog_img/2017-07-25-机器学习-Python-数学相关的速查表/numpy4.png" alt=""></p>
<h4 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h4><p>链接: <a href="http://datasciencefree.com/pandas.pdf" target="_blank" rel="external">http://datasciencefree.com/pandas.pdf</a></p>
<p><img src="/assets/images/blog_img/2017-07-25-机器学习-Python-数学相关的速查表/pandas.png" alt=""></p>
<p>链接: <a href="https://www.datacamp.com/community/blog/python-pandas-cheat-sheet#gs.S4P4T=U" target="_blank" rel="external">https://www.datacamp.com/community/blog/python-pandas-cheat-sheet#gs.S4P4T=U</a></p>
<p><img src="/assets/images/blog_img/2017-07-25-机器学习-Python-数学相关的速查表/pandas2.png" alt=""></p>
<p>链接: <a href="https://github.com/donnemartin/data-science-ipython-notebooks/blob/master/pandas/pandas.ipynb" target="_blank" rel="external">https://github.com/donnemartin/data-science-ipython-notebooks/blob/master/pandas/pandas.ipynb</a></p>
<p><img src="/assets/images/blog_img/2017-07-25-机器学习-Python-数学相关的速查表/pandas3.png" alt=""></p>
<h4 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h4><p>链接: <a href="https://www.datacamp.com/community/blog/python-matplotlib-cheat-sheet" target="_blank" rel="external">https://www.datacamp.com/community/blog/python-matplotlib-cheat-sheet</a></p>
<p><img src="/assets/images/blog_img/2017-07-25-机器学习-Python-数学相关的速查表/matplotlib.png" alt=""></p>
<p>链接: <a href="https://github.com/donnemartin/data-science-ipython-notebooks/blob/master/matplotlib/matplotlib.ipynb" target="_blank" rel="external">https://github.com/donnemartin/data-science-ipython-notebooks/blob/master/matplotlib/matplotlib.ipynb</a></p>
<p><img src="/assets/images/blog_img/2017-07-25-机器学习-Python-数学相关的速查表/matplotlib2.png" alt=""></p>
<h4 id="Scikit-Learn"><a href="#Scikit-Learn" class="headerlink" title="Scikit Learn"></a>Scikit Learn</h4><p>链接: <a href="https://www.datacamp.com/community/blog/scikit-learn-cheat-sheet#gs.fZ2A1Jk" target="_blank" rel="external">https://www.datacamp.com/community/blog/scikit-learn-cheat-sheet#gs.fZ2A1Jk</a></p>
<p><img src="/assets/images/blog_img/2017-07-25-机器学习-Python-数学相关的速查表/skl.png" alt=""></p>
<p>链接: <a href="http://peekaboo-vision.blogspot.de/2013/01/machine-learning-cheat-sheet-for-scikit.html" target="_blank" rel="external">http://peekaboo-vision.blogspot.de/2013/01/machine-learning-cheat-sheet-for-scikit.html</a></p>
<p><img src="/assets/images/blog_img/2017-07-25-机器学习-Python-数学相关的速查表/skl2.png" alt=""></p>
<p>链接: <a href="https://github.com/rcompton/ml_cheat_sheet/blob/master/supervised_learning.ipynb" target="_blank" rel="external">https://github.com/rcompton/ml_cheat_sheet/blob/master/supervised_learning.ipynb</a></p>
<p><img src="/assets/images/blog_img/2017-07-25-机器学习-Python-数学相关的速查表/skl3.png" alt=""></p>
<h4 id="Tensorflow"><a href="#Tensorflow" class="headerlink" title="Tensorflow"></a>Tensorflow</h4><p>链接: <a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/1_Introduction/basic_operations.ipynb" target="_blank" rel="external">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/1_Introduction/basic_operations.ipynb</a></p>
<p><img src="/assets/images/blog_img/2017-07-25-机器学习-Python-数学相关的速查表/tf.png" alt=""></p>
<h4 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a>Pytorch</h4><p>链接: <a href="https://github.com/bfortuner/pytorch-cheatsheet" target="_blank" rel="external">https://github.com/bfortuner/pytorch-cheatsheet</a></p>
<p><img src="/assets/images/blog_img/2017-07-25-机器学习-Python-数学相关的速查表/torch.png" alt=""></p>
<h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><p>如果你想真正的理解机器学习，你需要有扎实的统计学(尤其是概率论), 线性代数以及微积分基础。我在上大学的时候辅修了数学专业，但是我肯定还是需要对这些数学知识进行复习。如果你想理解常用机器学习算法背后的数学原理，那么下面的这些速查表将会是你需要的。</p>
<h4 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h4><p>链接: <a href="http://www.wzchen.com/s/probability_cheatsheet.pdf" target="_blank" rel="external">http://www.wzchen.com/s/probability_cheatsheet.pdf</a></p>
<p><img src="/assets/images/blog_img/2017-07-25-机器学习-Python-数学相关的速查表/prob.png" alt=""></p>
<h4 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h4><p>链接: <a href="https://minireference.com/static/tutorials/linear_algebra_in_4_pages.pdf" target="_blank" rel="external">https://minireference.com/static/tutorials/linear_algebra_in_4_pages.pdf</a></p>
<p><img src="/assets/images/blog_img/2017-07-25-机器学习-Python-数学相关的速查表/la.png" alt=""></p>
<h4 id="统计学"><a href="#统计学" class="headerlink" title="统计学"></a>统计学</h4><p>链接: <a href="http://web.mit.edu/~csvoss/Public/usabo/stats_handout.pdf" target="_blank" rel="external">http://web.mit.edu/~csvoss/Public/usabo/stats_handout.pdf</a></p>
<p><img src="/assets/images/blog_img/2017-07-25-机器学习-Python-数学相关的速查表/stat.png" alt=""></p>
<h4 id="微积分"><a href="#微积分" class="headerlink" title="微积分"></a>微积分</h4><p>链接: <a href="http://tutorial.math.lamar.edu/getfile.aspx?file=B,41,N" target="_blank" rel="external">http://tutorial.math.lamar.edu/getfile.aspx?file=B,41,N</a></p>
<p><img src="/assets/images/blog_img/2017-07-25-机器学习-Python-数学相关的速查表/calculus.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 译文 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> MachineLearning </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GAFT-一个使用Python实现的遗传算法框架]]></title>
      <url>http://pytlab.github.io/2017/07/23/gaft-%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8EPython%E7%9A%84%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近需要用到遗传算法来优化一些东西，最初是打算直接基于某些算法实现一个简单的函数来优化，但是感觉单纯写个非通用的函数运行后期改进算子或者别人使用起来都会带来困难，同时遗传算法基本概念和运行流程相对固定，改进也一般通过编码机制，选择策略，交叉变异算子以及参数设计等方面，对于算法的整体结构并没有大的影响。这样对于遗传算法来说，就非常适合写个相对固定的框架然后给算子、参数等留出空间以便对新算法进行测试和改进。于是就动手写了个遗传算法的小框架gaft，本文对此框架进行一些介绍并分别以一个一维搜索和二维搜索为例子对使用方法进行了介绍。</p>
<a id="more"></a>
<p>GitHub: <a href="https://github.com/PytLab/gaft" target="_blank" rel="external">https://github.com/PytLab/gaft</a><br>PyPI: <a href="https://pypi.python.org/pypi/gaft" target="_blank" rel="external">https://pypi.python.org/pypi/gaft</a></p>
<p>目前框架只是完成了最初的版本，比较简陋，内置了几个基本的常用算子，使用者可以根据接口规则实现自定义的算子并放入框架中运行。我自己也会根据自己的需求后续添加更多的改进算子，同时改进框架使其更加<strong>通用</strong>.</p>
<p><img src="/assets/images/blog_img/2017-07-23-gaft-一个基于Python的遗传算法框架/title.png" alt=""></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="遗传算法介绍"><a href="#遗传算法介绍" class="headerlink" title="遗传算法介绍"></a>遗传算法介绍</h3><p>这里我对遗传算法的基本概念进行简要的介绍，并阐述gaft的设计原则。</p>
<p>简单而言，遗传算法使用群体搜索技术，将种群代表一组问题的可行解，通过对当前种群施加选择，交叉，变异等一些列遗传操作来产生新一代的种群，并逐步是种群进化到包含近似全局最优解的状态。下面我将遗传学和遗传算法相关术语的对应关系总结一下:</p>
<h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><table>
<thead>
<tr>
<th style="text-align:left">遗传学术语</th>
<th style="text-align:left">遗传算法术语</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">群体</td>
<td style="text-align:left">可行解集</td>
</tr>
<tr>
<td style="text-align:left">个体</td>
<td style="text-align:left">可行解</td>
</tr>
<tr>
<td style="text-align:left">染色体</td>
<td style="text-align:left">可行解的编码</td>
</tr>
<tr>
<td style="text-align:left">基因</td>
<td style="text-align:left">可行解编码的分量</td>
</tr>
<tr>
<td style="text-align:left">基因形式</td>
<td style="text-align:left">遗传编码</td>
</tr>
<tr>
<td style="text-align:left">适应度</td>
<td style="text-align:left">评价函数值</td>
</tr>
<tr>
<td style="text-align:left">选择</td>
<td style="text-align:left">选择操作</td>
</tr>
<tr>
<td style="text-align:left">交叉</td>
<td style="text-align:left">交叉操作</td>
</tr>
<tr>
<td style="text-align:left">变异</td>
<td style="text-align:left">变异操作</td>
</tr>
</tbody>
</table>
<h4 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h4><ol>
<li>以决策变量的编码作为运算对象，使得优化过程借鉴生物学中的概念成为可能</li>
<li>直接以目标函数作为搜索信息，确定搜索方向很范围，属于无导数优化</li>
<li>同时使用多个搜索点的搜索信息，算是一种隐含的并行性</li>
<li>是一种基于概率的搜索技术</li>
<li>具有自组织，自适应和自学习等特性</li>
</ol>
<h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p><img src="/assets/images/blog_img/2017-07-23-gaft-一个基于Python的遗传算法框架/flowchart.png" alt=""></p>
<h4 id="gaft-设计原则"><a href="#gaft-设计原则" class="headerlink" title="gaft 设计原则"></a>gaft 设计原则</h4><p>由于遗传算法的流程相对固定，我们优化算法基本上也是在流程整体框架下对编码机制，算子，参数等进行修改，因此在写框架的时候，我便想把那些固定的遗传算子，适应度函数写成接口，并使用元类、装饰器等方式实现对接口的限制和优化，这样便可以方便后续自定义算符和适应度函数定制。最后将各个部分组合到一起组成一个engine然后根据算法流程运行遗传算法对目标进行优化.</p>
<p>这样我们便脱离每次都要写遗传算法流程的繁琐，每次只需要像写插件一样实现自己的算子和适应度函数便可以将其放入gaft开始对算法进行测试或者对目标函数进行优化了。</p>
<h3 id="GAFT文件结构"><a href="#GAFT文件结构" class="headerlink" title="GAFT文件结构"></a>GAFT文件结构</h3><p>此部分我对自己实现的框架的整体结构进行下介绍.<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── LICENSE</div><div class="line">├── MANIFEST<span class="selector-class">.in</span></div><div class="line">├── README<span class="selector-class">.rst</span></div><div class="line">├── examples</div><div class="line">│   ├── ex01</div><div class="line">│   └── ex02</div><div class="line">├── gaft</div><div class="line">│   ├── __init__<span class="selector-class">.py</span></div><div class="line">│   ├── __pycache__</div><div class="line">│   ├── analysis</div><div class="line">│   ├── components</div><div class="line">│   ├── engine<span class="selector-class">.py</span></div><div class="line">│   ├── operators</div><div class="line">│   └── plugin_interfaces</div><div class="line">├── setup<span class="selector-class">.cfg</span></div><div class="line">├── setup<span class="selector-class">.py</span></div><div class="line">└── tests</div><div class="line">    ├── flip_bit_mutation_test<span class="selector-class">.py</span></div><div class="line">        ├── gaft_test<span class="selector-class">.py</span></div><div class="line">        ├── individual_test<span class="selector-class">.py</span></div><div class="line">        ├── population_test<span class="selector-class">.py</span></div><div class="line">        ├── roulette_wheel_selection_test<span class="selector-class">.py</span></div><div class="line">        └── uniform_crossover_test.py</div></pre></td></tr></table></figure></p>
<p>目前的文件结果如上所示，</p>
<ul>
<li><code>/gaft/components</code>中定义了内置的个体和种群类型，提供了两种不同的遗传编码方式:二进制编码和实数编码。</li>
<li><code>/gaft/plugin_interfaces</code>中是插件接口定义，所有的算子定义以及on-the-fly分析的接口规则都在里面，使用者可以根据此来编写自己的插件并放入到engine中。</li>
<li><code>/gaft/operators</code>里面是内置遗传算子，他们也是遵循<code>/gaft/plugin_interfaces</code>中的规则进行编写，可以作为编写算子的例子。其中算子我目前内置了roulette wheel选择算子，uniform 交叉算子和flipbit变异算子，使用者可以直接使用内置算子来使用gaft对自己的问题进行优化。</li>
<li><code>/gaft/analysis</code>里面是内置的on-the-fly分析插件，他可以在遗传算法迭代的过程中对迭代过程中的变量进行分析，例如我在里面内置了控制台日志信息输出，以及迭代适应度值的保存等插件方便对进化曲线作图。</li>
<li><code>/gaft/engine</code>便是遗传算法的流程控制模块了，他将所有的之前定义的各个部分组合到一起使用遗传算法流程进行优化迭代。</li>
</ul>
<h3 id="使用GAFT"><a href="#使用GAFT" class="headerlink" title="使用GAFT"></a>使用GAFT</h3><p>下面我就以两个函数作为例子来使用GAFT对目标函数进行优化.</p>
<h4 id="一维搜索"><a href="#一维搜索" class="headerlink" title="一维搜索"></a>一维搜索</h4><p>首先我们先对一个简单的具有多个局部极值的函数进行优化，我们来使用内置的算子求函数<br>$$<br>f(x) = x + 10sin(5x) + 7cos(4x)<br>$$<br>的极大值，x的取值范围为$[0, 10]$</p>
<ol>
<li><p><strong>先导入需要的模块</strong></p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sin, cos</div><div class="line"></div><div class="line"><span class="comment"># 导入种群和内置算子相关类</span></div><div class="line"><span class="keyword">from</span> gaft <span class="keyword">import</span> GAEngine</div><div class="line"><span class="keyword">from</span> gaft.components <span class="keyword">import</span> GAIndividual</div><div class="line"><span class="keyword">from</span> gaft.components <span class="keyword">import</span> GAPopulation</div><div class="line"><span class="keyword">from</span> gaft.operators <span class="keyword">import</span> RouletteWheelSelection</div><div class="line"><span class="keyword">from</span> gaft.operators <span class="keyword">import</span> UniformCrossover</div><div class="line"><span class="keyword">from</span> gaft.operators <span class="keyword">import</span> FlipBitMutation</div><div class="line"></div><div class="line"><span class="comment"># 用于编写分析插件的接口类</span></div><div class="line"><span class="keyword">from</span> gaft.plugin_interfaces.analysis <span class="keyword">import</span> OnTheFlyAnalysis</div><div class="line"></div><div class="line"><span class="comment"># 内置的存档适应度函数的分析类</span></div><div class="line"><span class="keyword">from</span> gaft.analysis.fitness_store <span class="keyword">import</span> FitnessStoreAnalysis</div><div class="line"></div><div class="line"><span class="comment"># 我们将用两种方式将分析插件注册到遗传算法引擎中</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>创建引擎</strong></p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 定义种群</span></div><div class="line">indv_template = GAIndividual(ranges=[(<span class="number">0</span>, <span class="number">10</span>)], encoding=<span class="string">'binary'</span>, eps=<span class="number">0.001</span>)</div><div class="line">population = GAPopulation(indv_template=indv_template, size=<span class="number">50</span>)</div><div class="line"></div><div class="line"><span class="comment"># 创建遗传算子</span></div><div class="line">selection = RouletteWheelSelection()</div><div class="line">crossover = UniformCrossover(pc=<span class="number">0.8</span>, pe=<span class="number">0.5</span>)</div><div class="line">mutation = FlipBitMutation(pm=<span class="number">0.1</span>)</div><div class="line"></div><div class="line"><span class="comment"># 创建遗传算法引擎, 分析插件和适应度函数可以以参数的形式传入引擎中</span></div><div class="line">engine = GAEngine(population=population, selection=selection,</div><div class="line">                  crossover=crossover, mutation=mutation,</div><div class="line">                  analysis=[FitnessStoreAnalysis])</div></pre></td></tr></table></figure>
</li>
<li><p><strong>自定义适应度函数</strong></p>
<p> 可以通过修饰符的方式将，适应度函数注册到引擎中。</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@engine.fitness_register</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fitness</span><span class="params">(indv)</span>:</span></div><div class="line">    x, = indv.variants</div><div class="line">    <span class="keyword">return</span> x + <span class="number">10</span>*sin(<span class="number">5</span>*x) + <span class="number">7</span>*cos(<span class="number">4</span>*x)</div></pre></td></tr></table></figure>
</li>
<li><p><strong>自定义on-the-fly分析插件</strong></p>
<p> 也可以通过修饰符在定义的时候直接将插件注册到引擎中</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@engine.analysis_register</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsoleOutputAnalysis</span><span class="params">(OnTheFlyAnalysis)</span>:</span></div><div class="line">    interval = <span class="number">1</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register_step</span><span class="params">(self, ng, population, engine)</span>:</span></div><div class="line">        best_indv = population.best_indv(engine.fitness)</div><div class="line">        msg = <span class="string">'Generation: &#123;&#125;, best fitness: &#123;:.3f&#125;'</span>.format(ng, engine.fitness(best_indv))</div><div class="line">        engine.logger.info(msg)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finalize</span><span class="params">(self, population, engine)</span>:</span></div><div class="line">        best_indv = population.best_indv(engine.fitness)</div><div class="line">        x = best_indv.variants</div><div class="line">        y = engine.fitness(best_indv)</div><div class="line">        msg = <span class="string">'Optimal solution: (&#123;&#125;, &#123;&#125;)'</span>.format(x, y)</div><div class="line">        engine.logger.info(msg)</div></pre></td></tr></table></figure>
</li>
<li><p><strong>Ok, 开始跑(优化)吧！</strong></p>
<p> 我们这里跑100代种群.</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="string">'__main__'</span> == __name__:</div><div class="line">    <span class="comment"># Run the GA engine.</span></div><div class="line">    engine.run(ng=<span class="number">100</span>)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>内置的分析插件会在每步迭代中记录得到的每一代的最优个体，并生成数据保存。</p>
<p>绘制一下函数本身的曲线和我们使用遗传算法得到的进化曲线:</p>
<p><img src="/assets/images/blog_img/2017-07-23-gaft-一个基于Python的遗传算法框架/envolution_curve_1d.png" alt=""></p>
<p>优化过程动画:</p>
<p><img src="/assets/images/blog_img/2017-07-23-gaft-一个基于Python的遗传算法框架/animation.gif" alt=""></p>
<h4 id="二维搜索"><a href="#二维搜索" class="headerlink" title="二维搜索"></a>二维搜索</h4><p>下面我们使用GAFT内置算子来搜索同样具有多个极值点的二元函数<br>$$<br>f(x) = ysin(2\pi x) + xcos(2\pi y)<br>$$</p>
<p>的最大值，x, y 的范围为 $[-2, 2]$.</p>
<p>这里我们就不自定义分析插件了，直接使用内置的分析类，并在构造引擎时直接传入.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="string">'''</span></div><div class="line">Find the global maximum for binary function: f(x) = y*sim(2*pi*x) + x*cos(2*pi*y)</div><div class="line">'''</div><div class="line"></div><div class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sin, cos, pi</div><div class="line"></div><div class="line"><span class="keyword">from</span> gaft <span class="keyword">import</span> GAEngine</div><div class="line"><span class="keyword">from</span> gaft.components <span class="keyword">import</span> GAIndividual</div><div class="line"><span class="keyword">from</span> gaft.components <span class="keyword">import</span> GAPopulation</div><div class="line"><span class="keyword">from</span> gaft.operators <span class="keyword">import</span> RouletteWheelSelection</div><div class="line"><span class="keyword">from</span> gaft.operators <span class="keyword">import</span> UniformCrossover</div><div class="line"><span class="keyword">from</span> gaft.operators <span class="keyword">import</span> FlipBitMutation</div><div class="line"></div><div class="line"><span class="comment"># Built-in best fitness analysis.</span></div><div class="line"><span class="keyword">from</span> gaft.analysis.fitness_store <span class="keyword">import</span> FitnessStoreAnalysis</div><div class="line"><span class="keyword">from</span> gaft.analysis.console_output <span class="keyword">import</span> ConsoleOutputAnalysis</div><div class="line"></div><div class="line"><span class="comment"># Define population.</span></div><div class="line">indv_template = GAIndividual(ranges=[(<span class="number">-2</span>, <span class="number">2</span>), (<span class="number">-2</span>, <span class="number">2</span>)], encoding=<span class="string">'binary'</span>, eps=<span class="number">0.001</span>)</div><div class="line">population = GAPopulation(indv_template=indv_template, size=<span class="number">50</span>)</div><div class="line"></div><div class="line"><span class="comment"># Create genetic operators.</span></div><div class="line">selection = RouletteWheelSelection()</div><div class="line">crossover = UniformCrossover(pc=<span class="number">0.8</span>, pe=<span class="number">0.5</span>)</div><div class="line">mutation = FlipBitMutation(pm=<span class="number">0.1</span>)</div><div class="line"></div><div class="line"><span class="comment"># Create genetic algorithm engine.</span></div><div class="line"><span class="comment"># Here we pass all built-in analysis to engine constructor.</span></div><div class="line">engine = GAEngine(population=population, selection=selection,</div><div class="line">                  crossover=crossover, mutation=mutation,</div><div class="line">                  analysis=[ConsoleOutputAnalysis, FitnessStoreAnalysis])</div><div class="line"></div><div class="line"><span class="comment"># Define fitness function.</span></div><div class="line"><span class="meta">@engine.fitness_register</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fitness</span><span class="params">(indv)</span>:</span></div><div class="line">    x, y = indv.variants</div><div class="line">    <span class="keyword">return</span> y*sin(<span class="number">2</span>*pi*x) + x*cos(<span class="number">2</span>*pi*y)</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="string">'__main__'</span> == __name__:</div><div class="line">    engine.run(ng=<span class="number">100</span>)</div></pre></td></tr></table></figure>
<p>进化曲线:<br><img src="/assets/images/blog_img/2017-07-23-gaft-一个基于Python的遗传算法框架/envolution_curve.png" alt=""></p>
<p>二维函数面:<br><img src="/assets/images/blog_img/2017-07-23-gaft-一个基于Python的遗传算法框架/surface.png" alt=""></p>
<p>搜索过程动画:<br><img src="/assets/images/blog_img/2017-07-23-gaft-一个基于Python的遗传算法框架/surface_animation.gif" alt=""></p>
<p>可见目前内置的基本算子都能很好的找到例子中函数的最优点。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了本人开发的一个用于遗传算法做优化计算的Python框架，框架内置了遗传算法中常用的组件，包括不同编码方式的个体，种群，以及遗传算子等。同时框架还提供了自定义遗传算子和分析插件的接口，能够方便快速搭建遗传算法流程并用于算法测试。</p>
<p>目前框架仅仅处于初步阶段，后续会在自己使用的过程中逐步完善更多的内置算子，是框架更加通用。本文中的两个优化例子均能在GitHub上找到源码(<a href="https://github.com/PytLab/gaft/tree/master/examples" target="_blank" rel="external">https://github.com/PytLab/gaft/tree/master/examples</a>)</p>
<p>目前的计划：1. 添加更多的内置算子; 2. 给内置算子和组件添加C++ backend; 3. 并行化</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《智能优化算法及其MATLAB实例》</li>
<li>《MATLAB最优化计算》</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 代码作品 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> GeneticAlgorithm </tag>
            
            <tag> gaft </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习算法实践-Logistic回归与梯度上升算法(下)]]></title>
      <url>http://pytlab.github.io/2017/07/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5-Logistic%E5%9B%9E%E5%BD%92%E4%B8%8E%E6%A2%AF%E5%BA%A6%E4%B8%8A%E5%8D%87%E7%AE%97%E6%B3%95-%E4%B8%8B/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上篇主要总结了Logistic回归模型建立的理论基础，主要包含模型似然函数的建立以及梯度上升算法的优化推导。本文在上文的基础上使用Python一步步实现一个Logistic回归分类器，并分别使用梯度上升和随机梯度上升算法实现，对二维数据点分类进行可视化，最后使用之前使用过的<a href="http://www.esp.uem.es/jmgomez/smsspamcorpus/" target="_blank" rel="external">SMS垃圾短信语料库</a>中的短信数据进行模型训练并对短信数据进行分类。</p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h3><p>从文件中读取特征以及类别标签用于优化模型参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">(filename)</span>:</span></div><div class="line">    dataset, labels = [], []</div><div class="line">    <span class="keyword">with</span> open(filename, <span class="string">'r'</span>) <span class="keyword">as</span> f:</div><div class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</div><div class="line">            splited_line = [float(i) <span class="keyword">for</span> i <span class="keyword">in</span> line.strip().split(<span class="string">'\t'</span>)]</div><div class="line">            data, label = [<span class="number">1.0</span>] + splited_line[: <span class="number">-1</span>], splited_line[<span class="number">-1</span>]</div><div class="line">            dataset.append(data)</div><div class="line">            labels.append(label)</div><div class="line">    dataset = np.array(dataset)</div><div class="line">    labels = np.array(labels)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> dataset, labels</div></pre></td></tr></table></figure>
<h3 id="使用梯度上升算法"><a href="#使用梯度上升算法" class="headerlink" title="使用梯度上升算法"></a>使用梯度上升算法</h3><p>上文对Logistic回归模型使用梯度上升算法优化参数进行了理论介绍，这里就最先使用梯度上升算法来构建一个分类器.</p>
<p>首先我们是Sigmoid函数:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="string">''' Sigmoid 阶跃函数</span></div><div class="line">    '''</div><div class="line">    <span class="keyword">return</span> <span class="number">1.0</span>/(<span class="number">1</span> + np.exp(-x))</div></pre></td></tr></table></figure></p>
<p>然后是梯度上升算法的实现:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_ascent</span><span class="params">(self, dataset, labels, max_iter=<span class="number">10000</span>)</span>:</span></div><div class="line">    <span class="string">''' 使用梯度上升优化Logistic回归模型参数</span></div><div class="line"></div><div class="line">    :param dataset: 数据特征矩阵</div><div class="line">    :type dataset: MxN numpy matrix</div><div class="line"></div><div class="line">    :param labels: 数据集对应的类型向量</div><div class="line">    :type labels: Nx1 numpy matrix</div><div class="line">    '''</div><div class="line">    dataset = np.matrix(dataset)</div><div class="line">    vlabels = np.matrix(labels).reshape(<span class="number">-1</span>, <span class="number">1</span>)</div><div class="line">    m, n = dataset.shape</div><div class="line">    w = np.ones((n, <span class="number">1</span>))</div><div class="line">    alpha = <span class="number">0.001</span></div><div class="line">    ws = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(max_iter):</div><div class="line">        error = vlabels - self.sigmoid(dataset*w)</div><div class="line">        w += alpha*dataset.T*error</div><div class="line">        ws.append(w.reshape(<span class="number">1</span>, <span class="number">-1</span>).tolist()[<span class="number">0</span>])</div><div class="line"></div><div class="line">    self.w = w</div><div class="line"></div><div class="line">    <span class="keyword">return</span> w, np.array(ws)</div></pre></td></tr></table></figure></p>
<p>在这里的数据操作都转换成Numpy矩阵的操作，主要是方便处理避免Python循环处理。同时每次梯度上升迭代过程中都把自变量，也就是Logistic模型参数进行收集，方便最后查看参数收敛情况。</p>
<p>关于梯度上升算法中，我们每次沿着梯度方向移动的步长 $\alpha$ 都设的固定距离为0.001，并没有做一维搜索。</p>
<h3 id="可视化决策边界"><a href="#可视化决策边界" class="headerlink" title="可视化决策边界"></a>可视化决策边界</h3><p>Sigmoid函数的特点就是通过0点来进行分类，$\overline{x}^{T} \centerdot \overline{\omega}$ 的值小于0为一类，大于0位另外一类，因此我们可以通过 $\overline{x}^{T} \centerdot \overline{\omega} = 0$ 来获取分界线或者超平面。在二维平面里，我们可以通过求解 $w_{0}x_{0} + w_{1}x_{0}$(其中 $x_{0} = 1$) 并绘制直线来可视化决策边界。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">snapshot</span><span class="params">(w, dataset, labels, pic_name)</span>:</span></div><div class="line">    <span class="string">''' 绘制类型分割线图</span></div><div class="line">    '''</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'./snapshots'</span>):</div><div class="line">        os.mkdir(<span class="string">'./snapshots'</span>)</div><div class="line"></div><div class="line">    fig = plt.figure()</div><div class="line">    ax = fig.add_subplot(<span class="number">111</span>)</div><div class="line"></div><div class="line">    pts = &#123;&#125;</div><div class="line">    <span class="keyword">for</span> data, label <span class="keyword">in</span> zip(dataset.tolist(), labels.tolist()):</div><div class="line">        pts.setdefault(label, [data]).append(data)</div><div class="line"></div><div class="line">    <span class="keyword">for</span> label, data <span class="keyword">in</span> pts.items():</div><div class="line">        data = np.array(data)</div><div class="line">        plt.scatter(data[:, <span class="number">1</span>], data[:, <span class="number">2</span>], label=label, alpha=<span class="number">0.5</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 分割线绘制</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_y</span><span class="params">(x, w)</span>:</span></div><div class="line">        w0, w1, w2 = w</div><div class="line">        <span class="keyword">return</span> (-w0 - w1*x)/w2</div><div class="line"></div><div class="line">    x = [<span class="number">-4.0</span>, <span class="number">3.0</span>]</div><div class="line">    y = [get_y(i, w) <span class="keyword">for</span> i <span class="keyword">in</span> x]</div><div class="line"></div><div class="line">    plt.plot(x, y, linewidth=<span class="number">2</span>, color=<span class="string">'#FB4A42'</span>)</div><div class="line"></div><div class="line">    pic_name = <span class="string">'./snapshots/&#123;&#125;'</span>.format(pic_name)</div><div class="line">    fig.savefig(pic_name)</div><div class="line">    plt.close(fig)</div></pre></td></tr></table></figure>
<p>好了，优化算法和可视化代码都具备了，我们便可以拟合我们的数据了，这里使用两种类型的二维数据点来训练模型, 数据见<a href="https://github.com/PytLab/MLBox/blob/master/logistic_regression/testSet.txt" target="_blank" rel="external">https://github.com/PytLab/MLBox/blob/master/logistic_regression/testSet.txt</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="string">'__main__'</span> == __name__:</div><div class="line">    clf = LogisticRegressionClassifier()</div><div class="line">    dataset, labels = load_data(<span class="string">'testSet.txt'</span>)</div><div class="line">    w, ws = clf.gradient_ascent(dataset, labels, max_iter=<span class="number">50000</span>)</div><div class="line">    m, n = ws.shape</div><div class="line"></div><div class="line">    <span class="comment"># 绘制分割线</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">300</span>):</div><div class="line">        <span class="keyword">if</span> i % (<span class="number">30</span>) == <span class="number">0</span>:</div><div class="line">            print(<span class="string">'&#123;&#125;.png saved'</span>.format(i))</div><div class="line">            snapshot(ws[i].tolist(), dataset, labels, <span class="string">'&#123;&#125;.png'</span>.format(i))</div><div class="line"></div><div class="line">    fig = plt.figure()</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">        label = <span class="string">'w&#123;&#125;'</span>.format(i)</div><div class="line">        ax = fig.add_subplot(n, <span class="number">1</span>, i+<span class="number">1</span>)</div><div class="line">        ax.plot(ws[:, i], label=label)</div><div class="line">        ax.legend()</div><div class="line"></div><div class="line">    fig.savefig(<span class="string">'w_traj.png'</span>)</div></pre></td></tr></table></figure>
<p>通过将迭代过程中的权重参数输出，我们可以绘制决策边界的变化，看到参数的优化过程:</p>
<p><img src="/assets/images/blog_img/2017-07-15-机器学习算法实践-Logistic回归与梯度上升算法-下/grad_ascent_animation.gif" alt=""></p>
<p>下面我们可视化一下模型参数在梯度上升过程中的收敛情况，我们总共迭代了50000步：</p>
<p><img src="/assets/images/blog_img/2017-07-15-机器学习算法实践-Logistic回归与梯度上升算法-下/grad_ascent_params.png" alt=""></p>
<h3 id="使用随机随机梯度上升算法"><a href="#使用随机随机梯度上升算法" class="headerlink" title="使用随机随机梯度上升算法"></a>使用随机随机梯度上升算法</h3><p>从求目标函数梯度的公式<br>$$<br>\nabla ln\mathcal{L}(\overline{\omega}) = \overline{x} \centerdot (\overline{y} - \overline{\pi(\overline{x})}) = \overline{x} \centerdot \overline{error}<br>$$<br>和实现代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">error = vlabels - self.sigmoid(dataset*w)</div><div class="line">w += alpha*dataset.T*error</div></pre></td></tr></table></figure></p>
<p>中我们可以看到，在使用梯度上升算法优化的时候每次迭代都需要使用所有的训练数据乘上误差向量，如果样本只有几百个那还好，如果有数十亿样本，那这个矩阵乘法将会非常的大，于是我们可以考虑使用随机梯度上升来更新 $\omega$, 所谓随机梯度就是指更新 $\omega$ 的时候不需要用所有的数据矩阵和误差矩阵乘积来更新，而是使用样本中随机选出的一个数据点来计算梯度并更新。这样可以在新的样本到来时对分类器进行<strong>增量式更新</strong>，因而随机梯度算法是一个<strong>在线学习</strong>算法, 之前的梯度上升算法是一次性处理所有样本数据被称作是<strong>批处理</strong>。</p>
<p>下面我们就重新写一个通过随机梯度上升算法优化的Logistic回归分类器<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> logreg_grad_ascent <span class="keyword">import</span> LogisticRegressionClassifier <span class="keyword">as</span> BaseClassifer</div><div class="line"><span class="keyword">from</span> logreg_grad_ascent <span class="keyword">import</span> load_data, snapshot</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogisticRegressionClassifier</span><span class="params">(BaseClassifer)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stoch_gradient_ascent</span><span class="params">(self, dataset, labels, max_iter=<span class="number">150</span>)</span>:</span></div><div class="line">        <span class="string">''' 使用随机梯度上升算法优化Logistic回归模型参数</span></div><div class="line">        '''</div><div class="line">        dataset = np.matrix(dataset)</div><div class="line">        m, n = dataset.shape</div><div class="line">        w = np.matrix(np.ones((n, <span class="number">1</span>)))</div><div class="line">        ws = []</div><div class="line"></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(max_iter):</div><div class="line">            data_indices = list(range(m))</div><div class="line">            random.shuffle(data_indices)</div><div class="line">            <span class="keyword">for</span> j, idx <span class="keyword">in</span> enumerate(data_indices):</div><div class="line">                data, label = dataset[idx], labels[idx]</div><div class="line">                error = label - self.sigmoid((data*w).tolist()[<span class="number">0</span>][<span class="number">0</span>])</div><div class="line">                alpha = <span class="number">4</span>/(<span class="number">1</span> + j + i) + <span class="number">0.01</span></div><div class="line">                w += alpha*data.T*error</div><div class="line">                ws.append(w.T.tolist()[<span class="number">0</span>])</div><div class="line"></div><div class="line">        self.w = w</div><div class="line"></div><div class="line">        <span class="keyword">return</span> w, np.array(ws)</div></pre></td></tr></table></figure></p>
<p>我们写一个继承与刚才实现的分类器的派生类，并实现随机梯度算法，这里沿着梯度方向的步长随着迭代会逐渐减小来减弱参数的博定。</p>
<p>我们同样来可视化决策边界和参数的收敛曲线来看看随机梯度下降法对模型的优化过程:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="string">'__main__'</span> == __name__:</div><div class="line">    clf = LogisticRegressionClassifier()</div><div class="line">    dataset, labels = load_data(<span class="string">'testSet.txt'</span>)</div><div class="line">    w, ws = clf.stoch_gradient_ascent(dataset, labels, max_iter=<span class="number">500</span>)</div><div class="line">    m, n = ws.shape</div><div class="line"></div><div class="line">    <span class="comment"># 绘制分割线</span></div><div class="line">    <span class="keyword">for</span> i, w <span class="keyword">in</span> enumerate(ws):</div><div class="line">        <span class="keyword">if</span> i % (m//<span class="number">10</span>) == <span class="number">0</span>:</div><div class="line">            print(<span class="string">'&#123;&#125;.png saved'</span>.format(i))</div><div class="line">            snapshot(w.tolist(), dataset, labels, <span class="string">'&#123;&#125;.png'</span>.format(i))</div><div class="line"></div><div class="line">    fig = plt.figure()</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">        label = <span class="string">'w&#123;&#125;'</span>.format(i)</div><div class="line">        ax = fig.add_subplot(n, <span class="number">1</span>, i+<span class="number">1</span>)</div><div class="line">        ax.plot(ws[:, i], label=label)</div><div class="line">        ax.legend()</div><div class="line"></div><div class="line">    fig.savefig(<span class="string">'stoch_grad_ascent_params.png'</span>)</div></pre></td></tr></table></figure></p>
<p>决策线变化:<br><img src="/assets/images/blog_img/2017-07-15-机器学习算法实践-Logistic回归与梯度上升算法-下/stoch_grad_ascent_animation.gif" alt=""></p>
<p>参数收敛曲线:<br><img src="/assets/images/blog_img/2017-07-15-机器学习算法实践-Logistic回归与梯度上升算法-下/stoch_grad_ascent_params.png" alt=""></p>
<h3 id="使用Logistic回归分类器分类短信"><a href="#使用Logistic回归分类器分类短信" class="headerlink" title="使用Logistic回归分类器分类短信"></a>使用Logistic回归分类器分类短信</h3><p>这里我还是使用了前两篇决策树和贝叶斯分类器使用的垃圾短信数据集来训练Logistic回归分类器，这时候对于Logistic分类器的参数可能会比较多，我们使用随机梯度上升算法来优化参数，相对于贝叶斯分类器，基于随机梯度上升算法的Logistic回归分类器对于维数较高的的数据向量和数量较大的数据集的训练速度还是有待改善的，我们同样使用留存交叉验证的方式来训练和测试模型，测试了三次Logistic回归模型对于垃圾短信的识别错误率分别为: 0.0833, 0.038, 0.038.</p>
<p><img src="/assets/images/blog_img/2017-07-15-机器学习算法实践-Logistic回归与梯度上升算法-下/error-rates.png" alt=""></p>
<p>平均错误率为5.3%。可见我们的Logistic回归分类器也能较好的对垃圾短信文本进行识别。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文总结了Logistic回归和相关的优化算法(梯度上升以及随机梯度上升)的理论和代码实现，并对实现的模型进行了训练和测试。</p>
<h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><ul>
<li><a href="http://pytlab.org/2017/07/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5-%E5%86%B3%E7%AD%96%E6%A0%91/" target="_blank" rel="external">机器学习算法实践-决策树(Decision Tree)</a></li>
<li><a href="http://pytlab.org/2017/07/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF-Naive-Bayes/" target="_blank" rel="external">机器学习算法实践-朴素贝叶斯(Naive Bayes)</a></li>
<li><a href="http://pytlab.org/2017/07/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5-Logistic%E5%9B%9E%E5%BD%92%E4%B8%8E%E6%A2%AF%E5%BA%A6%E4%B8%8A%E5%8D%87%E7%AE%97%E6%B3%95-%E4%B8%8A/" target="_blank" rel="external">机器学习算法实践-Logistic回归与梯度上升算法(上)</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> MachineLearning </tag>
            
            <tag> LogisticRegression </tag>
            
            <tag> Optimization </tag>
            
            <tag> GradientAscent </tag>
            
            <tag> StochasticGradientAscent </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习算法实践-Logistic回归与梯度上升算法(上)]]></title>
      <url>http://pytlab.github.io/2017/07/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5-Logistic%E5%9B%9E%E5%BD%92%E4%B8%8E%E6%A2%AF%E5%BA%A6%E4%B8%8A%E5%8D%87%E7%AE%97%E6%B3%95-%E4%B8%8A/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于Logistic回归分类器我打算用两部分总结，第一部分主要介绍Logistic回归的理论相关的部分，因为这里涉及到通过似然函数建立Logistic回归模型以及使用梯度上升算法优化参数两个主要的内容, 感觉可能比较多, 不过对于学习过最优化方法, 概率论以及线性代数的基础内容童鞋来说，这部分也是很快就掌握得啦。第二部分主要总结Logistic回归模型的代码实现和模型训练以及测试等。</p>
<h2 id="Logistic回归"><a href="#Logistic回归" class="headerlink" title="Logistic回归"></a>Logistic回归</h2><p>Logistic回归为概率型非线性回归模型, 是研究二值型输出分类的一种多变量分析方法。通过logistic回归我们可以将二分类的观察结果$y$与一些影响因素$[x_{1}, x_{2}, x_{3}, …]$ 建立起关系从而对某些因素条件下某个结果发生的概率进行估计并分类。</p>
<a id="more"></a>
<h2 id="Sigmoid函数"><a href="#Sigmoid函数" class="headerlink" title="Sigmoid函数"></a>Sigmoid函数</h2><p>对于二分类问题，我们想要一个函数能够接受所有输入然后预测出两种类别，可以通过输出0或者1。这个函数就是sigmoid函数，它是一种阶跃函数具体的计算公式如下:<br>$$<br>\sigma(z) = \frac{1}{1 + e^{-z}}<br>$$<br>Sigmoid函数的性质: 当$x$为0时，Sigmoid函数值为0.5，随着$x$的增大对应的Sigmoid值将逼近于1; 而随着$x$的减小, Sigmoid函数会趋近于0。</p>
<h2 id="Logistic回归分类器-Logistic-Regression-Classifier"><a href="#Logistic回归分类器-Logistic-Regression-Classifier" class="headerlink" title="Logistic回归分类器(Logistic Regression Classifier)"></a>Logistic回归分类器(Logistic Regression Classifier)</h2><p>Logistic回归分类器是这样一种分类器:</p>
<p>在分类情形下，经过学习后的LR分类器是一组权值<br>$$<br>\overline{\omega} = [\omega_{0}, \omega_{1}, \omega_{2}, … , \omega_{n}]^{T}<br>$$<br>，样本也可以用一组向量 $\overline{x}$ 表示:<br>$$<br>\overline{x} = [x_{0}, x_{1}, x_{2}, x_{3}, … , x_{n}]^{T}<br>$$<br>其中$x_{0} = 1$</p>
<p>将 $\overline{x}$ 根据 $\overline{w}$ 线性叠加带入到Sigmoid函数中便可以得到范围在 $(0, 1)$, 之间的数值，大于$0.5$被分入1类，小于$0.5$的被归入0类:</p>
<p>$$<br>z = \overline{x}^{T}\centerdot\overline{\omega}<br>$$</p>
<p>$$<br>p(y=1 | \overline{x}) = \frac{1}{1 + e^{-z}}<br>$$</p>
<p>其中$p(y=1 | \overline{x})$就是指在特征为$\overline{x}$属于类1的条件概率, 当然也可以容易得到属于类0的概率为:</p>
<p>$$<br>p(y=0 | \overline{x}) = 1 - p(y=1 | \overline{x}) = \frac{1}{1 + e^{z}}<br>$$</p>
<p>所以Logistic回归最关键的问题就是研究如何求得 $\overline{\omega}$ 。这个问题就需要用<strong>似然函数</strong>进行<strong>极大似然</strong>估计来处理了。</p>
<h2 id="似然函数-Likelihood-function"><a href="#似然函数-Likelihood-function" class="headerlink" title="似然函数(Likelihood function)"></a>似然函数(Likelihood function)</h2><blockquote>
<p>In statistics, a likelihood function (often simply the likelihood) is a function of the parameters of a statistical model given data. </p>
</blockquote>
<p>从似然函数的英文定义中可以看到，似然函数是与<strong>统计模型中的参数</strong>的函数。虽然似然性和概率的意思差不多，但是在统计学中却有着明确的区分:</p>
<ol>
<li>概率(Probability)使我们平时用的最多的，用于在一直某些参数的值的情况下预测某个事件被观测到的可能性。</li>
<li>似然性(Likelihood)则是在一直观测到的结果时，对有关参数进行估计。</li>
</ol>
<p>可见这两个是个概念是个可逆的过程，即似然函数是条件概率的逆反.</p>
<p>对于某个已发生的事件 $x$, 某个参数或者某个参数向量 $\theta$ 的似然函数的值与已知参数 $\theta$ 前提下相同事件 $x$ 放生的条件概率(概率密度)的值相等, 即:</p>
<p>$$<br>\mathcal{L}(\theta | x) = P(x | \theta)<br>$$</p>
<p>似然函数对于离散和连续随机分布的表示形式是不同的:</p>
<h3 id="离散型"><a href="#离散型" class="headerlink" title="离散型"></a>离散型</h3><p>对于具有与参数 $\theta$ 相关离散概率分布 $p$ 的变量 $X$, 对于某个变量 $X = x$ $\theta$ 的似然函数表示成:<br>$$<br>\mathcal{L}(\theta | x) = p_{\theta}(x) = P_{\theta}(X=x)<br>$$</p>
<h3 id="连续型"><a href="#连续型" class="headerlink" title="连续型"></a>连续型</h3><p>连续性的分布我们则用概率密度 $f$ 来表示:<br>$$<br>\mathcal{L}(\theta | x) = f_{\theta}(x)<br>$$<br>注意似然函数并不是一个条件概率，虽然表达式与条件概率的形式相同。因为 $\theta$ 并不是一个随机变量而是一个参数。</p>
<div class="alert alert-info"><i class="fa fa-info"></i>  关于对似然性的理解，个人认为，似然性并不是一个概率，而是表示在一些列事件发生时，关于事件相关的参数的<b>可能性信息</b>，一个参数就对应一个似然函数的值，当参数发生变化的时候，似然函数也会随之变化，<b>似然函数的重要性并不在于他的具体值是多少，而在于他随参数变化的变化趋势</b>，是变大还是变小。当我们在取得某个参数的时候，似然函数的值到达了极大值，则说明这个参数具有**最合理性**。</div>
<h3 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h3><p>极大似然估计是似然函数最初也是最然的应用，我们优化Logistic模型就行极大似然估计的过程(求似然函数的极大值)，通过极大似然估计，我们可以得到最合理的参数。</p>
<h2 id="Logistic回归中的极大似然估计"><a href="#Logistic回归中的极大似然估计" class="headerlink" title="Logistic回归中的极大似然估计"></a>Logistic回归中的极大似然估计</h2><p>上一部分总结了什么似然函数和极大似然估计，这里就总结下Logistic模型的极大似然估计。</p>
<p>在LR分类器部分我们推导了Sigmoid函数计算两类问题的概率表达式，由于是二分类，分类结果是0和1，我们可以将两种类别的概率用一个式子表达, 对于一个样本 $\overline{x_{i}}$ 得到一个观测值为 $y_{i}$ 的概率为:<br>$$<br>P(y = y_{i} | \overline{x_{i}}) = p(y = 1 | \overline{x_{i}})^{y_{i}}(1 - p(y = 0 | \overline{x_{i}})^{1 - y_{i}} = (\frac{1}{1 + e^{-\overline{x_{i}}\centerdot\overline{\omega}^{T}}})^{y_{i}}(\frac{1}{1 + e^{\overline{x_{i}}\centerdot\overline{\omega}^{T}}})^{1 - y_{i}}<br>$$</p>
<p>若各个样本之间是相互独立的，则联合概率为各个样本概率的乘积。于是根据这系列的样本，我们就能得到关于参数向量 $\overline{\omega}$ 的似然函数 $\mathcal{L}(\overline{\omega})$ :</p>
<p>$$<br>\mathcal{L}(\overline{\omega}) = \prod_{i=1}^{n}(\frac{1}{1 + e^{-\overline{x_{i}}\centerdot\overline{\omega}^{T}}})^{y_{i}}(\frac{1}{1 + e^{\overline{x_{i}}\centerdot\overline{\omega}^{T}}})^{1 - y_{i}}<br>$$</p>
<p>我们的目的就是要对这个似然函数的极大值进行参数估计，这便是我们训练Logistic回归模型的过程。通过极大似然估计我们便可以通过所有样本得到满足训练数据集的最合理的参数 $\overline{\omega}$</p>
<h2 id="通过梯度上升算法进行极大似然估计"><a href="#通过梯度上升算法进行极大似然估计" class="headerlink" title="通过梯度上升算法进行极大似然估计"></a>通过梯度上升算法进行极大似然估计</h2><p>有了似然函数，我们便可以通过优化算法来进行优化了。使用梯度上升需要计算目标函数的梯度，下面我简单对梯度的计算进行一下推导:</p>
<p>为了方便，我们将似然函数取自然对数先,</p>
<p>$$<br>ln\mathcal{L}(\overline{\omega}) = \sum_{i=1}^{n}[y_{i}\centerdot ln\frac{exp(x_{i})}{exp(x_{i} + 1)} + (1 - y_{i}\centerdot ln\frac{1}{exp(x_{i} + 1)})]<br>$$<br>$$<br>ln\mathcal{L}(\overline{\omega}) = \sum_{i=1}^{m}[y_{i} \centerdot ln(exp(x_{i})) - y_{i} \centerdot ln(1 + exp(x_{i})) - (1 - y_{i})ln(1 + exp(x_{i}))]<br>$$<br>$$<br>ln\mathcal{L}(\overline{\omega}) = \sum_{i=1}^{n}(x_{i}y_{i} - ln(1 + exp(x_{i})))<br>$$</p>
<p>然后我们对去过对数的函数的梯度进行计算:</p>
<p>$$<br>\frac{\partial ln \mathcal{L}(\overline{\omega})}{\partial \omega_{k}} = \sum_{i=1}^{m}x_{ik}(y_{i} - \frac{1}{1 + exp(\overline{\omega} \centerdot \overline{x_{i}})})<br>$$</p>
<p>通过矩阵乘法直接表示成梯度:</p>
<p>$$<br>\nabla ln\mathcal{L}(\overline{\omega}) = \overline{x} \centerdot (\overline{y} - \overline{\pi(\overline{x})}) = \overline{x} \centerdot \overline{error}<br>$$</p>
<p>设步长为 \alpha, 则迭代得到的新的权重参数为:</p>
<p>$$<br>\overline{w} := \overline{w} + \alpha \nabla ln\mathcal{L}(\overline{\omega})<br>$$</p>
<p>这样我们通过梯度上升法做极大似然估计来做Logistic回归的过程就很清楚了，剩下的我们就需要通过代码来实现Logistic回归吧.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要总结了Logistic回归相关的原理以及使用梯度上升法做回归优化的过程推导，为我们自己实现Logistic回归分类器做好了充足的准备。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Likelihood_function" target="_blank" rel="external">https://en.wikipedia.org/wiki/Likelihood_function</a></li>
<li>《Machine Learning in Action》</li>
</ul>
<h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><ul>
<li><a href="http://pytlab.org/2017/07/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5-%E5%86%B3%E7%AD%96%E6%A0%91/" target="_blank" rel="external">机器学习算法实践-决策树(Decision Tree)</a></li>
<li><a href="http://pytlab.org/2017/07/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF-Naive-Bayes/" target="_blank" rel="external">机器学习算法实践-朴素贝叶斯(Naive Bayes)</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> MachineLearning </tag>
            
            <tag> LogisticRegression </tag>
            
            <tag> Optimization </tag>
            
            <tag> GradientAscent </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习算法实践-朴素贝叶斯(Naive Bayes)]]></title>
      <url>http://pytlab.github.io/2017/07/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF-Naive-Bayes/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://pytlab.org/2017/07/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5-%E5%86%B3%E7%AD%96%E6%A0%91/" target="_blank" rel="external">上一篇</a>总结了决策树的实现，本文中我将一步步实现一个朴素贝叶斯分类器，并采用<a href="http://www.esp.uem.es/jmgomez/smsspamcorpus/" target="_blank" rel="external">SMS垃圾短信语料库</a>中的数据进行模型训练，对垃圾短信进行过滤，在最后对分类的错误率进行了计算。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>与决策树分类和k近邻分类算法不同，贝叶斯分类主要借助概率论的知识来通过比较提供的数据属于每个类型的条件概率, 将他们分别计算出来然后预测具有最大条件概率的那个类别是最后的类别。当然样本越多我们统计的不同类型的特征值分布就越准确，使用此分布进行预测则会更加准确。</p>
<a id="more"></a>
<h3 id="贝叶斯准则"><a href="#贝叶斯准则" class="headerlink" title="贝叶斯准则"></a>贝叶斯准则</h3><p>朴素贝叶斯分类器中最核心的便是贝叶斯准则，他用如下的公式表示:<br>$$<br>p(c|x) = \frac{p(x|c)p(c)}{p(x)}<br>$$</p>
<p>此公式表示两个互换的条件概率之间的关系，他们通过联合概率关联起来，这样使得我们知道$p(B|A)$的情况下去计算$p(A|B)$成为了可能，而我们的贝叶斯模型便是通过贝叶斯准则去计算某个样本在不同类别条件下的条件概率并取具有最大条件概率的那个类型作为分类的预测结果。</p>
<h3 id="使用条件概率来进行分类"><a href="#使用条件概率来进行分类" class="headerlink" title="使用条件概率来进行分类"></a>使用条件概率来进行分类</h3><p>这里我通俗的介绍下如何通过条件概率来进行分类，假设我们看到了一个人的背影，想通过他背影的一些特征(数据)来判断这个人的性别(类别)，假设其中涉及到的特征有: 是否是长发, 身高是否在170以上，腿细，是否穿裙子。当我们看到一个背影便会得到一个特征向量用来描述上述特征(1表示是，0表示否): $\omega = [0, 1, 1, 0]$</p>
<p>贝叶斯分类便是比较如下两个条件概率:</p>
<ol>
<li>$p(男生 | \omega)$，$\omega$ 等于 $[0, 1, 1, 0]$ 的条件下此人是<strong>男生</strong>的概率</li>
<li>$p(女生 | \omega)$，$\omega$ 等于 $[0, 1, 1, 0]$ 的条件下此人是<strong>女生</strong>的概率</li>
</ol>
<p>若$p(男生 | \omega) &gt; p(女生 | \omega)$, 则判定此人为男生, 否则为女生</p>
<p>那么$p(男生 | \omega)$ 怎么求呢? 这就要上贝叶斯准则了</p>
<p>根据贝叶斯准则，<br>$$<br>p(男生 | \omega) = \frac{p(\omega | 男生)p(男生)}{p(\omega)}<br>$$<br>写成好理解些的便是:<br>$$<br>p(男生 | 短发且身高在170以上且腿细且不穿裙子) = \frac{p(短发且身高在170以上且腿细且不穿裙子 | 男生)p(男生)}{p(短发且身高在170以上且腿细且不穿裙子)}<br>$$</p>
<p>如果特征之间都是相互独立的(条件独立性假设)，那么便可以将上述条件概率改写成:</p>
<p>$$<br>p(短发且身高在170以上且腿细且不穿裙子 | 男生) = p(短发 | 男生) * p(170以上 | 男生) * p(腿细 | 男生) * p(没穿裙子 | 男生)<br>$$</p>
<p>这样我们就能计算当前这个背影属于男生和属于女生的条件概率了。</p>
<h3 id="实现自己的贝叶斯分类器"><a href="#实现自己的贝叶斯分类器" class="headerlink" title="实现自己的贝叶斯分类器"></a>实现自己的贝叶斯分类器</h3><p>贝叶斯分类器实现起来非常的简单, 下面我以进行文本分类为目的使用Python实现一个朴素贝叶斯文本分类器.</p>
<p>为了计算条件概率，我们需要计算各个特征的在不同类别下的条件概率以及类型的边际概率，这就需要我们通过大量的训练数据进行统计获取近似值了，这也就是我们训练我们朴素贝叶斯模型的过程.</p>
<p>针对不同的文本，我们可以将所有出现的单词作为数据特征向量，统计每个文本中出现词条的数目(或者是否出现某个词条)作为数据向量。这样一个文本就可以处理成一个整数列表，并且长度是所有词条的数目，这个向量也许会很长，用于本文的数据集中的短信词条大概一共3000多个单词。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_doc_vector</span><span class="params">(words, vocabulary)</span>:</span></div><div class="line">    <span class="string">''' 根据词汇表将文档中的词条转换成文档向量</span></div><div class="line"></div><div class="line">    :param words: 文档中的词条列表</div><div class="line">    :type words: list of str</div><div class="line"></div><div class="line">    :param vocabulary: 总的词汇列表</div><div class="line">    :type vocabulary: list of str</div><div class="line"></div><div class="line">    :return doc_vect: 用于贝叶斯分析的文档向量</div><div class="line">    :type doc_vect: list of int</div><div class="line">    '''</div><div class="line">    doc_vect = [<span class="number">0</span>]*len(vocabulary)</div><div class="line"></div><div class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words:</div><div class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> vocabulary:</div><div class="line">            idx = vocabulary.index(word)</div><div class="line">            doc_vect[idx] = <span class="number">1</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> doc_vect</div></pre></td></tr></table></figure>
<p>统计训练的过程的代码实现如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self, dataset, classes)</span>:</span></div><div class="line">    <span class="string">''' 训练朴素贝叶斯模型</span></div><div class="line"></div><div class="line">    :param dataset: 所有的文档数据向量</div><div class="line">    :type dataset: MxN matrix containing all doc vectors.</div><div class="line"></div><div class="line">    :param classes: 所有文档的类型</div><div class="line">    :type classes: 1xN list</div><div class="line"></div><div class="line">    :return cond_probs: 训练得到的条件概率矩阵</div><div class="line">    :type cond_probs: dict</div><div class="line"></div><div class="line">    :return cls_probs: 各种类型的概率</div><div class="line">    :type cls_probs: dict</div><div class="line">    '''</div><div class="line">    <span class="comment"># 按照不同类型记性分类</span></div><div class="line">    sub_datasets = defaultdict(<span class="keyword">lambda</span>: [])</div><div class="line">    cls_cnt = defaultdict(<span class="keyword">lambda</span>: <span class="number">0</span>)</div><div class="line"></div><div class="line">    <span class="keyword">for</span> doc_vect, cls <span class="keyword">in</span> zip(dataset, classes):</div><div class="line">        sub_datasets[cls].append(doc_vect)</div><div class="line">        cls_cnt[cls] += <span class="number">1</span></div><div class="line"></div><div class="line">    <span class="comment"># 计算类型概率</span></div><div class="line">    cls_probs = &#123;k: v/len(classes) <span class="keyword">for</span> k, v <span class="keyword">in</span> cls_cnt.items()&#125;</div><div class="line"></div><div class="line">    <span class="comment"># 计算不同类型的条件概率</span></div><div class="line">    cond_probs = &#123;&#125;</div><div class="line">    dataset = np.array(dataset)</div><div class="line">    <span class="keyword">for</span> cls, sub_dataset <span class="keyword">in</span> sub_datasets.items():</div><div class="line">        sub_dataset = np.array(sub_dataset)</div><div class="line">        <span class="comment"># Improve the classifier.</span></div><div class="line">        cond_prob_vect = np.log((np.sum(sub_dataset, axis=<span class="number">0</span>) + <span class="number">1</span>)/(np.sum(dataset) + <span class="number">2</span>))</div><div class="line">        cond_probs[cls] = cond_prob_vect</div><div class="line"></div><div class="line">    <span class="keyword">return</span> cond_probs, cls_probs</div></pre></td></tr></table></figure></p>
<p>注意这里对于基本的条件概率直接相乘有两处改进:</p>
<ol>
<li>各个特征的概率初始值为1，分母上统计的某一类型的样本总数的初始值是1，这是为了避免如果有一个特征统计的概率为0，则联合概率也为零那自然没有什么意义了, 如果训练样本足够大时，并不会对比较结果产生影响.</li>
<li>由于各个独立特征的概率都是小于1的数，累积起来必然会是个更小的书，这会遇到浮点数下溢的问题，因此在这里我们对所有的概率都取了对数处理，这样在保证不会有损失的情况下避免了下溢的问题。</li>
</ol>
<p>获取了统计概率信息后，我们便可以通过贝叶斯准则预测我们数据的类型了，这里我并没有直接计算每种情况的概率，而是通过统计得到的向量与数据向量进行内积获取条件概率的相对值并进行相对比较做出决策的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify</span><span class="params">(self, doc_vect, cond_probs, cls_probs)</span>:</span></div><div class="line">    <span class="string">''' 使用朴素贝叶斯将doc_vect进行分类.</span></div><div class="line">    '''</div><div class="line">    pred_probs = &#123;&#125;</div><div class="line">    <span class="keyword">for</span> cls, cls_prob <span class="keyword">in</span> cls_probs.items():</div><div class="line">        cond_prob_vect = cond_probs[cls]</div><div class="line">        pred_probs[cls] = np.sum(cond_prob_vect*doc_vect) + np.log(cls_prob)</div><div class="line">    <span class="keyword">return</span> max(pred_probs, key=pred_probs.get)</div></pre></td></tr></table></figure>
<h3 id="进行短信分类"><a href="#进行短信分类" class="headerlink" title="进行短信分类"></a>进行短信分类</h3><p>已经构建好了朴素贝叶斯模型，我们就可以使用此模型来统计数据并用来预测了。这里我使用了<a href="http://www.esp.uem.es/jmgomez/smsspamcorpus/" target="_blank" rel="external">SMS垃圾短信语料库</a>中的垃圾短信数据, 并随机抽取90%的数据作为训练数据，剩下10%的数据作为测试数据来测试我们的贝叶斯模型预测的准确性。</p>
<p>当然在建立模型前我们需要将数据处理成模型能够处理的格式:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">ENCODING = <span class="string">'ISO-8859-1'</span></div><div class="line">TRAIN_PERCENTAGE = <span class="number">0.9</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_doc_vector</span><span class="params">(words, vocabulary)</span>:</span></div><div class="line">    <span class="string">''' 根据词汇表将文档中的词条转换成文档向量</span></div><div class="line"></div><div class="line">    :param words: 文档中的词条列表</div><div class="line">    :type words: list of str</div><div class="line"></div><div class="line">    :param vocabulary: 总的词汇列表</div><div class="line">    :type vocabulary: list of str</div><div class="line"></div><div class="line">    :return doc_vect: 用于贝叶斯分析的文档向量</div><div class="line">    :type doc_vect: list of int</div><div class="line">    '''</div><div class="line">    doc_vect = [<span class="number">0</span>]*len(vocabulary)</div><div class="line"></div><div class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words:</div><div class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> vocabulary:</div><div class="line">            idx = vocabulary.index(word)</div><div class="line">            doc_vect[idx] = <span class="number">1</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> doc_vect</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_line</span><span class="params">(line)</span>:</span></div><div class="line">    <span class="string">''' 解析数据集中的每一行返回词条向量和短信类型.</span></div><div class="line">    '''</div><div class="line">    cls = line.split(<span class="string">','</span>)[<span class="number">-1</span>].strip()</div><div class="line">    content = <span class="string">','</span>.join(line.split(<span class="string">','</span>)[: <span class="number">-1</span>])</div><div class="line">    word_vect = [word.lower() <span class="keyword">for</span> word <span class="keyword">in</span> re.split(<span class="string">r'\W+'</span>, content) <span class="keyword">if</span> word]</div><div class="line">    <span class="keyword">return</span> word_vect, cls</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_file</span><span class="params">(filename)</span>:</span></div><div class="line">    <span class="string">''' 解析文件中的数据</span></div><div class="line">    '''</div><div class="line">    vocabulary, word_vects, classes = [], [], []</div><div class="line">    <span class="keyword">with</span> open(filename, <span class="string">'r'</span>, encoding=ENCODING) <span class="keyword">as</span> f:</div><div class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</div><div class="line">            <span class="keyword">if</span> line:</div><div class="line">                word_vect, cls = parse_line(line)</div><div class="line">                vocabulary.extend(word_vect)</div><div class="line">                word_vects.append(word_vect)</div><div class="line">                classes.append(cls)</div><div class="line">    vocabulary = list(set(vocabulary))</div><div class="line"></div><div class="line">    <span class="keyword">return</span> vocabulary, word_vects, classes</div></pre></td></tr></table></figure></p>
<p>有了上面三个函数我们就可以直接将我们的文本转换成模型需要的数据向量，之后我们就可以划分数据集并将训练数据集给贝叶斯模型进行统计。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 训练数据 &amp; 测试数据</span></div><div class="line">ntest = int(len(classes)*(<span class="number">1</span>-TRAIN_PERCENTAGE))</div><div class="line"></div><div class="line">test_word_vects = []</div><div class="line">test_classes = []</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(ntest):</div><div class="line">    idx = random.randint(<span class="number">0</span>, len(word_vects)<span class="number">-1</span>)</div><div class="line">    test_word_vects.append(word_vects.pop(idx))</div><div class="line">    test_classes.append(classes.pop(idx))</div><div class="line"></div><div class="line">train_word_vects = word_vects</div><div class="line">train_classes = classes</div><div class="line"></div><div class="line">train_dataset = [get_doc_vector(words, vocabulary) <span class="keyword">for</span> words <span class="keyword">in</span> train_word_vects]</div></pre></td></tr></table></figure></p>
<p>训练模型:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cond_probs, cls_probs = clf.train(train_dataset, train_classes)</div></pre></td></tr></table></figure></p>
<p>剩下我们用测试数据来测试我们贝叶斯模型的预测准确度:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 测试模型</span></div><div class="line">error = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> test_word_vect, test_cls <span class="keyword">in</span> zip(test_word_vects, test_classes):</div><div class="line">    test_data = get_doc_vector(test_word_vect, vocabulary)</div><div class="line">    pred_cls = clf.classify(test_data, cond_probs, cls_probs)</div><div class="line">    <span class="keyword">if</span> test_cls != pred_cls:</div><div class="line">        print(<span class="string">'Predict: &#123;&#125; -- Actual: &#123;&#125;'</span>.format(pred_cls, test_cls))</div><div class="line">        error += <span class="number">1</span></div><div class="line"></div><div class="line">print(<span class="string">'Error Rate: &#123;&#125;'</span>.format(error/len(test_classes)))</div></pre></td></tr></table></figure></p>
<p>随机测了四组，错误率分别为:0, 0.037, 0.015, 0. 平均错误率为1.3%</p>
<p>测完了我们尝试下看看不同类型短信各个词条的概率分布是怎样的吧:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 绘制不同类型的概率分布曲线</span></div><div class="line">fig = plt.figure()</div><div class="line">ax = fig.add_subplot(<span class="number">111</span>)</div><div class="line"><span class="keyword">for</span> cls, probs <span class="keyword">in</span> cond_probs.items():</div><div class="line">    ax.scatter(np.arange(<span class="number">0</span>, len(probs)),</div><div class="line">               probs*cls_probs[cls],</div><div class="line">               label=cls,</div><div class="line">               alpha=<span class="number">0.3</span>)</div><div class="line">    ax.legend()</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure></p>
<p><img src="/assets/images/blog_img/2017-07-11-机器学习实践-朴素贝叶斯-Naive-Bayes/distribution.png" alt=""></p>
<h3 id="试试决策树"><a href="#试试决策树" class="headerlink" title="试试决策树"></a>试试决策树</h3><p>上一篇我们基于ID3算法实现了决策树，同样是分类问题，我们同样可以使用我们的文本数据来构建用于分类短信的决策树，当然唯一比较麻烦的地方在于如果按照与贝叶斯相同的向量作为数据，则属性可能会非常多，我们在构建决策树的时候每层树结构都是递归通过遍历属性根据信息增益来选取最佳属性进行树分裂的，这样很多的属性可能会对构建决策树这一过程来说会比较耗时.那我们就试试吧…</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 生成决策树</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'sms_tree.pkl'</span>):</div><div class="line">    clf.create_tree(train_dataset, train_classes, vocabulary)</div><div class="line">    clf.dump_tree(<span class="string">'sms_tree.pkl'</span>)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    clf.load_tree(<span class="string">'sms_tree.pkl'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 测试模型</span></div><div class="line">error = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> test_word_vect, test_cls <span class="keyword">in</span> zip(test_word_vects, test_classes):</div><div class="line">    test_data = get_doc_vector(test_word_vect, vocabulary)</div><div class="line">    pred_cls = clf.classify(test_data, feat_names=vocabulary)</div><div class="line">    <span class="keyword">if</span> test_cls != pred_cls:</div><div class="line">        print(<span class="string">'Predict: &#123;&#125; -- Actual: &#123;&#125;'</span>.format(pred_cls, test_cls))</div><div class="line">        error += <span class="number">1</span></div><div class="line"></div><div class="line">print(<span class="string">'Error Rate: &#123;&#125;'</span>.format(error/len(test_classes)))</div></pre></td></tr></table></figure>
<p>随机测了两次，错误率分别为:0.09, 0.0</p>
<p>效果还算不错</p>
<p>我们还是用Graphviz可视化看一下决策树都选取了那些词条作为判别标准(这时候决策树的好处就体现出来了)。</p>
<p><img src="/assets/images/blog_img/2017-07-11-机器学习实践-朴素贝叶斯-Naive-Bayes/sms_tree_2.gif" alt=""><br><img src="/assets/images/blog_img/2017-07-11-机器学习实践-朴素贝叶斯-Naive-Bayes/sms_tree.gif" alt=""></p>
<p>可见决策树的深度并不是很深，如果分类类型一多，估计深度增加上去决策树可能会有些麻烦。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文我们使用Python一步步实现了朴素贝叶斯分类器，并对短信进行了垃圾短信过滤，同样的数据我们同决策树的分类效果进行了简单的比较。本文相关代码实现:<a href="https://github.com/PytLab/MLBox/tree/master/naive_bayes" target="_blank" rel="external">https://github.com/PytLab/MLBox/tree/master/naive_bayes</a> 。决策树过滤垃圾短信的脚本在<a href="https://github.com/PytLab/MLBox/tree/master/decision_tree" target="_blank" rel="external">https://github.com/PytLab/MLBox/tree/master/decision_tree</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Machine Learning in Action》</li>
<li><a href="http://blog.jobbole.com/111399/" target="_blank" rel="external">实例详解贝叶斯推理的原理</a></li>
<li><a href="http://blog.jobbole.com/105367/" target="_blank" rel="external">大道至简：朴素贝叶斯分类器</a></li>
</ul>
<h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><ul>
<li><a href="http://pytlab.org/2017/07/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5-%E5%86%B3%E7%AD%96%E6%A0%91/" target="_blank" rel="external">机器学习算法实践-决策树(Decision Tree)</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> MachineLearning </tag>
            
            <tag> NaiveBayes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习算法实践-决策树(Decision Tree)]]></title>
      <url>http://pytlab.github.io/2017/07/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5-%E5%86%B3%E7%AD%96%E6%A0%91/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近打算系统学习下机器学习的基础算法，避免眼高手低，决定把常用的机器学习基础算法都实现一遍以便加深印象。本文为这系列博客的第一篇，关于决策树(Decision Tree)的算法实现，文中我将对决策树种涉及到的算法进行总结并附上自己相关的实现代码。所有算法代码以及用于相应模型的训练的数据都会放到GitHub上(<a href="https://github.com/PytLab/MLBox" target="_blank" rel="external">https://github.com/PytLab/MLBox</a>).</p>
<p>本文中我将一步步通过MLiA的隐形眼镜处方数集构建决策树并使用Graphviz将决策树可视化。</p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="决策树学习"><a href="#决策树学习" class="headerlink" title="决策树学习"></a>决策树学习</h3><p>决策树学习是根据数据的属性采用树状结构建立的一种决策模型，可以用此模型解决分类和回归问题。常见的算法包括 CART(Classification And Regression Tree), ID3, C4.5等。我们往往根据数据集来构建一棵决策树，他的一个重要任务就是为了数据中所蕴含的知识信息，并提取出一系列的规则，这些规则也就是树结构的创建过程就是机器学习的过程。</p>
<h3 id="决策树的结构"><a href="#决策树的结构" class="headerlink" title="决策树的结构"></a>决策树的结构</h3><p>以下面一个简单的用于是否买电脑预测的决策树为例子，树中的内部节点表示某个属性，节点引出的分支表示此属性的所有可能的值，叶子节点表示最终的判断结果也就是类型。</p>
<p><img src="/assets/images/blog_img/2017-07-09-机器学习算法实践-决策树/tree-structure.jpg" alt=""></p>
<p>借助可视化工具例如Graphviz，matplotlib的注解等等都可以讲我们创建的决策树模型可视化并直接被人理解，这是贝叶斯神经网络等算法没有的特性。</p>
<h3 id="决策树算法"><a href="#决策树算法" class="headerlink" title="决策树算法"></a>决策树算法</h3><p>决策树算法主要是指决策树进行创建中进行树分裂(划分数据集)的时候选取最优特征的算法，他的主要目的就是要选取一个特征能够将分开的数据集尽量的规整，也就是尽可能的<strong>纯</strong>. 最大的原则就是: <strong>将无序的数据变得更加有序</strong></p>
<p>这里总结下三个常用的方法:</p>
<ol>
<li>信息增益(information gain)</li>
<li>增益比率(gain ratio)</li>
<li>基尼不纯度(Gini impurity)</li>
</ol>
<h4 id="信息增益-Information-gain"><a href="#信息增益-Information-gain" class="headerlink" title="信息增益 (Information gain)"></a>信息增益 (Information gain)</h4><p>这里涉及到了信息论中的一些概念：某个事件的信息量，信息熵，信息增益等, 关于事件信息的通俗解释可以看知乎上的一个<a href="https://www.zhihu.com/question/22178202/answer/49929786" target="_blank" rel="external">回答</a></p>
<ul>
<li><p>某个事件$i$的信息量: 这个事件发生的概率的负对数<br>  $$TI = -log(P(x_{i}))$$</p>
</li>
<li><p>信息熵就是平均而言一个事件发生得到的信息量大小，也就是信息量的期望值<br>  $$ H = \sum_{i=1}^{n}H(x_{i}) = -\sum_{i=1}^{n}P(x_{i})log(P(x_{i})) $$</p>
<p>  任何一个序列都可以获取这个序列的信息熵，也就是将此序列分类后统计每个类型的概率，再用上述公式计算，使用Python实现如下:</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_shanno_entropy</span><span class="params">(self, values)</span>:</span></div><div class="line">    <span class="string">''' 根据给定列表中的值计算其Shanno Entropy</span></div><div class="line">    '''</div><div class="line">    uniq_vals = set(values)</div><div class="line">    val_nums = &#123;key: values.count(key) <span class="keyword">for</span> key <span class="keyword">in</span> uniq_vals&#125;</div><div class="line">    probs = [v/len(values) <span class="keyword">for</span> k, v <span class="keyword">in</span> val_nums.items()]</div><div class="line">    entropy = sum([-prob*log2(prob) <span class="keyword">for</span> prob <span class="keyword">in</span> probs])</div><div class="line">    <span class="keyword">return</span> entropy</div></pre></td></tr></table></figure>
</li>
<li><p>信息增益<br>  我们将一组数据集进行划分后，数据的信息熵会发生改变，我们可以通过使用信息熵的计算公式分别计算被划分的子数据集的信息熵并计算他们的平均值(期望值)来作为分割后的数据集的信息熵。新的信息熵的相比未划分数据的信息熵的减小值便是<strong>信息增益</strong>了. 这里我在最初就理解错了，于是写出的代码并不能创建正确的决策树。<br>  假设我们将数据集$D$划分成$k$份${D_{1}, D_{2}, … , D_{k}}$，则划分后的信息熵为:<br>  $$ H_{splited} = \sum_{j=1}^{k}P(D_{j})H(D_{j}) = \sum_{j=1}^{k} \frac{len(D_{j})}{len(D)} H(D_{j}) $$<br>  信息增益便是两个信息熵的插值<br>  $$ Gain_{splited} = H - H_{splited} $$</p>
<p>  在这里我主要使用信息增益来进行属性选择，具体的实现代码如下:</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose_best_split_feature</span><span class="params">(self, dataset, classes)</span>:</span></div><div class="line">    <span class="string">''' 根据信息增益确定最好的划分数据的特征</span></div><div class="line"></div><div class="line">    :param dataset: 待划分的数据集</div><div class="line">    :param classes: 数据集对应的类型</div><div class="line"></div><div class="line">    :return: 划分数据的增益最大的属性索引</div><div class="line">    '''</div><div class="line">    base_entropy = self.get_shanno_entropy(classes)</div><div class="line"></div><div class="line">    feat_num = len(dataset[<span class="number">0</span>])</div><div class="line">    entropy_gains = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(feat_num):</div><div class="line">        splited_dict = self.split_dataset(dataset, classes, i)</div><div class="line">        new_entropy = sum([</div><div class="line">            len(sub_classes)/len(classes)*self.get_shanno_entropy(sub_classes)</div><div class="line">            <span class="keyword">for</span> _, (_, sub_classes) <span class="keyword">in</span> splited_dict.items()</div><div class="line">        ])</div><div class="line">        entropy_gains.append(base_entropy - new_entropy)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> entropy_gains.index(max(entropy_gains))</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="增益比率"><a href="#增益比率" class="headerlink" title="增益比率"></a>增益比率</h4><p>增益比率是信息增益方法的一种扩展，是为了克服信息增益带来的弱泛化的缺陷。因为按照信息增益选择，总是会倾向于选择分支多的属性，这样会是的每个子集的信息熵最小。例如给每个数据添加一个第一无二的id值特征，则按照这个id值进行分类是获得信息增益最大的，这样每个子集中的信息熵都为0，但是这样的分类便没有任何意义，没有任何泛化能力，类似过拟合。</p>
<p>因此我们可以通过引入一个分裂信息来找到一个更合适的衡量数据划分的标准，即增益比率。</p>
<p>分裂信息的公式表示为:<br>$$<br>SplitInfo(D) = \sum_{j=1}^{k} \frac{len(D_{j})}{len(D)} log(\frac{len(D_{j})}{len(D)})<br>$$<br>可见如果数据分的越多，分裂信息的值就会越大</p>
<p>这时候把分裂信息的值放到分母上便会中和信息增益带来的弊端。</p>
<p>$$ GianRatio = \frac{Gain}{SplitInfo} $$</p>
<p>当然SplitInfo有可能趋近于0，这个时候增益比率就会变得非常大而不可信，因此有时还需在分母上添加一个平滑函数，具体的可以参考参考部分列出的文章</p>
<h4 id="基尼不纯度-Gini-impurity"><a href="#基尼不纯度-Gini-impurity" class="headerlink" title="基尼不纯度(Gini impurity)"></a>基尼不纯度(Gini impurity)</h4><p>基尼不纯度的定义:<br>$$ I_{G}(D) = 1 - \sum_{i=1}^{m}p_{i}^{2} $$<br>其中$m$表示数据集$D$中类别的个数, $p_{i}$表示某种类型出现的概率。可见当只有一种类型的时候基尼不纯度的值为0，此时不纯度最低。</p>
<p>针对划分成k个子数据集的数据集的基尼不纯度可以通过如下式子计算:<br>$$ I_{G}^{splited}(D) = \sum_{j=1}^{k} \frac{len(D_{j})}{len(D)}I_{G}(D))$$</p>
<p>由此我们可以根据不纯度的变化来选取最有的树分裂属性</p>
<p>$$ \Delta I_{G} = I_{G} - I_{G}^{splited} $$</p>
<h3 id="树分裂"><a href="#树分裂" class="headerlink" title="树分裂"></a>树分裂</h3><p>有了选取最佳分裂属性的算法，下面我们就需要根据选择的属性来将树进一步的分裂。所谓树分裂只不过是根据选择的属性将数据集划分，然后在总划分出来的数据集中再次调用选取属性的方法选取子数据集的中属性。实现的最好方式就是递归了.</p>
<p>关于用什么数据结构来表示决策树，在Python中可以使用字典很方便的表示决策树的嵌套，一个树的根节点便是属性，属性对应的值又是一个新的字典，其中key为属性的可能值，value为新的子树。</p>
<p>下面是我使用Python实现的根据数据集创建决策树：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_tree</span><span class="params">(self, dataset, classes, feat_names)</span>:</span></div><div class="line">    <span class="string">''' 根据当前数据集递归创建决策树</span></div><div class="line"></div><div class="line">    :param dataset: 数据集</div><div class="line">    :param feat_names: 数据集中数据相应的特征名称</div><div class="line">    :param classes: 数据集中数据相应的类型</div><div class="line"></div><div class="line">    :param tree: 以字典形式返回决策树</div><div class="line">    '''</div><div class="line">    <span class="comment"># 如果数据集中只有一种类型停止树分裂</span></div><div class="line">    <span class="keyword">if</span> len(set(classes)) == <span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> classes[<span class="number">0</span>]</div><div class="line"></div><div class="line">    <span class="comment"># 如果遍历完所有特征，返回比例最多的类型</span></div><div class="line">    <span class="keyword">if</span> len(feat_names) == <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> get_majority(classes)</div><div class="line"></div><div class="line">    <span class="comment"># 分裂创建新的子树</span></div><div class="line">    tree = &#123;&#125;</div><div class="line">    best_feat_idx = self.choose_best_split_feature(dataset, classes)</div><div class="line">    feature = feat_names[best_feat_idx]</div><div class="line">    tree[feature] = &#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment"># 创建用于递归创建子树的子数据集</span></div><div class="line">    sub_feat_names = feat_names[:]</div><div class="line">    sub_feat_names.pop(best_feat_idx)</div><div class="line"></div><div class="line">    splited_dict = self.split_dataset(dataset, classes, best_feat_idx)</div><div class="line">    <span class="keyword">for</span> feat_val, (sub_dataset, sub_classes) <span class="keyword">in</span> splited_dict.items():</div><div class="line">        tree[feature][feat_val] = self.create_tree(sub_dataset,</div><div class="line">                                                   sub_classes,</div><div class="line">                                                   sub_feat_names)</div><div class="line">    self.tree = tree</div><div class="line">    self.feat_names = feat_names</div><div class="line"></div><div class="line">    <span class="keyword">return</span> tree</div></pre></td></tr></table></figure></p>
<p>树分裂的终止条件有两个</p>
<ul>
<li><p>一个是遍历完所有的属性<br>  可以看到，在进行树分裂的时候，我们的数据集中的数据向量的长度是不断缩短的，当缩短到0时，说明数据集已经将所有的属性用尽，便也分裂不下去了, 这时我们选取最终子数据集中的众数作为最终的分类结果放到叶子节点上.</p>
</li>
<li><p>另一个是新划分的数据集中只有一个类型。<br> 若某个节点所指向的数据集都是同一种类型，那自然没有必要在分裂下去了即使属性还没有遍历完.</p>
</li>
</ul>
<h3 id="构建一棵决策树"><a href="#构建一棵决策树" class="headerlink" title="构建一棵决策树"></a>构建一棵决策树</h3><p>这我用了一下MLiA书上附带的隐形眼镜的数据来生成一棵决策树，数据中包含了患者眼部状况以及医生推荐的隐形眼镜类型.</p>
<p>首先先导入数据并将数据特征同类型分开作为训练数据用于生成决策树<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> trees <span class="keyword">import</span> DecisionTreeClassifier</div><div class="line"></div><div class="line">lense_labels = [<span class="string">'age'</span>, <span class="string">'prescript'</span>, <span class="string">'astigmatic'</span>, <span class="string">'tearRate'</span>]</div><div class="line">X = []</div><div class="line">Y = []</div><div class="line"></div><div class="line"><span class="keyword">with</span> open(<span class="string">'lenses.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</div><div class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</div><div class="line">        comps = line.strip().split(<span class="string">'\t'</span>)</div><div class="line">        X.append(comps[: <span class="number">-1</span>])</div><div class="line">        Y.append(comps[<span class="number">-1</span>])</div></pre></td></tr></table></figure></p>
<p>生成决策树:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">clf = DecisionTreeClassifier()</div><div class="line">clf.create_tree(X, Y, lense_labels)</div></pre></td></tr></table></figure>
<p>查看生成的决策树:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">2</span>]: clf.tree</div><div class="line">Out[<span class="number">2</span>]:</div><div class="line">&#123;<span class="string">'tearRate'</span>: &#123;<span class="string">'normal'</span>: &#123;<span class="string">'astigmatic'</span>: &#123;<span class="string">'no'</span>: &#123;<span class="string">'age'</span>: &#123;<span class="string">'pre'</span>: <span class="string">'soft'</span>,</div><div class="line">      <span class="string">'presbyopic'</span>: &#123;<span class="string">'prescript'</span>: &#123;<span class="string">'hyper'</span>: <span class="string">'soft'</span>, <span class="string">'myope'</span>: <span class="string">'no lenses'</span>&#125;&#125;,</div><div class="line">            <span class="string">'young'</span>: <span class="string">'soft'</span>&#125;&#125;,</div><div class="line">    <span class="string">'yes'</span>: &#123;<span class="string">'prescript'</span>: &#123;<span class="string">'hyper'</span>: &#123;<span class="string">'age'</span>: &#123;<span class="string">'pre'</span>: <span class="string">'no lenses'</span>,</div><div class="line">                <span class="string">'presbyopic'</span>: <span class="string">'no lenses'</span>,</div><div class="line">                        <span class="string">'young'</span>: <span class="string">'hard'</span>&#125;&#125;,</div><div class="line">          <span class="string">'myope'</span>: <span class="string">'hard'</span>&#125;&#125;&#125;&#125;,</div><div class="line">  <span class="string">'reduced'</span>: <span class="string">'no lenses'</span>&#125;&#125;</div></pre></td></tr></table></figure>
<h3 id="可视化决策树"><a href="#可视化决策树" class="headerlink" title="可视化决策树"></a>可视化决策树</h3><p>直接通过嵌套字典表示决策树对人来说不好理解，我们需要借助可视化工具可视化树结构，这里我将使用Graphviz来可视化树结构。为此实现了讲字典表示的树生成Graphviz Dot文件内容的函数，大致思想就是递归获取整棵树的所有节点和连接节点的边然后将这些节点和边生成Dot格式的字符串写入文件中并绘图。</p>
<p>递归获取树的节点和边，其中使用了uuid给每个节点添加了id属性以便将相同属性的节点区分开.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_nodes_edges</span><span class="params">(self, tree=None, root_node=None)</span>:</span></div><div class="line">    <span class="string">''' 返回树中所有节点和边</span></div><div class="line">    '''</div><div class="line">    Node = namedtuple(<span class="string">'Node'</span>, [<span class="string">'id'</span>, <span class="string">'label'</span>])</div><div class="line">    Edge = namedtuple(<span class="string">'Edge'</span>, [<span class="string">'start'</span>, <span class="string">'end'</span>, <span class="string">'label'</span>])</div><div class="line"></div><div class="line">    <span class="keyword">if</span> tree <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        tree = self.tree</div><div class="line"></div><div class="line">    <span class="keyword">if</span> type(tree) <span class="keyword">is</span> <span class="keyword">not</span> dict:</div><div class="line">        <span class="keyword">return</span> [], []</div><div class="line"></div><div class="line">    nodes, edges = [], []</div><div class="line"></div><div class="line">    <span class="keyword">if</span> root_node <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        label = list(tree.keys())[<span class="number">0</span>]</div><div class="line">        root_node = Node._make([uuid.uuid4(), label])</div><div class="line">        nodes.append(root_node)</div><div class="line"></div><div class="line">    <span class="keyword">for</span> edge_label, sub_tree <span class="keyword">in</span> tree[root_node.label].items():</div><div class="line">        node_label = list(sub_tree.keys())[<span class="number">0</span>] <span class="keyword">if</span> type(sub_tree) <span class="keyword">is</span> dict <span class="keyword">else</span> sub_tree</div><div class="line">        sub_node = Node._make([uuid.uuid4(), node_label])</div><div class="line">        nodes.append(sub_node)</div><div class="line"></div><div class="line">        edge = Edge._make([root_node, sub_node, edge_label])</div><div class="line">        edges.append(edge)</div><div class="line"></div><div class="line">        sub_nodes, sub_edges = self.get_nodes_edges(sub_tree, root_node=sub_node)</div><div class="line">        nodes.extend(sub_nodes)</div><div class="line">        edges.extend(sub_edges)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> nodes, edges</div></pre></td></tr></table></figure>
<p>生成dot文件内容</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dotify</span><span class="params">(self, tree=None)</span>:</span></div><div class="line">    <span class="string">''' 获取树的Graphviz Dot文件的内容</span></div><div class="line">    '''</div><div class="line">    <span class="keyword">if</span> tree <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        tree = self.tree</div><div class="line"></div><div class="line">    content = <span class="string">'digraph decision_tree &#123;\n'</span></div><div class="line">    nodes, edges = self.get_nodes_edges(tree)</div><div class="line"></div><div class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</div><div class="line">        content += <span class="string">'    "&#123;&#125;" [label="&#123;&#125;"];\n'</span>.format(node.id, node.label)</div><div class="line"></div><div class="line">    <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</div><div class="line">        start, label, end = edge.start, edge.label, edge.end</div><div class="line">        content += <span class="string">'    "&#123;&#125;" -&gt; "&#123;&#125;" [label="&#123;&#125;"];\n'</span>.format(start.id, end.id, label)</div><div class="line">    content += <span class="string">'&#125;'</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> content</div></pre></td></tr></table></figure>
<p>隐形眼镜数据生成Dot文件内容如下:<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">digraph decision_tree &#123;</div><div class="line">    <span class="string">"959b4c0c-1821-446d-94a1-c619c2decfcd"</span> [<span class="keyword">label</span><span class="bash">=<span class="string">"call"</span>];</span></div><div class="line">    <span class="string">"18665160-b058-437f-9b2e-05df2eb55661"</span> [<span class="keyword">label</span><span class="bash">=<span class="string">"to"</span>];</span></div><div class="line">    <span class="string">"2eb9860d-d241-45ca-85e6-cbd80fe2ebf7"</span> [<span class="keyword">label</span><span class="bash">=<span class="string">"your"</span>];</span></div><div class="line">    <span class="string">"bcbcc17c-9e2a-4bd4-a039-6e51fde5f8fd"</span> [<span class="keyword">label</span><span class="bash">=<span class="string">"areyouunique"</span>];</span></div><div class="line">    <span class="string">"ca091fc7-8a4e-4970-9ec3-485a4628ad29"</span> [<span class="keyword">label</span><span class="bash">=<span class="string">"02073162414"</span>];</span></div><div class="line">    <span class="string">"aac20872-1aac-499d-b2b5-caf0ef56eff3"</span> [<span class="keyword">label</span><span class="bash">=<span class="string">"ham"</span>];</span></div><div class="line">    <span class="string">"18aa8685-a6e8-4d76-bad5-ccea922bb14d"</span> [<span class="keyword">label</span><span class="bash">=<span class="string">"spam"</span>];</span></div><div class="line">    <span class="string">"3f7f30b1-4dbb-4459-9f25-358ad3c6d50b"</span> [<span class="keyword">label</span><span class="bash">=<span class="string">"spam"</span>];</span></div><div class="line">    <span class="string">"44d1f972-cd97-4636-b6e6-a389bf560656"</span> [<span class="keyword">label</span><span class="bash">=<span class="string">"spam"</span>];</span></div><div class="line">    <span class="string">"7f3c8562-69b5-47a9-8ee4-898bd4b6b506"</span> [<span class="keyword">label</span><span class="bash">=<span class="string">"i"</span>];</span></div><div class="line">    <span class="string">"a6f22325-8841-4a81-bc04-4e7485117aa1"</span> [<span class="keyword">label</span><span class="bash">=<span class="string">"spam"</span>];</span></div><div class="line">    <span class="string">"c181fe42-fd3c-48db-968a-502f8dd462a4"</span> [<span class="keyword">label</span><span class="bash">=<span class="string">"ldn"</span>];</span></div><div class="line">    <span class="string">"51b9477a-0326-4774-8622-24d1d869a283"</span> [<span class="keyword">label</span><span class="bash">=<span class="string">"ham"</span>];</span></div><div class="line">    <span class="string">"16f6aecd-c675-4291-867c-6c64d27eb3fc"</span> [<span class="keyword">label</span><span class="bash">=<span class="string">"spam"</span>];</span></div><div class="line">    <span class="string">"adb05303-813a-4fe0-bf98-c319eb70be48"</span> [<span class="keyword">label</span><span class="bash">=<span class="string">"spam"</span>];</span></div><div class="line">    <span class="string">"959b4c0c-1821-446d-94a1-c619c2decfcd"</span> -&gt; <span class="string">"18665160-b058-437f-9b2e-05df2eb55661"</span> [<span class="keyword">label</span><span class="bash">=<span class="string">"0"</span>];</span></div><div class="line">    <span class="string">"18665160-b058-437f-9b2e-05df2eb55661"</span> -&gt; <span class="string">"2eb9860d-d241-45ca-85e6-cbd80fe2ebf7"</span> [<span class="keyword">label</span><span class="bash">=<span class="string">"0"</span>];</span></div><div class="line">    <span class="string">"2eb9860d-d241-45ca-85e6-cbd80fe2ebf7"</span> -&gt; <span class="string">"bcbcc17c-9e2a-4bd4-a039-6e51fde5f8fd"</span> [<span class="keyword">label</span><span class="bash">=<span class="string">"0"</span>];</span></div><div class="line">    <span class="string">"bcbcc17c-9e2a-4bd4-a039-6e51fde5f8fd"</span> -&gt; <span class="string">"ca091fc7-8a4e-4970-9ec3-485a4628ad29"</span> [<span class="keyword">label</span><span class="bash">=<span class="string">"0"</span>];</span></div><div class="line">    <span class="string">"ca091fc7-8a4e-4970-9ec3-485a4628ad29"</span> -&gt; <span class="string">"aac20872-1aac-499d-b2b5-caf0ef56eff3"</span> [<span class="keyword">label</span><span class="bash">=<span class="string">"0"</span>];</span></div><div class="line">    <span class="string">"ca091fc7-8a4e-4970-9ec3-485a4628ad29"</span> -&gt; <span class="string">"18aa8685-a6e8-4d76-bad5-ccea922bb14d"</span> [<span class="keyword">label</span><span class="bash">=<span class="string">"1"</span>];</span></div><div class="line">    <span class="string">"bcbcc17c-9e2a-4bd4-a039-6e51fde5f8fd"</span> -&gt; <span class="string">"3f7f30b1-4dbb-4459-9f25-358ad3c6d50b"</span> [<span class="keyword">label</span><span class="bash">=<span class="string">"1"</span>];</span></div><div class="line">    <span class="string">"2eb9860d-d241-45ca-85e6-cbd80fe2ebf7"</span> -&gt; <span class="string">"44d1f972-cd97-4636-b6e6-a389bf560656"</span> [<span class="keyword">label</span><span class="bash">=<span class="string">"1"</span>];</span></div><div class="line">    <span class="string">"18665160-b058-437f-9b2e-05df2eb55661"</span> -&gt; <span class="string">"7f3c8562-69b5-47a9-8ee4-898bd4b6b506"</span> [<span class="keyword">label</span><span class="bash">=<span class="string">"1"</span>];</span></div><div class="line">    <span class="string">"7f3c8562-69b5-47a9-8ee4-898bd4b6b506"</span> -&gt; <span class="string">"a6f22325-8841-4a81-bc04-4e7485117aa1"</span> [<span class="keyword">label</span><span class="bash">=<span class="string">"0"</span>];</span></div><div class="line">    <span class="string">"7f3c8562-69b5-47a9-8ee4-898bd4b6b506"</span> -&gt; <span class="string">"c181fe42-fd3c-48db-968a-502f8dd462a4"</span> [<span class="keyword">label</span><span class="bash">=<span class="string">"1"</span>];</span></div><div class="line">    <span class="string">"c181fe42-fd3c-48db-968a-502f8dd462a4"</span> -&gt; <span class="string">"51b9477a-0326-4774-8622-24d1d869a283"</span> [<span class="keyword">label</span><span class="bash">=<span class="string">"0"</span>];</span></div><div class="line">    <span class="string">"c181fe42-fd3c-48db-968a-502f8dd462a4"</span> -&gt; <span class="string">"16f6aecd-c675-4291-867c-6c64d27eb3fc"</span> [<span class="keyword">label</span><span class="bash">=<span class="string">"1"</span>];</span></div><div class="line">    <span class="string">"959b4c0c-1821-446d-94a1-c619c2decfcd"</span> -&gt; <span class="string">"adb05303-813a-4fe0-bf98-c319eb70be48"</span> [<span class="keyword">label</span><span class="bash">=<span class="string">"1"</span>];</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样我们便可以使用Graphviz将决策树绘制出来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(<span class="string">'lenses.dot'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</div><div class="line">    dot = clf.tree.dotify()</div><div class="line">    f.write(dot)</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">dot</span> <span class="selector-tag">-Tgif</span> <span class="selector-tag">lenses</span><span class="selector-class">.dot</span> <span class="selector-tag">-o</span> <span class="selector-tag">lenses</span><span class="selector-class">.gif</span></div></pre></td></tr></table></figure>
<p>效果如下:<br><img src="/assets/images/blog_img/2017-07-09-机器学习算法实践-决策树/lenses.gif" alt=""></p>
<h3 id="使用生成的决策树进行分类"><a href="#使用生成的决策树进行分类" class="headerlink" title="使用生成的决策树进行分类"></a>使用生成的决策树进行分类</h3><p>对未知数据进行预测，主要是根据树中的节点递归的找到叶子节点即可。z这里可以通过为递归进行优化，代码实现如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify</span><span class="params">(self, data_vect, feat_names=None, tree=None)</span>:</span></div><div class="line">    <span class="string">''' 根据构建的决策树对数据进行分类</span></div><div class="line">    '''</div><div class="line">    <span class="keyword">if</span> tree <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        tree = self.tree</div><div class="line"></div><div class="line">    <span class="keyword">if</span> feat_names <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        feat_names = self.feat_names</div><div class="line"></div><div class="line">    <span class="comment"># Recursive base case.</span></div><div class="line">    <span class="keyword">if</span> type(tree) <span class="keyword">is</span> <span class="keyword">not</span> dict:</div><div class="line">        <span class="keyword">return</span> tree</div><div class="line"></div><div class="line">    feature = list(tree.keys())[<span class="number">0</span>]</div><div class="line">    value = data_vect[feat_names.index(feature)]</div><div class="line">    sub_tree = tree[feature][value]</div><div class="line"></div><div class="line">    <span class="keyword">return</span> self.classify(feat_names, data_vect, sub_tree)</div></pre></td></tr></table></figure></p>
<h3 id="决策树的存储"><a href="#决策树的存储" class="headerlink" title="决策树的存储"></a>决策树的存储</h3><p>通过字典表示决策树，这样我们可以通过内置的pickle或者json模块将其存储到硬盘上，同时也可以从硬盘中读取树结构，这样在数据集很大的时候可以节省构建决策树的时间.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dump_tree</span><span class="params">(self, filename, tree=None)</span>:</span></div><div class="line">    <span class="string">''' 存储决策树</span></div><div class="line">    '''</div><div class="line">    <span class="keyword">if</span> tree <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        tree = self.tree</div><div class="line"></div><div class="line">    <span class="keyword">with</span> open(filename, <span class="string">'w'</span>) <span class="keyword">as</span> f:</div><div class="line">        pickle.dump(tree, f)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_tree</span><span class="params">(self, filename)</span>:</span></div><div class="line">    <span class="string">''' 加载树结构</span></div><div class="line">    '''</div><div class="line">    <span class="keyword">with</span> open(filename, <span class="string">'r'</span>) <span class="keyword">as</span> f:</div><div class="line">        tree = pickle.load(f)</div><div class="line">        self.tree = tree</div><div class="line">    <span class="keyword">return</span> tree</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文一步步实现了决策树的实现, 其中使用了ID3算法确定最佳划分属性，并通过Graphviz可视化了构建的决策树。本文相关的代码链接: <a href="https://github.com/PytLab/MLBox/tree/master/decision_tree" target="_blank" rel="external">https://github.com/PytLab/MLBox/tree/master/decision_tree</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><ul>
<li>《Machine Learning in Action》</li>
<li><a href="http://www.cnblogs.com/fengfenggirl/p/classsify_decision_tree.html" target="_blank" rel="external">数据挖掘系列（6）决策树分类算法</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> MachineLearning </tag>
            
            <tag> DecisionTree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[KinLab - 基于Flask+Bootstrap实现的用于微观动力学计算的web应用]]></title>
      <url>http://pytlab.github.io/2017/07/04/KinLab-%E5%9F%BA%E4%BA%8EFlask-Bootstrap%E5%AE%9E%E7%8E%B0%E5%BE%AE%E8%A7%82%E5%8A%A8%E5%8A%9B%E5%AD%A6%E8%AE%A1%E7%AE%97%E7%9A%84web%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>前两周花了些时间给自己的动力学程序Kynetix和KMCLibX写了个web界面方便别人使用，目前程序完成了计算微观动力学的部分，并部署在了腾讯云上<a href="http://123.206.225.154:5000/" target="_blank" rel="external">http://123.206.225.154:5000/</a>, 程序命名为KinLab (<a href="https://github.com/PytLab/kynetix-webapp" target="_blank" rel="external">https://github.com/PytLab/kynetix-webapp</a>).</p>
<p>目前KinLab主要包含四个部分:</p>
<ol>
<li>文件系统</li>
<li>模型定义</li>
<li>模型计算<br>生成结果报告</li>
</ol>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>文件系统这里我模仿jupyternotebook写的，因为着急实现主要的计算过程，这里一些常用的文件操作还没实现(后续有时间会加上)，正常可以在任何路径下创建或者打开一个作业设置界面。<br><a id="more"></a><br><img src="/assets/images/blog_img/2017-07-04-使用Flask实现微观动力学计算的web应用/filestree.png" alt=""></p>
<p>同时在文件系统中可以查看文本文件的内容，若是非文本文件则会进行下载，其中代码高亮使用了rainbow插件显示。</p>
<p><img src="/assets/images/blog_img/2017-07-04-使用Flask实现微观动力学计算的web应用/filecontent.png" alt=""></p>
<h2 id="模型创建"><a href="#模型创建" class="headerlink" title="模型创建"></a>模型创建</h2><p>在创建模型的时候，程序会判断当前路径下是否已经存在模型相关的文件，如果存在则会打开现有的模型，否则创建一个空的设置面板。</p>
<p><img src="/assets/images/blog_img/2017-07-04-使用Flask实现微观动力学计算的web应用/openjob.png" alt=""></p>
<p>模型设置面板的界面如下:</p>
<p><img src="/assets/images/blog_img/2017-07-04-使用Flask实现微观动力学计算的web应用/model-panel.png" alt=""></p>
<h3 id="添加基元反应方程式"><a href="#添加基元反应方程式" class="headerlink" title="添加基元反应方程式"></a>添加基元反应方程式</h3><p>根据有无能垒的反应，可以自行选择，一下以包含能垒的反应式为例:</p>
<p><img src="/assets/images/blog_img/2017-07-04-使用Flask实现微观动力学计算的web应用/choose-rxn.png" alt=""></p>
<p>创建基元反应的弹窗，为了能对基元反应进行检测，我特地把化学方程式解析的部分独立出来成一个模块rxn-parser.js(<a href="https://github.com/PytLab/rxn-parser.js" target="_blank" rel="external">https://github.com/PytLab/rxn-parser.js</a>)</p>
<p><img src="/assets/images/blog_img/2017-07-04-使用Flask实现微观动力学计算的web应用/rxn-modal.png" alt=""></p>
<h3 id="反应式存档"><a href="#反应式存档" class="headerlink" title="反应式存档"></a>反应式存档</h3><p>通过单击<code>save</code>可以将方程式信息保存到当前路径下</p>
<p><img src="/assets/images/blog_img/2017-07-04-使用Flask实现微观动力学计算的web应用/rxn-save.png" alt=""></p>
<h3 id="绘制energy-profile"><a href="#绘制energy-profile" class="headerlink" title="绘制energy-profile"></a>绘制energy-profile</h3><p>当选中一个或者多个基元反应的时候，便可以绘制交互式的energy profile</p>
<p><img src="/assets/images/blog_img/2017-07-04-使用Flask实现微观动力学计算的web应用/energy-profile.png" alt=""></p>
<p>其他相关功能在使用时可以进行尝试</p>
<h3 id="模型参数"><a href="#模型参数" class="headerlink" title="模型参数"></a>模型参数</h3><p>模型参数便是常用的求解微观动力学的参数，这里需要注意的是在添加好基元反应后，通过<code>Load</code>程序可以解析反应式中的物种并生成压强和总覆盖度表单。</p>
<p><img src="/assets/images/blog_img/2017-07-04-使用Flask实现微观动力学计算的web应用/load-pressure.png" alt=""></p>
<h2 id="作业计算"><a href="#作业计算" class="headerlink" title="作业计算"></a>作业计算</h2><p>设置好模型后便可以<code>Run</code>了。程序会打开Running界面，并实时显示作业生成的日志</p>
<p><img src="/assets/images/blog_img/2017-07-04-使用Flask实现微观动力学计算的web应用/running.png" alt=""></p>
<h2 id="生成结果报告"><a href="#生成结果报告" class="headerlink" title="生成结果报告"></a>生成结果报告</h2><p>报告会以图标和表格的方式显示:</p>
<p>其中包括ODE积分的轨迹图，稳态覆盖度，TOF以及可逆度。</p>
<p><img src="/assets/images/blog_img/2017-07-04-使用Flask实现微观动力学计算的web应用/report.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 代码作品 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> chemistry </tag>
            
            <tag> catalyst </tag>
            
            <tag> jQuery </tag>
            
            <tag> webapp </tag>
            
            <tag> javascript </tag>
            
            <tag> KinLab </tag>
            
            <tag> kynetix </tag>
            
            <tag> bootstrap </tag>
            
            <tag> flask </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[编写Bootstrap插件的步骤]]></title>
      <url>http://pytlab.github.io/2017/06/18/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AABootstrap%E7%9A%84JS%E6%8F%92%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>最近在给自己的动力学模拟程序写个web界面，目前采用了bootstrap + flask的组合, 看了下bootstrap的一些组件样式和内置的插件的使用，在实现自己的网站的时候肯定会有自己的需求，于是需要开发或者扩展Bootstrap插件，这里就总结下开发Bootstrap插件的步骤。</p>
<p>Bootstrap插件本质上就是一个jQuery插件,除了将插件函数绑定到jQuery的原型对象上以外，Bootstrap还需要遵守一些其他的额外的步骤方便维护和学习等。</p>
<a id="more"></a>
<h2 id="Bootstrap的JS插件的实现步骤"><a href="#Bootstrap的JS插件的实现步骤" class="headerlink" title="Bootstrap的JS插件的实现步骤"></a>Bootstrap的JS插件的实现步骤</h2><h3 id="1-声明立即调用函数"><a href="#1-声明立即调用函数" class="headerlink" title="1. 声明立即调用函数"></a>1. 声明立即调用函数</h3><p>这个就和开发jQuery插件相同，是为了在文档加载完之后执行回调函数, 类似<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>但是为了避免与其他库的命名冲突，Bootstrap里统一使用这种方式:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</div><div class="line">    <span class="string">"use restrict"</span>;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;)(jQuery)</div></pre></td></tr></table></figure></p>
<h3 id="2-定义插件核心类以及相关的原型方法"><a href="#2-定义插件核心类以及相关的原型方法" class="headerlink" title="2. 定义插件核心类以及相关的原型方法"></a>2. 定义插件核心类以及相关的原型方法</h3><p>通过定义插件类，我们能够将选择器获取的元素以及操作元素的接口都封装到类中。这样Bootstrap插件实际上都是核心类的原型方法的调用。</p>
<h3 id="3-定义jQuery插件并重设插件构造函数"><a href="#3-定义jQuery插件并重设插件构造函数" class="headerlink" title="3. 定义jQuery插件并重设插件构造函数"></a>3. 定义jQuery插件并重设插件构造函数</h3><p>这一步是在上一步已经定义好操作jQuery对象的接口的基础上的，我们定义一个jQuery插件(就是一个js函数绑定到jQuery原型<code>jQuery.fn</code>上)。执行这个插件的过程就是将第2步插件类实例化并绑定到相应元素和判断执行相应原型方法的过程。</p>
<h3 id="4-防冲突处理"><a href="#4-防冲突处理" class="headerlink" title="4. 防冲突处理"></a>4. 防冲突处理</h3><p>毕竟是自定义插件，难免有可能会与空间中定义好的其他插件重名造成冲突，这个时候我们需要写一个函数可以将插件的名称还给原始的插件。这部分比较固定，一般是这样处理:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 例如我的插件名叫form_status</span></div><div class="line"></div><div class="line"><span class="comment">// 将初始的插件先保存下来</span></div><div class="line"><span class="keyword">var</span> old = $.fn.form_status</div><div class="line"></div><div class="line"><span class="comment">// 定义一个放冲突函数，可以将原始的插件对象归还回来</span></div><div class="line">$.fn.form_status.noConflict = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    $.fn.form_status = old;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="5-绑定触发事件"><a href="#5-绑定触发事件" class="headerlink" title="5. 绑定触发事件"></a>5. 绑定触发事件</h3><p>在前面4步以后已经可以通过js直接调用插件实现相应效果，这里的事件绑定主要是针对Bootstrap的HTML声明式的事件触发。</p>
<h2 id="插件开发实例"><a href="#插件开发实例" class="headerlink" title="插件开发实例"></a>插件开发实例</h2><p>这里我就以一个简单用于我自己web应用的一个现实表单状态现实的Bootstrap插件的开发为例子说明下。</p>
<ol>
<li><p>声明立即调用函数</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">; (<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</div><div class="line">    <span class="string">"use restrict"</span>;</div><div class="line">&#125;)(<span class="built_in">window</span>.jQuery);</div></pre></td></tr></table></figure>
</li>
<li><p>定义插件类</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Define FormStatus class */</span></div><div class="line"><span class="keyword">var</span> FormStatus = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.$element = $(element);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">FormStatus.DEFAULTS = &#123;</div><div class="line">    <span class="attr">show</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">status</span>: <span class="string">'error'</span>,</div><div class="line">    <span class="attr">msg</span>: <span class="string">'Error!'</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p> 这里主要是定义类构造函数，已经类属性用于存放默认参数。属性中包含相应的元素的jQuery对象，可以在原型方法中方便的操作相应的元素.</p>
<p> 然后我们需要定义用于操作绑定元素的接口：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Prototype methods.</span></div><div class="line">FormStatus.prototype.show = <span class="function"><span class="keyword">function</span>(<span class="params">option</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> wrapper = <span class="string">'&lt;div class="form-group has-'</span> + option.status + <span class="string">'"&gt;&lt;/div&gt;'</span>;</div><div class="line">    <span class="keyword">this</span>.$element.wrap(wrapper);</div><div class="line">    <span class="keyword">var</span> msg_element = <span class="string">'&lt;label class="control-label"&gt;'</span> + option.msg + <span class="string">'&lt;/label&gt;'</span>;</div><div class="line">    <span class="keyword">this</span>.$element.before(msg_element);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">FormStatus.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params">option</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.$element.parent(<span class="string">'form-group'</span>)) &#123;</div><div class="line">        <span class="keyword">this</span>.$element.unwrap();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.$element.prev(<span class="string">'label.control-label'</span>).remove();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>创建form_status jQuery插件</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// New jQuery plugin.</span></div><div class="line"><span class="keyword">var</span> old = $.fn.form_status;</div><div class="line">$.fn.form_status = <span class="function"><span class="keyword">function</span>(<span class="params">option</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> $<span class="keyword">this</span> = $(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">var</span> data = $<span class="keyword">this</span>.data(<span class="string">'bs.form_status'</span>);</div><div class="line"></div><div class="line">        <span class="comment">// Merge options.</span></div><div class="line">        <span class="keyword">var</span> options = $.extend(&#123;&#125;, FormStatus.DEFAULTS, option);</div><div class="line"></div><div class="line">        <span class="comment">// Bind FormStatus instance to element.</span></div><div class="line">        <span class="keyword">if</span> (!data) &#123;</div><div class="line">            $<span class="keyword">this</span>.data(<span class="string">'bs.form_status'</span>, (data = <span class="keyword">new</span> FormStatus(<span class="keyword">this</span>)));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Call corresponding prototype methods.</span></div><div class="line">        <span class="keyword">if</span> (options.remove) &#123;</div><div class="line">            data.remove(options);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.show) &#123;</div><div class="line">            data.show(options);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;;</div><div class="line">$.fn.form_status.Constructor = FormStatus;</div></pre></td></tr></table></figure>
<p> 可以见到我们将插件类的实例绑定到了元素的<code>bs.form_status</code>属性中，当我们调用<code>$(selector).form_status(options)</code>的时候便会根据传入的参数选择调用原型方法。</p>
</li>
<li><p>防冲突处理</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// No conflict.</span></div><div class="line">$.fn.form_status.noConflict = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    $.fn.form_status = old;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>触发事件绑定<br> 由于我不是很喜欢HTML声明式调用，于是我就没有写相应的绑定事件，绑定会在js中单独编写就好了。</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是开发一个Bootstrap插件的过程。主要是如何编写插件类已经绑定jQuery插件，插件类是为了封装操作接口，jQuery插件用于调用接口操作元素对象。我自己开发的代码都放在GitHub上:<a href="https://github.com/PytLab/kynetix-webapp" target="_blank" rel="external">https://github.com/PytLab/kynetix-webapp</a></p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Bootstrap </tag>
            
            <tag> jQuery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[算法分析中的渐近记号总结]]></title>
      <url>http://pytlab.github.io/2017/06/03/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%AD%E7%9A%84%E6%B8%90%E8%BF%9B%E8%AE%B0%E5%8F%B7%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>最近在看算导决定抽空把算法基础在夯实一遍, 算法相关的实现代码时不时会丢到<a href="https://github.com/PytLab/ALGO" target="_blank" rel="external">GitHub</a>上，主要以C++实现，也会有相应的Python和Javascript的实现。</p>
<p>在这里，作为算法的渐近分析的标准方法之一，对几种渐近记号进行下总结.</p>
<h2 id="渐近记号"><a href="#渐近记号" class="headerlink" title="渐近记号"></a>渐近记号</h2><p>所有的渐近记号都表示一个函数的集合.</p>
<a id="more"></a>
<h3 id="Theta-记号"><a href="#Theta-记号" class="headerlink" title="$\Theta$ 记号"></a>$\Theta$ 记号</h3><p>$\Theta$ 记号表示一个函数的渐近紧确界，同时包含了渐近上界和渐近下界。</p>
<p>通常对于$\Theta$ 的一种非形式化的概念，我们通过去掉低阶项并忽略最高项的系数来获取其紧确界的函数形式。</p>
<p>来看下他的严格定义, 对于一个给定的函数$g(n)$, 我们用$\Theta(g(n))$ 表示这样的一个函数集合:</p>
<blockquote>
<p>$\Theta(g(n)) = \{f(n):$ 存在正常量 $c_{1}$、 $c_{2}$ 和 $n_{0}$, 使得对所有 $n &gt; n_{0}$, 有 $0 \leq c_{1}g(n) \leq f(n) \leq c_{2}g(n)\}$</p>
</blockquote>
<h3 id="O-记号"><a href="#O-记号" class="headerlink" title="$O$ 记号"></a>$O$ 记号</h3><p>$O$ 记号是一个比 $\Theta$ 记号更弱的概念，他只表示一个函数的渐近上界, 也就是最坏的运行时间。</p>
<p>对于一个给定的函数$g(n)$, 我们用$O(g(n))$ 表示这样的一个函数集合:</p>
<blockquote>
<p>$O(g(n)) = \{f(n): $ 存在正常量 $c$和$n_{0}$, 使得对所有 $n \geq n_{0}$, 有 $0 \leq f(n) \leq cg(n) \}$</p>
</blockquote>
<p>有时候$O$记号非形式化的表示一个函数的渐近紧确界，也就是$\Theta$记号表示的集合, 这也是为什么有时候看到$n = O(n^{2})$会感觉不对.</p>
<h3 id="Omega-记号"><a href="#Omega-记号" class="headerlink" title="$\Omega$ 记号"></a>$\Omega$ 记号</h3><p>类似 $O$ 记号，$\Omega$ 记号表示的是一个函数的渐近下界，也就是最好的运行时间</p>
<p>对于一个给定的函数$g(n)$, 我们用$\Omega(g(n))$ 表示这样的一个函数集合:</p>
<blockquote>
<p>$\Omega(g(n)) = \{f(n): $ 存在正常量 $c$和$n_{0}$, 使得对所有 $n \geq n_{0}$, 有 $0 \leq cg(n) \leq f(n) \}$</p>
</blockquote>
<h3 id="o-记号"><a href="#o-记号" class="headerlink" title="$o$ 记号"></a>$o$ 记号</h3><p>$O$ 记号表示的是一个函数的渐近上界，但是可能是渐近紧确界也可能不是，例如$3n^{2} = O(n^{2})$ 中 $O$ 表示的就是紧确上界，而 $n = O(n^{2})$ 中的 $O(n^{2})$ 便不是紧确上界. $o$ 记号就表示非紧确界的情况, 即 $2n = o(n^{2})$ 但是 $2n^{2} \neq o(n^{2})$ </p>
<p>写下定义吧, 对于一个给定的函数 $g(n)$, 我们用 $o(g(n))$ 表示这样一个函数集合:</p>
<blockquote>
<p>$o(g(n)) = \{f(n):$ 对<strong>任意常量</strong> $c &gt; 0$, 存在常量 $n_{0}$, 使得对所有 $n \geq n_{0}$, 有 $0 \leq f(n) \leq cg(n)\}$</p>
</blockquote>
<p>直观上来看，在 $o$ 记号中, 当 $n$ 趋近于无穷大时， 函数 $f(n)$ 的值会远小于 $g(n)$ 的值, 即</p>
<p>$${\lim_{x \to \infty}} \frac{f(n)}{g(n)} = 0$$</p>
<h3 id="omega-记号"><a href="#omega-记号" class="headerlink" title="$\omega$ 记号"></a>$\omega$ 记号</h3><p>类似 $o$ 与 $O$ 的关系类似, $\omega$ 记号用来表示一个非渐近紧确下界。 它的定义:</p>
<blockquote>
<p>$\omega(g(n)) = \{f(n): $ 对<strong>任意正常量</strong> $c &gt; 0$, 存在常量 $n_{0} &gt; 0$, 使得对所有 $n \geq n_{0}$, 有 $0 \leq cg(n) \leq f(n) \}$</p>
</blockquote>
<p>类似 $o$ 记号， $\omega$ 记号也有</p>
<p>$${\lim_{x \to \infty}} \frac{g(n)}{f(n)} = 0$$</p>
<h2 id="渐近记号的比较"><a href="#渐近记号的比较" class="headerlink" title="渐近记号的比较"></a>渐近记号的比较</h2><p>假定 $f(n)$ 和 $g(n)$ 都渐近为正.</p>
<h3 id="传递性"><a href="#传递性" class="headerlink" title="传递性"></a>传递性</h3><ul>
<li>$f(n) = \Theta(g(n))$ 且 $g(n) = \Theta(h(n))$ 则 $f(n) = \Theta(h(n))$</li>
<li>$f(n) = O(g(n))$ 且 $g(n) = O(h(n))$ 则 $f(n) = O(h(n))$</li>
<li>$f(n) = \Omega(g(n))$ 且 $g(n) = \Omega(h(n))$ 则 $f(n) = \Omega(h(n))$</li>
<li>$f(n) = o(g(n))$ 且 $g(n) = o(h(n))$ 则 $f(n) = o(h(n))$</li>
<li>$f(n) = \omega(g(n))$ 且 $g(n) = \omega(h(n))$ 则 $f(n) = \omega(h(n))$</li>
</ul>
<h3 id="自反性"><a href="#自反性" class="headerlink" title="自反性"></a>自反性</h3><ul>
<li>$f(n) = \Theta(f(n))$</li>
<li>$f(n) = O(f(n))$</li>
<li>$f(n) = \Omega(f(n))$</li>
</ul>
<h3 id="对称性"><a href="#对称性" class="headerlink" title="对称性"></a>对称性</h3><ul>
<li>$f(n) = \Theta(g(n))$ 当且仅当 $g(n) = \Theta(f(n))$</li>
</ul>
<h3 id="转置对称性"><a href="#转置对称性" class="headerlink" title="转置对称性"></a>转置对称性</h3><ul>
<li>$f(n) = O(g(n))$ 当且仅当 $g(n) = \Omega(f(n))$</li>
<li>$f(n) = o(g(n))$ 当且仅当 $g(n) = \omega(f(n))$</li>
</ul>
<h3 id="渐近比较和实数比较的类比"><a href="#渐近比较和实数比较的类比" class="headerlink" title="渐近比较和实数比较的类比"></a>渐近比较和实数比较的类比</h3><ul>
<li>$f(n) = \Theta(g(n))$ 类似于 $a = b$, $f(n)$ 渐近等于 $g(n)$</li>
<li>$f(n) = O(g(n))$ 类似于 $a \leq b$, $f(n)$ 渐近小于等于 $g(n)$</li>
<li>$f(n) = \Omega(g(n))$ 类似于 $a \geq b$, $f(n)$ 渐近大于等于 $g(n)$</li>
<li>$f(n) = o(g(n))$ 类似于 $a &lt; b$, $f(n)$ 渐近小于 $g(n)$</li>
<li>$f(n) = \omega(g(n))$ 类似于 $a &gt; b$, $f(n)$ 渐近大于 $g(n)$</li>
</ul>
<h3 id="三分性-不一定成立"><a href="#三分性-不一定成立" class="headerlink" title="三分性 不一定成立"></a>三分性 <strong>不一定成立</strong></h3><p>对于值会来回摆动的函数三分性便不成立，例如:</p>
<p>$n^{1+sin(n)} \neq O(n)$ 且 $n^{1+sin(n)} \neq \Omega(n)$</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithms </tag>
            
            <tag> 渐近记号 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于matplotlib的2D/3D抽象网格和能量曲线绘制程序]]></title>
      <url>http://pytlab.github.io/2017/04/25/%E5%9F%BA%E4%BA%8Ematplotlib%E5%86%99%E4%B8%80%E4%B8%AA2D-3D%E6%8A%BD%E8%B1%A1%E7%BD%91%E6%A0%BC%E5%92%8C%E8%83%BD%E9%87%8F%E6%9B%B2%E7%BA%BF%E7%BB%98%E5%88%B6%E7%A8%8B%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在写文章需要绘制一些一维的能量曲线(energy profile)和抽象的二维和三维的网格来表示晶体用来描述自己的算法，于是自己在之前的脚本的基础上进行了整改写成了只提供接口的Python库,基本思想就是封装了matplotlib中相关接口，方便快速搭建和定制自己的能量曲线和网格结构, 代码托管在GitHub上并上传至PyPI。对于研究晶体材料的同学如果想通过python来绘制简单的晶格图像可以参考一下。</p>
<ul>
<li>GitHub地址: <a href="https://github.com/PytLab/catplot/" target="_blank" rel="external">https://github.com/PytLab/catplot/</a></li>
<li>PyPI地址: <a href="https://pypi.python.org/pypi/catplot/" target="_blank" rel="external">https://pypi.python.org/pypi/catplot/</a></li>
</ul>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>首先还是介绍一下这个程序的用途，目前主要是提供三个主要的模块来绘制三方面的内容：</p>
<h4 id="1-绘制抽象的二维网格结构"><a href="#1-绘制抽象的二维网格结构" class="headerlink" title="1. 绘制抽象的二维网格结构"></a>1. 绘制抽象的二维网格结构</h4><p>catplot提供了丰富的接口用来定制所需要的任何二维网格并进行周期性扩展，如下图是一个通过当个重复单元扩展出来的抽象(100)晶面的二维网格结构:<br><img src="/assets/images/blog_img/2017-04-25-基于matplotlib写一个2D-3D抽象网格和能量曲线绘制程序/2d-grid-example.png" alt=""></p>
<h4 id="2-绘制抽象的三维网格结构"><a href="#2-绘制抽象的三维网格结构" class="headerlink" title="2. 绘制抽象的三维网格结构"></a>2. 绘制抽象的三维网格结构</h4><p>同理只不过这次是在三维画布中进行绘制并进行重复单元的周期性扩展，扩展的效果如下图:<br><img src="/assets/images/blog_img/2017-04-25-基于matplotlib写一个2D-3D抽象网格和能量曲线绘制程序/grid_3d.png" alt=""></p>
<h4 id="3-通过插值算法实现绘制”顺滑”的energy-profile"><a href="#3-通过插值算法实现绘制”顺滑”的energy-profile" class="headerlink" title="3. 通过插值算法实现绘制”顺滑”的energy profile"></a>3. 通过插值算法实现绘制”顺滑”的energy profile</h4><p><img src="/assets/images/blog_img/2017-04-25-基于matplotlib写一个2D-3D抽象网格和能量曲线绘制程序/energy-profile-example.png" alt=""></p>
<p>实现过程基本是通过对matplotlib提供的绘图组件和接口进一步封装成可以快速搭建上面三个类型图像的组件。</p>
<h3 id="采用二次插值结合样条插值方法绘制-energy-profile"><a href="#采用二次插值结合样条插值方法绘制-energy-profile" class="headerlink" title="采用二次插值结合样条插值方法绘制 energy profile"></a>采用二次插值结合样条插值方法绘制 energy profile</h3><p>energy profile可以理解成在势能面(Potential Energy Surface)上沿着某个特定的方向(反应坐标方向)上能量的变化，</p>
<p>下面我就上一个简单的例子来画一条顺滑的energy profile, 更多具体的例子我都已经jupyter notebook的形式放在的github上(<a href="https://github.com/PytLab/catplot/tree/master/examples" target="_blank" rel="external">https://github.com/PytLab/catplot/tree/master/examples</a>)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 从catplot中导入绘制所需的组件: 画布 和 线</span></div><div class="line"><span class="keyword">from</span> catplot.ep_components.ep_canvas <span class="keyword">import</span> EPCanvas</div><div class="line"><span class="keyword">from</span> catplot.ep_components.ep_lines <span class="keyword">import</span> ElementaryLine</div><div class="line"></div><div class="line"><span class="comment"># 创建一个用于绘制energy profile的画布</span></div><div class="line">canvas = EPCanvas()</div><div class="line"></div><div class="line"><span class="comment"># 创建一条能量曲线，提供的三个值分别是三个状态下的能量数值</span></div><div class="line">line = ElementaryLine([<span class="number">0.0</span>, <span class="number">1.2</span>, <span class="number">0.8</span>])</div><div class="line"></div><div class="line"><span class="comment"># 将这条线添加到画布中</span></div><div class="line">canvas.add_line(line)</div><div class="line"></div><div class="line"><span class="comment"># 绘制</span></div><div class="line">canvas.draw()</div><div class="line">canvas.figure.show()</div></pre></td></tr></table></figure>
<h4 id="插值方法"><a href="#插值方法" class="headerlink" title="插值方法"></a>插值方法</h4><p>为了能将能量最高点沿着横坐标任意位置移动，我先将顶点的两边用二次函数进行插值，获取两个不同的二次函数形式，然后根据二次函数的形式在左右两边插上5个点，为了能让分开插值的两部分看起来连续，在将上面的10个新插的点和之前的3个点进行一次spline插值即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 顶点两侧进行二次插值的算法</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">quadratic_connect_interp</span><span class="params">(x1, y1, x2, y2)</span>:</span></div><div class="line">    A = np.matrix([[x1**<span class="number">2</span>, x1, <span class="number">1</span>],</div><div class="line">                   [x2**<span class="number">2</span>, x2, <span class="number">1</span>],</div><div class="line">                   [<span class="number">2</span>*x2, <span class="number">1</span>, <span class="number">0</span>]])</div><div class="line"></div><div class="line">    b = np.matrix([[y1], [y2], [<span class="number">0</span>]])</div><div class="line">    x = A.I * b</div><div class="line">    x.shape = (<span class="number">1</span>, <span class="number">-1</span>)</div><div class="line">    a, b, c = x.tolist()[<span class="number">0</span>]</div><div class="line"></div><div class="line">    poly_func = <span class="keyword">lambda</span> x: a*x**<span class="number">2</span> + b*x + c</div><div class="line"></div><div class="line">    <span class="keyword">return</span> poly_func</div></pre></td></tr></table></figure>
<p><img src="/assets/images/blog_img/2017-04-25-基于matplotlib写一个2D-3D抽象网格和能量曲线绘制程序/interpolation.png" alt=""></p>
<p>与插值相关的方法参考:<a href="https://github.com/PytLab/catplot/blob/master/catplot/interpolate.py" target="_blank" rel="external">https://github.com/PytLab/catplot/blob/master/catplot/interpolate.py</a></p>
<h4 id="丰富的接口"><a href="#丰富的接口" class="headerlink" title="丰富的接口"></a>丰富的接口</h4><p>除了上面最简单的例子，catplot还提供了丰富的接口来定制和操作energy profile，比如拼接，合并，平移，添加阴影、改变颜色, 辅助线， 修改画布大小，导出插值数据等等。具体的例子参考: <a href="https://github.com/PytLab/catplot/tree/master/examples" target="_blank" rel="external">https://github.com/PytLab/catplot/tree/master/examples</a></p>
<p><img src="/assets/images/blog_img/2017-04-25-基于matplotlib写一个2D-3D抽象网格和能量曲线绘制程序/energy-profile-examples.png" alt=""></p>
<h3 id="绘制二维和三维抽象网格"><a href="#绘制二维和三维抽象网格" class="headerlink" title="绘制二维和三维抽象网格"></a>绘制二维和三维抽象网格</h3><p>晶格中的原子和键在catplot中被抽象成图中的node和edge，这样我们就可以通过创建图中的node和edge的方式搭建我们网格的重复单元，之后可以通过重复单元的扩展方法来将其扩展成nxn或者nxnxn的网格。</p>
<p>实现的基本方法就是通过matplotlib提供的Line2D, Arrow和scatter相关的接口来将相应node和edge的数据添加到maptlotlib的二维或者三维画布中然后进行绘制和显示。下面给分别给出两个绘制正交网格的绘制方法:</p>
<h4 id="绘制5x5的二维网格"><a href="#绘制5x5的二维网格" class="headerlink" title="绘制5x5的二维网格"></a>绘制5x5的二维网格</h4><p>notebook版可以参见：<a href="https://github.com/PytLab/catplot/blob/master/examples/grid_2d_examples/expand_supercell.ipynb" target="_blank" rel="external">https://github.com/PytLab/catplot/blob/master/examples/grid_2d_examples/expand_supercell.ipynb</a></p>
<p>创建nodes和edges</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> catplot.grid_components.nodes <span class="keyword">import</span> Node2D</div><div class="line"><span class="keyword">from</span> catplot.grid_components.edges <span class="keyword">import</span> Edge2D</div><div class="line"></div><div class="line">nodes, edges = [], []</div><div class="line"></div><div class="line"><span class="comment"># 创建重复单元中的nodes和edge</span></div><div class="line">top = Node2D([<span class="number">0.0</span>, <span class="number">0.0</span>], size=<span class="number">800</span>, color=<span class="string">"#2A6A9C"</span>)</div><div class="line">t1 = Node2D([<span class="number">0.0</span>, <span class="number">1.0</span>])</div><div class="line">t2 = Node2D([<span class="number">1.0</span>, <span class="number">0.0</span>])</div><div class="line">nodes.append(top)</div><div class="line"></div><div class="line"><span class="comment"># 链接这三个node的edges</span></div><div class="line">e1 = Edge2D(top, t1, width=<span class="number">4</span>)</div><div class="line">e2 = Edge2D(top, t2, width=<span class="number">4</span>)</div><div class="line">edges.extend([e1, e2])</div><div class="line"></div><div class="line"><span class="comment"># 中间的nodes</span></div><div class="line">bridge1 = Node2D([<span class="number">0.0</span>, <span class="number">0.5</span>], style=<span class="string">"s"</span>, size=<span class="number">600</span>, color=<span class="string">"#5A5A5A"</span>, alpha=<span class="number">0.6</span>)</div><div class="line">bridge2 = Node2D([<span class="number">0.5</span>, <span class="number">0.0</span>], style=<span class="string">"s"</span>, size=<span class="number">600</span>, color=<span class="string">"#5A5A5A"</span>, alpha=<span class="number">0.6</span>)</div><div class="line">b1 = bridge1.clone([<span class="number">0.5</span>, <span class="number">0.5</span>])</div><div class="line">b2 = bridge2.clone([<span class="number">0.5</span>, <span class="number">0.5</span>])</div><div class="line">nodes.extend([bridge1, bridge2])</div><div class="line"></div><div class="line"><span class="comment"># 连接他们的edges</span></div><div class="line">e1 = Edge2D(bridge1, b1)</div><div class="line">e2 = Edge2D(bridge1, bridge2)</div><div class="line">e3 = Edge2D(bridge2, b2)</div><div class="line">e4 = Edge2D(b1, b2)</div><div class="line">edges.extend([e1, e2, e3, e4])</div><div class="line"></div><div class="line"><span class="comment"># 正中间的node</span></div><div class="line">h = Node2D([<span class="number">0.5</span>, <span class="number">0.5</span>], style=<span class="string">"h"</span>, size=<span class="number">700</span>, color=<span class="string">"#5A5A5A"</span>, alpha=<span class="number">0.3</span>)</div><div class="line">nodes.append(h)</div></pre></td></tr></table></figure>
<p>好了，现在我们就创建一个重复单元中的所需的所有元素，可以绘制一下看看效果了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> catplot.grid_components.grid_canvas <span class="keyword">import</span> Grid2DCanvas</div><div class="line"><span class="keyword">from</span> catplot.grid_components.supercell <span class="keyword">import</span> SuperCell2D</div><div class="line"></div><div class="line">canvas = Grid2DCanvas()</div><div class="line"><span class="comment"># 将上面的元素放到supercell中，后面我们将一supercell为单位进行展开</span></div><div class="line">supercell = SuperCell2D(nodes, edges)</div><div class="line"></div><div class="line"><span class="comment"># 绘制效果</span></div><div class="line">canvas.add_supercell(supercell)</div><div class="line">canvas.draw()</div><div class="line">canvas.figure</div></pre></td></tr></table></figure>
<p><img src="/assets/images/blog_img/2017-04-25-基于matplotlib写一个2D-3D抽象网格和能量曲线绘制程序/2d-unitcell.png" alt=""></p>
<p>OK, 重复单元已经搭建成功，可以以他为单位进行扩展了, 下面我们将其沿着x和y轴方向各进行5次重复扩展。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 很简单，就一行代码</span></div><div class="line">expanded_supercell = supercell.expand(<span class="number">5</span>, <span class="number">5</span>)</div></pre></td></tr></table></figure>
<p>来看看效果:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">canvas_big = Grid2DCanvas(figsize=(<span class="number">30</span>, <span class="number">20</span>), dpi=<span class="number">60</span>)  <span class="comment"># 定制画布大小</span></div><div class="line">canvas_big.add_supercell(expanded_supercell)</div><div class="line">canvas_big.draw()</div><div class="line">canvas_big.figure</div></pre></td></tr></table></figure>
<p><img src="/assets/images/blog_img/2017-04-25-基于matplotlib写一个2D-3D抽象网格和能量曲线绘制程序/5x5-grid.png" alt=""></p>
<p>是不是很直观和简单呢？</p>
<h3 id="绘制三维网格"><a href="#绘制三维网格" class="headerlink" title="绘制三维网格"></a>绘制三维网格</h3><p>绘制三维网格，catplot中我都写了与二维绘制中相对应的类和接口，这里就不赘述了，可以参考项目中的examples: <a href="https://github.com/PytLab/catplot/tree/master/examples/grid_3d_examples/expand_3d_supercell.ipynb" target="_blank" rel="external">https://github.com/PytLab/catplot/tree/master/examples/grid_3d_examples/expand_3d_supercell.ipynb</a></p>
<h3 id="是不是只能画正交的网格？"><a href="#是不是只能画正交的网格？" class="headerlink" title="是不是只能画正交的网格？"></a>是不是只能画正交的网格？</h3><p>怎么可能，虽然所有的坐标都是在分数坐标系中定义的，但是在SuperCell类中我添加了分数坐标到笛卡尔坐标的转化，从而可以使得catplot绘制任意的网格。来个例子就知道了:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 创建nodes和edges的代码与上面的部分完全相同</span></div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment"># 但是我们在定义supercell的时候可以修改cell_vectors参数来是重复单元发生形变</span></div><div class="line">supercell = SuperCell2D(nodes, edges, cell_vectors=[[<span class="number">1.0</span>, <span class="number">0.0</span>],</div><div class="line">                                                    [<span class="number">0.5</span>, <span class="number">1.0</span>]])</div><div class="line">canvas.add_supercell(supercell)</div><div class="line">canvas.draw()</div><div class="line">canvas.figure.show()</div></pre></td></tr></table></figure></p>
<p>来我们看看这时候的重复单元是什么样子:</p>
<p><img src="/assets/images/blog_img/2017-04-25-基于matplotlib写一个2D-3D抽象网格和能量曲线绘制程序/2d-unitcell-cv.png" alt=""></p>
<p>然后我们再将其进行一次3x3的扩展看看</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">expanded_supercell = supercell.expand(<span class="number">3</span>, <span class="number">3</span>)</div><div class="line">canvas_big = Grid2DCanvas(figsize=(<span class="number">30</span>, <span class="number">20</span>), dpi=<span class="number">60</span>)</div><div class="line">canvas_big.add_supercell(expanded_supercell)</div><div class="line">canvas_big.draw()</div><div class="line">canvas_big.figure.show()</div></pre></td></tr></table></figure>
<p><img src="/assets/images/blog_img/2017-04-25-基于matplotlib写一个2D-3D抽象网格和能量曲线绘制程序/3x3-grid.png" alt=""></p>
<p>所以基本上现在所有类型的晶格都可以通过CatPlot来绘制了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本来catplot这个库最初是自己用matplotlib来绘图的小脚本，由于现在写论文的情况下需要灵活的绘制网格图，所以进行了重写，现在写成了一个封装了matplotlib的python库方便使用者可以快速搭建自己想要的网格图和绘制漂亮的energy profile。代码和具体使用的notebook格式的例子均开源并放到了github上 (<a href="https://github.com/PytLab/catplot" target="_blank" rel="external">https://github.com/PytLab/catplot</a> )，欢迎有需要的童鞋参考和使用。</p>
]]></content>
      
        <categories>
            
            <category> 代码作品 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> matplotlib </tag>
            
            <tag> catalyst </tag>
            
            <tag> energy profile </tag>
            
            <tag> graph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[优雅的在终端中编写Python]]></title>
      <url>http://pytlab.github.io/2017/03/26/%E4%BC%98%E9%9B%85%E7%9A%84%E5%9C%A8%E7%BB%88%E7%AB%AF%E4%B8%AD%E7%BC%96%E5%86%99Python/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最早我也只是在服务器上编辑文件的时候用用vim来改改程序，并没有把vim当做自己的主力编辑器。但是偶然的一次机会需要改一个奇葩的输入文件的格式，用了下Vim的宏录制，尝到了甜头，于是后面就开始用Vim来写程序了，虽然使用初期有些阻力，但时间久了就会发现，双手再也不用离开键盘，即使使用sublime这样的编辑器我也要改成使用Vim模式，Vim真的能让自己一思维的速度编辑文本(对我来说就是写程序了)。</p>
<p>正好最近换了新的电脑，需要在新电脑上配置一下，就干脆把一些配置相关的东东记录下来吧，相关的配置文件我都放在了github(<a href="https://github.com/PytLab/dotfiles" target="_blank" rel="external">https://github.com/PytLab/dotfiles</a>) 上并写了相应的安装和卸载脚本，给有需要的同学做个参考吧。</p>
<p>本文是有关配置的文章，并不对Vim的核心技巧进行说明，有需要的童鞋可以参考文档和相关书籍。这里主要配合tmux和vim可以更有优雅的帮助我们在终端中进行Python编程。</p>
<a id="more"></a>
<p>先来个大致的效果图吧:</p>
<p><img src="/assets/images/blog_img/2017-03-26-优雅的在终端中编写Python/vim-screeshot.png" alt=""></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="终端窗口管理工具Tmux"><a href="#终端窗口管理工具Tmux" class="headerlink" title="终端窗口管理工具Tmux"></a>终端窗口管理工具Tmux</h3><p>首先还是需要配置下tmux，它除了可以进行多window多panel以外最主要的是他提供了窗口组随时存储和恢复的功能。也可以帮助我们在一个窗口中使用多个panel一边使用vim一边在ipython中进行测试。</p>
<p>tmux的配置文件是当前用户主目录下的<code>.tmux.conf</code>文件，启动tmux时会自动加载，也可以通过在tmux中进行加载例如<code>&lt;prefix&gt; : source ~/.tmux.conf</code>。</p>
<p>完整的配置文件参见: <a href="https://github.com/PytLab/dotfiles/blob/master/.tmux.conf" target="_blank" rel="external">https://github.com/PytLab/dotfiles/blob/master/.tmux.conf</a></p>
<h4 id="修改快捷键前缀"><a href="#修改快捷键前缀" class="headerlink" title="修改快捷键前缀"></a>修改快捷键前缀</h4><p>关于tmux的配置比较简单，我先把快捷键的前缀从<code>Ctrl-b</code>换成了<code>Ctrl-l</code>，主要是根据个人喜好，因为这样左手<code>Ctrl</code>右手<code>l</code>个人觉得比较方便。</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># <span class="keyword">Set</span> tmux <span class="comment">prefix to &lt;C-a&gt;</span></div><div class="line"><span class="keyword">set</span> <span class="comment">-g prefix C-l</span></div><div class="line">unbind <span class="comment">C-b</span></div></pre></td></tr></table></figure>
<h4 id="修改分屏快捷键"><a href="#修改分屏快捷键" class="headerlink" title="修改分屏快捷键"></a>修改分屏快捷键</h4><p>tmux的分屏快捷键默认值为:</p>
<ul>
<li><code>&lt;prefix&gt; + &quot;</code> 水平分屏</li>
<li><code>&lt;prefix&gt; + %</code> 垂直分屏</li>
</ul>
<p>感觉好奇怪，我就改成了相对直观的方式:</p>
<ul>
<li><code>&lt;prefix&gt; + |</code>, 类似在屏幕上加一条处置线</li>
<li><code>&lt;prefix&gt; + -</code>, 类似在屏幕上加一条水平线</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Split pane.</span></div><div class="line">unbind <span class="string">'"'</span></div><div class="line"><span class="built_in">bind</span> | splitw -h</div><div class="line">unbind <span class="string">'%'</span></div><div class="line"><span class="built_in">bind</span> - splitw -v</div></pre></td></tr></table></figure>
<h4 id="将复制模式改为vim的复制模式"><a href="#将复制模式改为vim的复制模式" class="headerlink" title="将复制模式改为vim的复制模式"></a>将复制模式改为vim的复制模式</h4><p>由于使用vim习惯了而且不想在去碰鼠标，tmux也是可以将复制模式修改成同Vim相同的方式，只是操作的前缀不同罢了。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># Copy <span class="keyword">mode</span></div><div class="line"># <span class="keyword">copy</span>-<span class="keyword">mode</span> <span class="keyword">to</span> <span class="keyword">vi</span> <span class="keyword">mode</span></div><div class="line">setw -g <span class="keyword">mode</span>-<span class="built_in">keys</span> <span class="keyword">vi</span></div><div class="line"># enter <span class="keyword">copy</span> <span class="keyword">mode</span></div><div class="line">bind Escape <span class="keyword">copy</span>-<span class="keyword">mode</span></div><div class="line"># paste <span class="keyword">buffer</span></div><div class="line">bind C-<span class="keyword">p</span> pasteb</div><div class="line"># select (v)</div><div class="line">bind -t <span class="keyword">vi</span>-<span class="keyword">copy</span> v begin-selection</div><div class="line"># <span class="keyword">copy</span> (<span class="keyword">y</span>)</div><div class="line">bind -t <span class="keyword">vi</span>-<span class="keyword">copy</span> <span class="keyword">y</span> <span class="keyword">copy</span>-selection</div></pre></td></tr></table></figure>
<h4 id="绑定面板切换快捷键"><a href="#绑定面板切换快捷键" class="headerlink" title="绑定面板切换快捷键"></a>绑定面板切换快捷键</h4><p>这里面板切换上，我将面板的上下左右方向绑定到了kjhl四个同Vim中光标移动一样的四个键上同Vim保持一致，这样就不需要在记住新的方向键了。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># Map panel switch.</span></div><div class="line"><span class="meta"># Up</span></div><div class="line">bind-<span class="built_in">key</span> k <span class="built_in">select</span>-pane -U</div><div class="line"><span class="meta"># Down</span></div><div class="line">bind-<span class="built_in">key</span> j <span class="built_in">select</span>-pane -D</div><div class="line"><span class="meta"># left</span></div><div class="line">bind-<span class="built_in">key</span> h <span class="built_in">select</span>-pane -L</div><div class="line"><span class="meta"># right</span></div><div class="line">bind-<span class="built_in">key</span> l <span class="built_in">select</span>-pane -R</div></pre></td></tr></table></figure>
<h4 id="修改面板大小的快捷键"><a href="#修改面板大小的快捷键" class="headerlink" title="修改面板大小的快捷键"></a>修改面板大小的快捷键</h4><p>这里为了能够将大小更灵活的移动，我将鼠标控制打开，这样就能通过鼠标进行方便精准的面板大小调整了。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># Resize panel size.</div><div class="line">bind &lt; <span class="keyword">resize</span>-pane -L <span class="number">10</span></div><div class="line">bind &gt; <span class="keyword">resize</span>-pane -R <span class="number">10</span></div><div class="line">bind _ <span class="keyword">resize</span>-pane -D <span class="number">10</span></div><div class="line">bind + <span class="keyword">resize</span>-pane -U <span class="number">10</span></div><div class="line"></div><div class="line"># Use mouse <span class="keyword">to</span> <span class="keyword">resize</span> panel.</div><div class="line"><span class="keyword">set</span> -g mouse-utf8 <span class="keyword">on</span></div></pre></td></tr></table></figure>
<p>配置当然要根据自己的使用习惯来设置，这里仅仅给出参考。这样我们将多窗口终端的控制玩弄于手掌之中啦。</p>
<p><img src="/assets/images/blog_img/2017-03-26-优雅的在终端中编写Python/tmux_panels.png" alt=""></p>
<h3 id="Vim配置"><a href="#Vim配置" class="headerlink" title="Vim配置"></a>Vim配置</h3><p>解决了终端窗口问题，我们开始大刀阔斧的捣鼓编辑器啦，这里我对我使用的几个Vim插件进行整理，以及几个基本配置进行下说明。</p>
<p>完整的vim配置文件参见: <a href="https://github.com/PytLab/dotfiles/blob/master/.vimrc" target="_blank" rel="external">https://github.com/PytLab/dotfiles/blob/master/.vimrc</a></p>
<h4 id="关于Vim安装"><a href="#关于Vim安装" class="headerlink" title="关于Vim安装"></a>关于Vim安装</h4><p>这里主要说一下在Mac上的Vim安装，Vim的官网以及YouCompleteMe的README都有推荐使用MacVim, 但是如果我们并不想在使用Vim的时候还打开新的窗口而是直接在终端使用Vim的话需要在安装MacVim后做一点小处理。</p>
<ol>
<li><p>安装MacVim</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">brew </span>cask <span class="keyword">install </span>macvim</div></pre></td></tr></table></figure>
</li>
<li><p>使用MacVim的mvim脚本覆盖掉系统自带的vim</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">alias</span> vim=<span class="string">'/usr/local/bin/mvim -v'</span></div><div class="line"><span class="built_in">alias</span> vi=<span class="string">'vim'</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="自动给打开的文件添加头部"><a href="#自动给打开的文件添加头部" class="headerlink" title="自动给打开的文件添加头部"></a>自动给打开的文件添加头部</h4><p>例如我们编写Python脚本的时候经常会在文件开头添加执行文件的Python路径以及文件的编码方式，我们可以通过在Vim的配置文件中添加一个函数，并让他在打开一个新的缓冲区的时候自动添加到头部。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">" Auto add head info</span></div><div class="line"><span class="comment">" .py file into add header</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">HeaderPython</span><span class="params">()</span></span></div><div class="line">    <span class="keyword">call</span> <span class="built_in">setline</span>(<span class="number">1</span>, <span class="string">"#!/usr/bin/env python"</span>)</div><div class="line">    <span class="keyword">call</span> <span class="keyword">append</span>(<span class="number">1</span>, <span class="string">"# -*- coding: utf-8 -*-"</span>)</div><div class="line">    <span class="keyword">normal</span> G</div><div class="line">    <span class="keyword">normal</span> <span class="keyword">o</span></div><div class="line"><span class="keyword">endf</span></div><div class="line"><span class="keyword">autocmd</span> bufnewfile *.<span class="keyword">py</span> <span class="keyword">call</span> HeaderPython()</div></pre></td></tr></table></figure></p>
<p>这样当我们使用<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">vi</span> <span class="keyword">new</span>.<span class="keyword">py</span></div></pre></td></tr></table></figure></p>
<p>的时候便会匹配到文件后缀并执行头部添加函数进行内容添加, 其他语言的脚本例如bash、perl等都是类似的方式。</p>
<h4 id="安装插件管理器Vundle"><a href="#安装插件管理器Vundle" class="headerlink" title="安装插件管理器Vundle"></a>安装插件管理器Vundle</h4><p>如果要安装插件，必须要有个方便的插件管理器，Vim的插件管理器有很多，这里我使用了Vundle，它的全称是Vim Bundle，可以让我们轻松的安装、更新、搜索和清理Vim插件。Vundle本身是一个Vim插件，所以使我们安装所有插件中最早需要安装的插件。</p>
<p>Vundle的安装方式这里就不详细介绍了，可以参见：<a href="https://github.com/VundleVim/Vundle.vim" target="_blank" rel="external">https://github.com/VundleVim/Vundle.vim</a></p>
<p>安装好后我们需要修改下<code>.vimrc</code>文件：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> nocompatible</div><div class="line"><span class="keyword">filetype</span> off</div><div class="line"></div><div class="line"><span class="keyword">set</span> rtp+=~/.<span class="keyword">vim</span>/bundle/Vundle.<span class="keyword">vim</span></div><div class="line"><span class="keyword">call</span> vundle#begin()</div><div class="line"></div><div class="line"><span class="comment">" 在这里添加你想安装的Vim插件</span></div><div class="line"></div><div class="line"><span class="keyword">call</span> vundle#end()            <span class="comment">" required</span></div><div class="line"><span class="keyword">filetype</span> plugin <span class="built_in">indent</span> <span class="keyword">on</span>    <span class="comment">" required</span></div></pre></td></tr></table></figure></p>
<p>这样如果我们想安装插件的话我们只需要在<code>call vundle#begin()</code> 和 <code>call vundle#end()</code>之间直接写入就好了，非常方便，写好后我们直接运行<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">vim</span> +PluginInstall +<span class="keyword">qall</span></div></pre></td></tr></table></figure></p>
<p>vundle便会自动下载并安装好插件，我们直接作为伸手党使用就好啦.</p>
<p><img src="/assets/images/blog_img/2017-03-26-优雅的在终端中编写Python/vim_plugin_install.png" alt=""></p>
<h4 id="自动补全神器YouCompleteMe"><a href="#自动补全神器YouCompleteMe" class="headerlink" title="自动补全神器YouCompleteMe"></a>自动补全神器YouCompleteMe</h4><p>YouCompleteMe是一个非常强大的Vim自动补全插件，他的特别之处就在于他并不是像vim自带的<code>Ctrl-x</code>和<code>Ctrl-n</code>那样基于文本进行补全，而是基于语义，通过分析源文件进行语法分析，这得益于强大的clang/llvm。同时YCM也整合了多种插件，其中也包含语法纠错，类似Syntastic的功能，但是只能进行C/C++/Objective-C的语法检测，对于Python的话我们后面需要安装Syntastic插件。</p>
<p>YCM虽然强大，但是安装却稍微麻烦些，首先他文件比较大，另外需要自己进行编译(NeoVundle插件管理器貌似可以直接帮你自动编译), 不过无论我之前在ubuntu还是现在的mac上，至少我还是没有遇到什么很大的问题的。</p>
<p>具体的安装请参考YCM的安装说明: <a href="https://github.com/Valloric/YouCompleteMe#installation" target="_blank" rel="external">https://github.com/Valloric/YouCompleteMe#installation</a></p>
<p>YCM的相关设置：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">" Plugin YCM settings.</span></div><div class="line"><span class="keyword">set</span> completeopt=longest,<span class="keyword">menu</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:ycm_min_num_of_chars_for_completion</span>=<span class="number">2</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:ycm_cache_omnifunc</span>=<span class="number">0</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:ycm_seed_identifiers_with_syntax</span>=<span class="number">1</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:ycm_complete_in_comments</span> = <span class="number">1</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:ycm_complete_in_strings</span> = <span class="number">1</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:ycm_collect_identifiers_from_comments_and_strings</span> = <span class="number">0</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:ycm_global_ycm_extra_conf</span> = <span class="string">'~/.ycm_extra_conf.py'</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:syntastic_check_on_open</span>=<span class="number">1</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:syntastic_enable_signs</span>=<span class="number">1</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:syntastic_cpp_check_header</span> = <span class="number">1</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:syntastic_cpp_remove_include_errors</span> = <span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>YCM除了在<code>.vimrc</code>中进行配置外，还有一个Python的配置文件<code>.ycm_extra_conf.py</code>，在里面我们可以设置相应的编译选项，比如编译参数，头文件和库文件的地址等等，这样我们在编写C/C++等的时候ycm会找到相应的头文件和库文件进行编译并给出相应的提示。这个文件需要根据自己的项目根据自己的文件位置进行自定义。</p>
<p>我的<code>.ycm_extra_conf.py</code>的完整版：<a href="https://github.com/PytLab/dotfiles/blob/master/.ycm_extra_conf.py" target="_blank" rel="external">https://github.com/PytLab/dotfiles/blob/master/.ycm_extra_conf.py</a></p>
<p><img src="/assets/images/blog_img/2017-03-26-优雅的在终端中编写Python/ycm_complete.png" alt=""></p>
<h4 id="为Python的缩进助力"><a href="#为Python的缩进助力" class="headerlink" title="为Python的缩进助力"></a>为Python的缩进助力</h4><p>写Python的时候你一定需要一款帮助你显示缩进的插件，indentLine就是一款提供缩指示线的插件，有纯文字实现，有了他在判断Python代码块的时候就方便了许多。</p>
<p>插件地址：<a href="https://github.com/Yggdroot/indentLine" target="_blank" rel="external">https://github.com/Yggdroot/indentLine</a></p>
<p>我相应的配置：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">" Plugin indentLine settings.</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:indentLine_char</span> = <span class="string">"┆"</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:indentLine_enabled</span> = <span class="number">1</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:autopep8_disable_show_diff</span>=<span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>效果：</p>
<p><img src="/assets/images/blog_img/2017-03-26-优雅的在终端中编写Python/indent_line.png" alt=""></p>
<h4 id="对打开的多个文件进行操作"><a href="#对打开的多个文件进行操作" class="headerlink" title="对打开的多个文件进行操作"></a>对打开的多个文件进行操作</h4><p>当我们写代码的时候不可能每次只打开一个文件，而是打开很多个，而且要经常在这之间来回切换。vim提供了自己的buffer管理工具，但是并不直观，这时可以使用minibufexplorer插件，这样便可以像切换tab一样在Vim中进行buffer的切换来同时编辑多个文件。</p>
<p>效果如下图：</p>
<p><img src="/assets/images/blog_img/2017-03-26-优雅的在终端中编写Python/bufexplorer.png" alt=""></p>
<p>我们可以通过根据前面的buffer序号来使用<code>Ctrl+w :b buffer-number</code>来快速切换。</p>
<h4 id="使用Pylint来帮助我们进行Python语法检测"><a href="#使用Pylint来帮助我们进行Python语法检测" class="headerlink" title="使用Pylint来帮助我们进行Python语法检测"></a>使用Pylint来帮助我们进行Python语法检测</h4><p>首先Pylint是一个代码分析工具，它能够分析Python中的代码错误，查找不符合风格标准（默认PEP8）和有潜在问题的代码，如果单独使用的话，他还可以为我们的Python代码进行检测并生成一份报告，并为你的代码进行评分，像这样：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pylint incar<span class="selector-class">.py</span> --output-format=<span class="selector-tag">html</span> &gt; score.html</div></pre></td></tr></table></figure></p>
<p><img src="/assets/images/blog_img/2017-03-26-优雅的在终端中编写Python/pylint_score.png" alt=""></p>
<p>我们可以利用syntastic插件来使用pylint帮助我们进行语法检查。</p>
<p>syntastic的安装可以直接通过Vundle来进行方便的安装，安装后我们需要进行下配置：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">" Plugin syntastic settings.</span></div><div class="line"><span class="keyword">set</span> statusline+=%#warningmsg#</div><div class="line"><span class="keyword">set</span> statusline+=%&#123;SyntasticStatuslineFlag()&#125;</div><div class="line"><span class="keyword">set</span> statusline+=%*</div><div class="line"></div><div class="line"><span class="keyword">let</span> <span class="variable">g:syntastic_always_populate_loc_list</span> = <span class="number">1</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:syntastic_auto_loc_list</span> = <span class="number">1</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:syntastic_check_on_open</span> = <span class="number">0</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:syntastic_check_on_wq</span> = <span class="number">0</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:syntastic_mode_map</span> = &#123;<span class="string">'mode'</span>: <span class="string">'passive'</span>, <span class="string">'active_filetypes'</span>: [], <span class="string">'passive_filetypes'</span>: []&#125;</div><div class="line"><span class="comment">" Use pylint to check python files.</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:syntastic_python_checkers</span> = [<span class="string">'pylint'</span>]</div><div class="line"><span class="keyword">map</span> <span class="symbol">&lt;F5&gt;</span> :SyntasticToggleMode<span class="symbol">&lt;CR&gt;</span> :SyntasticCheck<span class="symbol">&lt;CR&gt;</span></div><div class="line"></div><div class="line"><span class="comment">" Ignore warnings about newlines trailing.</span></div><div class="line"><span class="keyword">let</span> <span class="variable">g:syntastic_quiet_messages</span> = &#123; <span class="string">'regex'</span>: [<span class="string">'trailing-newlines'</span>, <span class="string">'invalid-name'</span>,</div><div class="line">    \<span class="string">'too-many-lines'</span>, <span class="string">'too-many-instance-attributes'</span>, <span class="string">'too-many-public-methods'</span>,</div><div class="line">    \<span class="string">'too-many-locals'</span>, <span class="string">'too-many-branches'</span>] &#125;</div></pre></td></tr></table></figure></p>
<p>这里主要涉及两个部分的配置，</p>
<ol>
<li>一个是将检测模式改成被动，由于Syntastic检测并不是异步进行的，如果每次保存的时候都进行检测，都会卡在那里等一会，如果我的代码比较大的话会更久，所以我们在想要检测的时候在检测。</li>
<li>忽略掉一些我们不想看到的warnign，pylint完全按照PEP8来的话，我的代码经常会各种提示的warning，比如我喜欢在代码最后一行留个空行也会有提示，因此我就通过正则表达式将次信息过滤掉，这时候就需要设置<code>syntastic_quiet_message</code>变量了。</li>
</ol>
<p><img src="/assets/images/blog_img/2017-03-26-优雅的在终端中编写Python/syntastic_warning.png" alt=""></p>
<h4 id="树形目录方便文件查看"><a href="#树形目录方便文件查看" class="headerlink" title="树形目录方便文件查看"></a>树形目录方便文件查看</h4><p>像其他IDE一样，左边有树形目录的话，所有文件夹和文件都一目了然那一定是极好的，所以NERDTree插件就是这么一款工具，他可以直接通过Vundle进行安装，然后在配置文件中设置启动的快捷键以及窗口大小和忽略显示的文件等等。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">" Plugin nerdtree settings.</span></div><div class="line"><span class="keyword">map</span> <span class="symbol">&lt;F2&gt;</span> :NERDTreeToggle<span class="symbol">&lt;CR&gt;</span></div><div class="line"><span class="keyword">let</span> NERDTreeChDirMode=<span class="number">1</span></div><div class="line"><span class="keyword">let</span> NERDTreeShowBookmarks=<span class="number">1</span></div><div class="line"><span class="keyword">let</span> NERDTreeWinSize=<span class="number">25</span></div><div class="line"><span class="keyword">let</span> NERDTreeShowHidden=<span class="number">1</span></div><div class="line"><span class="keyword">let</span> NERDTreeIgnore=[<span class="string">'\~$'</span>, <span class="string">'\.pyc$'</span>, <span class="string">'\.swp$'</span>, <span class="string">'\.git$'</span>]</div></pre></td></tr></table></figure>
<p><img src="/assets/images/blog_img/2017-03-26-优雅的在终端中编写Python/nerdtree.png" alt=""></p>
<h4 id="在项目中迅速定位文件"><a href="#在项目中迅速定位文件" class="headerlink" title="在项目中迅速定位文件"></a>在项目中迅速定位文件</h4><p>ctrlp.vim 顾名思义，就是提供了同Sublime的Ctrl+p的功能，可以直接通过Vundle安装，在配置文件中将其映射到功能键上便可以快速启动搜索，支持模糊匹配。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">map</span> <span class="symbol">&lt;F3&gt;</span> :CtrlP<span class="symbol">&lt;CR&gt;</span></div></pre></td></tr></table></figure>
<p><img src="/assets/images/blog_img/2017-03-26-优雅的在终端中编写Python/ctrlp.png" alt=""></p>
<h4 id="显示文件中的类、函数、变量"><a href="#显示文件中的类、函数、变量" class="headerlink" title="显示文件中的类、函数、变量"></a>显示文件中的类、函数、变量</h4><p>tagbar插件可以帮助我们显示当前文件中的类、函数、变量等，方便我们阅读代码，它是基于ctags的，支持很多语言，具体详见：<a href="https://github.com/majutsushi/tagbar/wiki" target="_blank" rel="external">https://github.com/majutsushi/tagbar/wiki</a></p>
<p>安装好ctags之后可以直接从Vundle中进行安装。</p>
<p>在配置文件中可以将其绑定到快捷键上方便快速启动。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">map</span> <span class="symbol">&lt;F2&gt;</span> :TagbarToggle<span class="symbol">&lt;CR&gt;</span></div></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="/assets/images/blog_img/2017-03-26-优雅的在终端中编写Python/tagbar.png" alt=""></p>
<h4 id="其他插件"><a href="#其他插件" class="headerlink" title="其他插件"></a>其他插件</h4><p>Vim 的插件很丰富，这里我就不再一一赘述了，希望这些强大的工具能让我们在终端中更优雅的编写Python(不限于Python啦),有关我使用的vim插件都在我的<code>.vimrc</code>中，有兴趣的童鞋可以搜索相应的插件名称进行查看。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">" Plugins.</span></div><div class="line">Plugin <span class="string">'VundleVim/Vundle.vim'</span></div><div class="line">Plugin <span class="string">'Valloric/YouCompleteMe'</span></div><div class="line">Plugin <span class="string">'nathanaelkane/vim-indent-guides'</span></div><div class="line">Plugin <span class="string">'fholgado/minibufexpl.vim'</span></div><div class="line">Plugin <span class="string">'Yggdroot/indentLine'</span></div><div class="line">Plugin <span class="string">'scrooloose/nerdtree'</span></div><div class="line">Plugin <span class="string">'ctrlpvim/ctrlp.vim'</span></div><div class="line">Plugin <span class="string">'majutsushi/tagbar'</span></div><div class="line">Plugin <span class="string">'dyng/ctrlsf.vim'</span></div><div class="line">Plugin <span class="string">'vim-airline/vim-airline'</span></div><div class="line">Plugin <span class="string">'vim-airline/vim-airline-themes'</span></div><div class="line">Plugin <span class="string">'MattesGroeger/vim-bookmarks'</span></div><div class="line">Plugin <span class="string">'vim-syntastic/syntastic'</span></div></pre></td></tr></table></figure></p>
<p>同时为了方便自己我也写了相应的安装和卸载脚本，方便大家参考，github地址：<a href="https://github.com/PytLab/dotfiles" target="_blank" rel="external">https://github.com/PytLab/dotfiles</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要简单介绍下本人平时编程中使用tmux,vim等工具的配置，希望能借此帮助大家能更好的在终端中进行程序编写提高工作效率。</p>
<p>最后还是建议配置文件中不要盲目复制粘贴别人的配置，最好保证里面的配置自己都知道是做什么的，而且是对自己需要的。</p>
]]></content>
      
        <categories>
            
            <category> 工具应用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> Vim </tag>
            
            <tag> tmux </tag>
            
            <tag> macOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python多进程并行编程实践-mpi4py的使用]]></title>
      <url>http://pytlab.github.io/2017/02/19/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5-mpi4py%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在高性能计算的项目中我们通常都会使用效率更高的编译型的语言例如C、C++、Fortran等，但是由于Python的灵活性和易用性使得它在发展和验证算法方面备受人们的青睐于是在高性能计算领域也经常能看到Python的身影了。本文简单介绍在Python环境下使用MPI接口在集群上进行多进程并行计算的方法。</p>
<h2 id="MPI-Message-Passing-Interface"><a href="#MPI-Message-Passing-Interface" class="headerlink" title="MPI(Message Passing Interface)"></a>MPI(Message Passing Interface)</h2><p>这里我先对MPI进行一下简单的介绍，MPI的全称是Message Passing Interface，即消息传递接口。</p>
<ul>
<li><p>它并不是一门语言，而是一个库，我们可以用Fortran、C、C++结合MPI提供的接口来将串行的程序进行并行化处理，也可以认为Fortran+MPI或者C+MPI是一种再原来串行语言的基础上扩展出来的并行语言。</p>
</li>
<li><p>它是一种标准而不是特定的实现，具体的可以有很多不同的实现，例如MPICH、OpenMPI等。</p>
</li>
<li><p>它是一种消息传递编程模型，顾名思义，它就是专门服务于进程间通信的。</p>
</li>
</ul>
<a id="more"></a>
<p>MPI的工作方式很好理解，我们可以同时启动一组进程，在同一个通信域中不同的进程都有不同的编号，程序员可以利用MPI提供的接口来给不同编号的进程分配不同的任务和帮助进程相互交流最终完成同一个任务。就好比包工头给工人们编上了工号然后指定一个方案来给不同编号的工人分配任务并让工人相互沟通完成任务。</p>
<h2 id="Python中的并行"><a href="#Python中的并行" class="headerlink" title="Python中的并行"></a>Python中的并行</h2><p>由于CPython中的GIL的存在我们可以暂时不奢望能在CPython中使用多线程利用多核资源进行并行计算了，因此我们在Python中可以利用多进程的方式充分利用多核资源。</p>
<p>Python中我们可以使用很多方式进行多进程编程，例如<code>os.fork()</code>来创建进程或者通过<code>multiprocessing</code>模块来更方便的创建进程和进程池等。在上一篇<a href="http://pytlab.org/2017/01/19/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5-multiprocessing%E6%A8%A1%E5%9D%97/" target="_blank" rel="external">《Python多进程并行编程实践-multiprocessing模块》</a>中我们使用进程池来方便的管理Python进程并且通过multiprocessing模块中的<code>Manager</code>管理分布式进程实现了计算的多机分布式计算。</p>
<p>与多线程的共享式内存不同，由于各个进程都是相互独立的，因此进程间通信再多进程中扮演这非常重要的角色，Python中我们可以使用multiprocessing模块中的<code>pipe</code>、<code>queue</code>、<code>Array</code>、<code>Value</code>等等工具来实现进程间通讯和数据共享，但是在编写起来仍然具有很大的不灵活性。而这一方面正是MPI所擅长的领域，因此如果能够在Python中调用MPI的接口那真是太完美了不是么。</p>
<h2 id="MPI与mpi4py"><a href="#MPI与mpi4py" class="headerlink" title="MPI与mpi4py"></a>MPI与mpi4py</h2><p>mpi4py是一个构建在MPI之上的Python库，主要使用Cython编写。mpi4py使得Python的数据结构可以方便的在多进程中传递。</p>
<p>mpi4py是一个很强大的库，它实现了很多MPI标准中的接口，包括点对点通信，组内集合通信、非阻塞通信、重复非阻塞通信、组间通信等，基本上我能想到用到的MPI接口mpi4py中都有相应的实现。不仅是Python对象，mpi4py对numpy也有很好的支持并且传递效率很高。同时它还提供了SWIG和F2PY的接口能够让我们将自己的Fortran或者C/C++程序在封装成Python后仍然能够使用mpi4py的对象和接口来进行并行处理。可见mpi4py的作者的功力的确是非常了得。</p>
<h2 id="mpi4py"><a href="#mpi4py" class="headerlink" title="mpi4py"></a>mpi4py</h2><p>这里我开始对在Python环境中使用mpi4py的接口进行并行编程进行介绍。</p>
<h3 id="MPI环境管理"><a href="#MPI环境管理" class="headerlink" title="MPI环境管理"></a>MPI环境管理</h3><p>mpi4py提供了相应的接口<code>Init()</code>和<code>Finalize()</code>来初始化和结束mpi环境。但是mpi4py通过在<code>__init__.py</code>中写入了初始化的操作，因此在我们<code>from mpi4py import MPI</code>的时候就已经自动初始化mpi环境。</p>
<p><code>MPI_Finalize()</code>被注册到了Python的C接口<code>Py_AtExit()</code>，这样在Python进程结束时候就会自动调用<code>MPI_Finalize()</code>， 因此不再需要我们显式的去掉用<code>Finalize()</code>。</p>
<h3 id="通信域-Communicator"><a href="#通信域-Communicator" class="headerlink" title="通信域(Communicator)"></a>通信域(Communicator)</h3><p>mpi4py直接提供了相应的通信域的Python类，其中<code>Comm</code>是通信域的基类，<code>Intracomm</code>和<code>Intercomm</code>是其派生类，这根MPI的C++实现中是相同的。</p>
<p><img src="/assets/images/blog_img/2017-02-19-Python多进程并行编程实践-mpi4py的使用/commHier.png" alt=""></p>
<p>同时它也提供了两个预定义的通信域对象:</p>
<ol>
<li>包含所有进程的<code>COMM_WORLD</code></li>
<li>只包含调用进程本身的<code>COMM_SELF</code></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> mpi4py <span class="keyword">import</span> MPI                  </div><div class="line">                                                </div><div class="line">In [<span class="number">2</span>]: MPI.COMM_SELF                           </div><div class="line">Out[<span class="number">2</span>]: &lt;mpi4py.MPI.Intracomm at <span class="number">0x7f2fa2fd59d0</span>&gt;</div><div class="line">                                                </div><div class="line">In [<span class="number">3</span>]: MPI.COMM_WORLD                          </div><div class="line">Out[<span class="number">3</span>]: &lt;mpi4py.MPI.Intracomm at <span class="number">0x7f2fa2fd59f0</span>&gt;</div></pre></td></tr></table></figure>
<p>通信域对象则提供了与通信域相关的接口，例如获取当前进程号、获取通信域内的进程数、获取进程组、对进程组进行集合运算、分割合并等等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">4</span>]: comm = MPI.COMM_WORLD                   </div><div class="line">                                                </div><div class="line">In [<span class="number">5</span>]: comm.Get_rank()                         </div><div class="line">Out[<span class="number">5</span>]: <span class="number">0</span>                                       </div><div class="line">                                                </div><div class="line">In [<span class="number">6</span>]: comm.Get_size()                         </div><div class="line">Out[<span class="number">6</span>]: <span class="number">1</span>                                       </div><div class="line">                                                </div><div class="line">In [<span class="number">7</span>]: comm.Get_group()                        </div><div class="line">Out[<span class="number">7</span>]: &lt;mpi4py.MPI.Group at <span class="number">0x7f2fa40fec30</span>&gt;    </div><div class="line">                                                </div><div class="line">In [<span class="number">9</span>]: comm.Split(<span class="number">0</span>, <span class="number">0</span>)                        </div><div class="line">Out[<span class="number">9</span>]: &lt;mpi4py.MPI.Intracomm at <span class="number">0x7f2fa2fd5bd0</span>&gt;</div></pre></td></tr></table></figure>
<p>关于通信域与进程组的操作这里就不细讲了，可以参考<a href="http://mpitutorial.com/tutorials/introduction-to-groups-and-communicators/" target="_blank" rel="external">Introduction to Groups and Communicators</a></p>
<h3 id="点对点通信"><a href="#点对点通信" class="headerlink" title="点对点通信"></a>点对点通信</h3><p>mpi4py提供了点对点通信的接口使得多个进程间能够互相传递Python的内置对象（基于pickle序列化），同时也提供了直接的数组传递（numpy数组，接近C语言的效率）。</p>
<p>如果我们需要传递通用的Python对象，则需要使用通信域对象的方法中小写的接口，例如<code>send()</code>,<code>recv()</code>,<code>isend()</code>等。</p>
<p>如果需要直接传递数据对象，则需要调用大写的接口，例如<code>Send()</code>,<code>Recv()</code>,<code>Isend()</code>等，这与C++接口中的拼写是一样的。</p>
<p><img src="/assets/images/blog_img/2017-02-19-Python多进程并行编程实践-mpi4py的使用/message_passing.png" alt=""></p>
<p>MPI中的点到点通信有很多中，其中包括标准通信，缓存通信，同步通信和就绪通信，同时上面这些通信又有非阻塞的异步版本等等。这些在mpi4py中都有相应的Python版本的接口来让我们更灵活的处理进程间通信。这里我只用标准通信的阻塞和非阻塞版本来做个举例：</p>
<h4 id="阻塞标准通信"><a href="#阻塞标准通信" class="headerlink" title="阻塞标准通信"></a>阻塞标准通信</h4><p><img src="/assets/images/blog_img/2017-02-19-Python多进程并行编程实践-mpi4py的使用/send_recv_mode.png" alt=""><br>这里我尝试使用mpi4py的接口在两个进程中传递Python list对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> mpi4py <span class="keyword">import</span> MPI</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">comm = MPI.COMM_WORLD</div><div class="line">rank = comm.Get_rank()</div><div class="line">size = comm.Get_size()</div><div class="line"></div><div class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</div><div class="line">    data = range(<span class="number">10</span>)</div><div class="line">    comm.send(data, dest=<span class="number">1</span>, tag=<span class="number">11</span>)</div><div class="line">    print(<span class="string">"process &#123;&#125; send &#123;&#125;..."</span>.format(rank, data))</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    data = comm.recv(source=<span class="number">0</span>, tag=<span class="number">11</span>)</div><div class="line">    print(<span class="string">"process &#123;&#125; recv &#123;&#125;..."</span>.format(rank, data))</div></pre></td></tr></table></figure>
<p>执行效果：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">zjshao<span class="variable">@vaio</span><span class="symbol">:~/temp_codes/mpipy</span><span class="variable">$ </span>mpiexec -np <span class="number">2</span> python temp.py</div><div class="line">process <span class="number">0</span> send [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]...</div><div class="line">process <span class="number">1</span> recv [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]...</div></pre></td></tr></table></figure></p>
<h4 id="非阻塞标准通信"><a href="#非阻塞标准通信" class="headerlink" title="非阻塞标准通信"></a>非阻塞标准通信</h4><p>所有的阻塞通信mpi都提供了一个非阻塞的版本，类似与我们编写异步程序不阻塞在耗时的IO上是一样的，MPI的非阻塞通信也不会阻塞消息的传递过程中，这样能够充分利用处理器资源提升整个程序的效率。</p>
<p>来张图看看阻塞通信与非阻塞通信的对比：</p>
<p><img src="/assets/images/blog_img/2017-02-19-Python多进程并行编程实践-mpi4py的使用/blocked_unblocked.png" alt=""></p>
<p>非阻塞通信的消息发送和接受：</p>
<p><img src="/assets/images/blog_img/2017-02-19-Python多进程并行编程实践-mpi4py的使用/unblocked.png" alt=""></p>
<p>同样的，我们也可以写一个上面例子的非阻塞版本。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> mpi4py <span class="keyword">import</span> MPI                                         </div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np                                             </div><div class="line">                                                               </div><div class="line">comm = MPI.COMM_WORLD                                          </div><div class="line">rank = comm.Get_rank()                                         </div><div class="line">size = comm.Get_size()                                         </div><div class="line">                                                               </div><div class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:                                                  </div><div class="line">    data = range(<span class="number">10</span>)                                           </div><div class="line">    comm.isend(data, dest=<span class="number">1</span>, tag=<span class="number">11</span>)                           </div><div class="line">    print(<span class="string">"process &#123;&#125; immediate send &#123;&#125;..."</span>.format(rank, data))</div><div class="line"><span class="keyword">else</span>:                                                          </div><div class="line">    data = comm.recv(source=<span class="number">0</span>, tag=<span class="number">11</span>)                         </div><div class="line">    print(<span class="string">"process &#123;&#125; recv &#123;&#125;..."</span>.format(rank, data))</div></pre></td></tr></table></figure>
<p>执行结果,注意非阻塞发送也可以用阻塞接收来接收消息：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">zjshao<span class="variable">@vaio</span><span class="symbol">:~/temp_codes/mpipy</span><span class="variable">$ </span>mpiexec -np <span class="number">2</span> python temp.py</div><div class="line">process <span class="number">0</span> immediate send [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]...</div><div class="line">process <span class="number">1</span> recv [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]...</div></pre></td></tr></table></figure></p>
<h4 id="支持Numpy数组"><a href="#支持Numpy数组" class="headerlink" title="支持Numpy数组"></a>支持Numpy数组</h4><p>mpi4py的一个很好的特点就是他对Numpy数组有很好的支持，我们可以通过其提供的接口来直接传递数据对象，这种方式具有很高的效率，基本上和C/Fortran直接调用MPI接口差不多（方式和效果）</p>
<p>例如我想传递长度为10的int数组，MPI的C++接口是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Comm::Send(<span class="keyword">const</span> <span class="keyword">void</span> * buf, <span class="keyword">int</span> count, <span class="keyword">const</span> Datatype &amp; datatype, <span class="keyword">int</span> dest, <span class="keyword">int</span> tag) <span class="keyword">const</span></div></pre></td></tr></table></figure></p>
<p>在mpi4py的接口中也及其类似, Comm.Send()中需要接收一个Python list作为参数，其中包含所传数据的地址，长度和类型。</p>
<p>来个阻塞标准通信的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> mpi4py <span class="keyword">import</span> MPI                                                 </div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np                                                     </div><div class="line">                                                                       </div><div class="line">comm = MPI.COMM_WORLD                                                  </div><div class="line">rank = comm.Get_rank()                                                 </div><div class="line">size = comm.Get_size()                                                 </div><div class="line">                                                                       </div><div class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:                                                          </div><div class="line">    data = np.arange(<span class="number">10</span>, dtype=<span class="string">'i'</span>)                                    </div><div class="line">    comm.Send([data, MPI.INT], dest=<span class="number">1</span>, tag=<span class="number">11</span>)                         </div><div class="line">    print(<span class="string">"process &#123;&#125; Send buffer-like array &#123;&#125;..."</span>.format(rank, data))</div><div class="line"><span class="keyword">else</span>:                                                                  </div><div class="line">    data = np.empty(<span class="number">10</span>, dtype=<span class="string">'i'</span>)                                     </div><div class="line">    comm.Recv([data, MPI.INT], source=<span class="number">0</span>, tag=<span class="number">11</span>)                       </div><div class="line">    print(<span class="string">"process &#123;&#125; recv buffer-like array &#123;&#125;..."</span>.format(rank, data))</div></pre></td></tr></table></figure>
<p>执行效果：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">zjshao@vaio:~/temp_codes/mpipy$ /usr/bin/mpiexec -np 2 python temp.py</div><div class="line">process 0 Send buffer-like<span class="built_in"> array </span>[0 1 2 3 4 5 6 7 8 9]...</div><div class="line">process 1 recv buffer-like<span class="built_in"> array </span>[0 1 2 3 4 5 6 7 8 9]...</div></pre></td></tr></table></figure></p>
<h3 id="组通信"><a href="#组通信" class="headerlink" title="组通信"></a>组通信</h3><p>MPI组通信和点到点通信的一个重要区别就是，在某个进程组内所有的进程同时参加通信，mpi4py提供了方便的接口让我们完成Python中的组内集合通信，方便编程同时提高程序的可读性和可移植性。</p>
<p>下面就几个常用的集合通信来小试牛刀吧。</p>
<h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><p>广播操作是典型的一对多通信，将跟进程的数据复制到同组内其他所有进程中。<br><img src="/assets/images/blog_img/2017-02-19-Python多进程并行编程实践-mpi4py的使用/bcast.png" alt=""></p>
<p>在Python中我想将一个列表广播到其他进程中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> mpi4py <span class="keyword">import</span> MPI                                                     </div><div class="line">                                                                           </div><div class="line">comm = MPI.COMM_WORLD                                                      </div><div class="line">rank = comm.Get_rank()                                                     </div><div class="line">size = comm.Get_size()                                                     </div><div class="line">                                                                           </div><div class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:                                                              </div><div class="line">    data = range(<span class="number">10</span>)                                                       </div><div class="line">    print(<span class="string">"process &#123;&#125; bcast data &#123;&#125; to other processes"</span>.format(rank, data))</div><div class="line"><span class="keyword">else</span>:                                                                      </div><div class="line">    data = <span class="keyword">None</span>                                                            </div><div class="line">    data = comm.bcast(data, root=<span class="number">0</span>)                                            </div><div class="line">print(<span class="string">"process &#123;&#125; recv data &#123;&#125;..."</span>.format(rank, data))</div></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="title">zjshao</span>@vaio:~/temp_codes/mpipy$ /usr/bin/mpiexec -np <span class="number">5</span> python temp.py </div><div class="line"><span class="title">process</span> <span class="number">0</span> bcast <span class="class"><span class="keyword">data</span> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] to other processes</span></div><div class="line"><span class="title">process</span> <span class="number">0</span> recv <span class="class"><span class="keyword">data</span> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]...</span></div><div class="line"><span class="title">process</span> <span class="number">1</span> recv <span class="class"><span class="keyword">data</span> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]...</span></div><div class="line"><span class="title">process</span> <span class="number">3</span> recv <span class="class"><span class="keyword">data</span> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]...</span></div><div class="line"><span class="title">process</span> <span class="number">2</span> recv <span class="class"><span class="keyword">data</span> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]...</span></div><div class="line"><span class="title">process</span> <span class="number">4</span> recv <span class="class"><span class="keyword">data</span> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]...</span></div></pre></td></tr></table></figure></p>
<h4 id="发散"><a href="#发散" class="headerlink" title="发散"></a>发散</h4><p>与广播不同，发散可以向不同的进程发送不同的数据，而不是完全复制。</p>
<p><img src="/assets/images/blog_img/2017-02-19-Python多进程并行编程实践-mpi4py的使用/scatter.png" alt=""></p>
<p>例如我想将0-9发送到不同的进程中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">m mpi4py <span class="keyword">import</span> MPI                                                            </div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np                                                                </div><div class="line">                                                                                  </div><div class="line">comm = MPI.COMM_WORLD                                                             </div><div class="line">rank = comm.Get_rank()                                                            </div><div class="line">size = comm.Get_size()                                                            </div><div class="line">                                                                                  </div><div class="line">recv_data = <span class="keyword">None</span>                                                                  </div><div class="line">                                                                                  </div><div class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:                                                                     </div><div class="line">    send_data = range(<span class="number">10</span>)                                                         </div><div class="line">    print(<span class="string">"process &#123;&#125; scatter data &#123;&#125; to other processes"</span>.format(rank, send_data))</div><div class="line"><span class="keyword">else</span>:                                                                             </div><div class="line">    send_data = <span class="keyword">None</span>                                                              </div><div class="line">recv_data = comm.scatter(send_data, root=<span class="number">0</span>)                                       </div><div class="line">print(<span class="string">"process &#123;&#125; recv data &#123;&#125;..."</span>.format(rank, recv_data))</div></pre></td></tr></table></figure>
<p>发散结果：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="title">zjshao</span>@vaio:~/temp_codes/mpipy$ /usr/bin/mpiexec -np <span class="number">10</span> python temp.py </div><div class="line"><span class="title">process</span> <span class="number">0</span> scatter <span class="class"><span class="keyword">data</span> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] to other processes</span></div><div class="line"><span class="title">process</span> <span class="number">0</span> recv <span class="class"><span class="keyword">data</span> 0...</span></div><div class="line"><span class="title">process</span> <span class="number">3</span> recv <span class="class"><span class="keyword">data</span> 3...</span></div><div class="line"><span class="title">process</span> <span class="number">5</span> recv <span class="class"><span class="keyword">data</span> 5...</span></div><div class="line"><span class="title">process</span> <span class="number">8</span> recv <span class="class"><span class="keyword">data</span> 8...</span></div><div class="line"><span class="title">process</span> <span class="number">2</span> recv <span class="class"><span class="keyword">data</span> 2...</span></div><div class="line"><span class="title">process</span> <span class="number">7</span> recv <span class="class"><span class="keyword">data</span> 7...</span></div><div class="line"><span class="title">process</span> <span class="number">4</span> recv <span class="class"><span class="keyword">data</span> 4...</span></div><div class="line"><span class="title">process</span> <span class="number">1</span> recv <span class="class"><span class="keyword">data</span> 1...</span></div><div class="line"><span class="title">process</span> <span class="number">9</span> recv <span class="class"><span class="keyword">data</span> 9...</span></div><div class="line"><span class="title">process</span> <span class="number">6</span> recv <span class="class"><span class="keyword">data</span> 6...</span></div></pre></td></tr></table></figure></p>
<h4 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h4><p>收集过程是发散过程的逆过程，每个进程将发送缓冲区的消息发送给根进程，根进程根据发送进程的进程号将各自的消息存放到自己的消息缓冲区中。</p>
<p><img src="/assets/images/blog_img/2017-02-19-Python多进程并行编程实践-mpi4py的使用/gather.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> mpi4py <span class="keyword">import</span> MPI                                              </div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np                                                  </div><div class="line">                                                                    </div><div class="line">comm = MPI.COMM_WORLD                                               </div><div class="line">rank = comm.Get_rank()                                              </div><div class="line">size = comm.Get_size()                                              </div><div class="line">                                                                    </div><div class="line">send_data = rank                                                    </div><div class="line"><span class="keyword">print</span> <span class="string">"process &#123;&#125; send data &#123;&#125; to root..."</span>.format(rank, send_data)  </div><div class="line">recv_data = comm.gather(send_data, root=<span class="number">0</span>)                          </div><div class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:                                                       </div><div class="line">    <span class="keyword">print</span> <span class="string">"process &#123;&#125; gather all data &#123;&#125;..."</span>.format(rank, recv_data)</div></pre></td></tr></table></figure>
<p>收集结果：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">zjshao@vaio:~/temp_codes/mpipy$ /usr/bin/mpiexec <span class="params">-np</span> <span class="number">5</span> python temp.py</div><div class="line">process <span class="number">2</span> send <span class="built_in">data</span> <span class="number">2</span> <span class="keyword">to</span> root<span class="params">...</span></div><div class="line">process <span class="number">3</span> send <span class="built_in">data</span> <span class="number">3</span> <span class="keyword">to</span> root<span class="params">...</span></div><div class="line">process <span class="number">0</span> send <span class="built_in">data</span> <span class="number">0</span> <span class="keyword">to</span> root<span class="params">...</span></div><div class="line">process <span class="number">4</span> send <span class="built_in">data</span> <span class="number">4</span> <span class="keyword">to</span> root<span class="params">...</span></div><div class="line">process <span class="number">1</span> send <span class="built_in">data</span> <span class="number">1</span> <span class="keyword">to</span> root<span class="params">...</span></div><div class="line">process <span class="number">0</span> gather <span class="literal">all</span> <span class="built_in">data</span> <span class="meta">[</span><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span><span class="meta">]</span>...</div></pre></td></tr></table></figure></p>
<p>其他的组内通信还有归约操作等等由于篇幅限制就不多讲了，有兴趣的可以去看看MPI的官方文档和相应的教材。</p>
<h2 id="mpi4py并行编程实践"><a href="#mpi4py并行编程实践" class="headerlink" title="mpi4py并行编程实践"></a>mpi4py并行编程实践</h2><p>这里我就上篇中的二重循环绘制map的例子来使用mpi4py进行并行加速处理。</p>
<p>我打算同时启动10个进程来将每个0轴需要计算和绘制的数据发送到不同的进程进行并行计算。<br>因此我需要将<code>pO2s</code>数组发散到10个进程中:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">comm = MPI.COMM_WORLD                </div><div class="line">rank = comm.Get_rank()               </div><div class="line">size = comm.Get_size()               </div><div class="line">                                     </div><div class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:                        </div><div class="line">    pO2 = np.linspace(<span class="number">1e-5</span>, <span class="number">0.5</span>, <span class="number">10</span>) </div><div class="line"><span class="keyword">else</span>:                                </div><div class="line">    pO2 = <span class="keyword">None</span>                       </div><div class="line">    pO2 = comm.scatter(pO2, root=<span class="number">0</span>)      </div><div class="line">                                     </div><div class="line">pCOs = np.linspace(<span class="number">1e-5</span>, <span class="number">0.5</span>, <span class="number">10</span>)</div></pre></td></tr></table></figure>
<p>之后我需要在每个进程中根据接受到的<code>pO2s</code>的数据再进行一次<code>pCOs</code>循环来进行计算。</p>
<p>最终将每个进程计算的结果(TOF)进行收集操作:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">comm.gather(tofs_1d, root=<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p>由于代码都是涉及的专业相关的东西我就不全列出来了，将mpi4py改过的并行版本放到10个进程中执行可见：</p>
<p><img src="/assets/images/blog_img/2017-02-19-Python多进程并行编程实践-mpi4py的使用/after.png" alt=""><br><img src="/assets/images/blog_img/2017-02-19-Python多进程并行编程实践-mpi4py的使用/before.png" alt=""></p>
<p>效率提升了10倍左右。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文简单介绍了mpi4py的接口在python中进行多进程编程的方法，MPI的接口非常庞大，相应的mpi4py也非常庞大，mpi4py还有实现了相应的SWIG和F2PY的封装文件和类型映射，能够帮助我们将Python同真正的C/C++以及Fortran程序在消息传递上实现统一。有兴趣的同学可以进一步研究一下，欢迎交流。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://pythonhosted.org/mpi4py/usrman/index.html" target="_blank" rel="external">MPI for Python 2.0.0 documentation</a></li>
<li><a href="http://mpitutorial.com/tutorials/" target="_blank" rel="external">MPI Tutorial</a></li>
<li><a href="http://materials.jeremybejarano.com/MPIwithPython/index.html" target="_blank" rel="external">A Python Introduction to Parallel Programming with MPI</a></li>
<li><a href="https://book.douban.com/subject/1244566/" target="_blank" rel="external">《高性能计算并行编程技术-MPI并行程序设计》</a></li>
<li><a href="https://book.douban.com/subject/3544630/" target="_blank" rel="external">《MPI并行程序设计实例教程》</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> MPI </tag>
            
            <tag> Parallel Computing </tag>
            
            <tag> mpi4py </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[推荐一本不错的MPI教程]]></title>
      <url>http://pytlab.github.io/2017/02/16/%E4%B8%80%E6%9C%AC%E4%B8%8D%E9%94%99%E7%9A%84MPI%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>今天看到一本很不错的MPI教程，内容并不是很多，但是讲的非常清晰，并且图示画得非常通俗易懂，比我第一次学习MPI时候看的那本清华大学出版社的《MPI并行程序设计实例教程》好很多，不知道是不是自己已经熟悉MPI的原因，反正我对这本书颇有好感，虽然代码是C和Fortran都有，但是默认以Fortran为主，推荐想学习MPI并行编程的童鞋参考这本书。</p>
<a id="more"></a>
<p><img src="/assets/images/blog_img/2017-02-16-一本不错的MPI教程/book.png" alt=""></p>
<p>PDF下载：<a href="https://pan.baidu.com/s/1c27omtU" target="_blank" rel="external">https://pan.baidu.com/s/1c27omtU</a></p>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MPI </tag>
            
            <tag> Parallel Computing </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ECMAScript中的作用域链和闭包]]></title>
      <url>http://pytlab.github.io/2017/02/14/ECMAScript%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/</url>
      <content type="html"><![CDATA[<p>本文对ECMAScript中的作用域以及闭包的概念进行一下小结。主要是整理概念便于理解和回忆。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>任何程序设计语言都有作用域的概念，简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。</p>
<h2 id="函数创建和调用时的作用域链"><a href="#函数创建和调用时的作用域链" class="headerlink" title="函数创建和调用时的作用域链"></a>函数创建和调用时的作用域链</h2><p>函数和其他对象一样，都拥有</p>
<ol>
<li>可以直接通过代码访问的属性</li>
<li>一些仅供js引擎访问的内部属性(用<code>[[...]]</code>扩起来的那些)。</li>
</ol>
<a id="more"></a>
<h3 id="函数创建"><a href="#函数创建" class="headerlink" title="函数创建"></a>函数创建</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> sum = num1 + num2;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>add</code>函数在创建的时候在函数对象内部会先创建一个预先包含全局变量对象的作用域链，这个作用于链内部属性<code>[[Scope]]</code>中。</p>
<p><img src="/assets/images/blog_img/2017-02-14-ECMAScript中的作用域链和闭包/scope_chain_0.png" alt=""></p>
<p style="text-align: center"><em>图片来自网络</em></p>

<h3 id="函数执行"><a href="#函数执行" class="headerlink" title="函数执行"></a>函数执行</h3><p>当<code>add</code>函数调用时，例如如下的调用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> total = add(<span class="number">5</span>, <span class="number">10</span>);</div></pre></td></tr></table></figure></p>
<h4 id="1-创建执行环境"><a href="#1-创建执行环境" class="headerlink" title="1. 创建执行环境"></a>1. 创建执行环境</h4><p>会为函数创建一个内部对象-<strong>执行环境</strong>,每个执行环境都有自己的<strong>作用域链</strong>用于标识符解析。</p>
<h4 id="2-为执行环复制原型链"><a href="#2-为执行环复制原型链" class="headerlink" title="2. 为执行环复制原型链"></a>2. 为执行环复制原型链</h4><p>复制函数对象的<code>[[Scope]]</code>属性中的对象(原型链)构建<strong>属于执行环境</strong>的作用域链, 这时候执行环境的原型链相当于函数对象原型链的一个<strong>副本</strong>。</p>
<h4 id="3-创建活动对象-activation-object"><a href="#3-创建活动对象-activation-object" class="headerlink" title="3. 创建活动对象(activation object)"></a>3. 创建活动对象(activation object)</h4><p>复制完原型链后，创建一个叫活动对象的对象，该对象包含了当前函数中的所有局部变量、名称参数、参数集合以及this。</p>
<h4 id="4-将活动对象放到作用域链的最前端"><a href="#4-将活动对象放到作用域链的最前端" class="headerlink" title="4. 将活动对象放到作用域链的最前端"></a>4. 将活动对象放到作用域链的最前端</h4><p>将活动对象当作变量对象放到作用域链的最前端。</p>
<p><img src="/assets/images/blog_img/2017-02-14-ECMAScript中的作用域链和闭包/scope_chain_1.png" alt=""></p>
<p style="text-align: center"><em>图片来自网络</em></p>

<h2 id="相关概念总结"><a href="#相关概念总结" class="headerlink" title="相关概念总结"></a>相关概念总结</h2><p>个人浅显总结如有理解错误欢迎指正。</p>
<h3 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h3><p><strong>执行环境(execution context)</strong>定义了变量或者函数有权访问的其他数据，是在函数调用时候创建的一个对象，包含有自己的作用域链。<br>每个函数都有自己的执行环境，当执行进入一个函数的时候，函数环境就被压入环境栈中，函数体退出后环境会在栈中弹出，把控制权返回给之前的执行环境。ECMAScript程序中的执行流正是通过这个机制控制者的。</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>每个执行环境都有一个<strong>变量对象(variable object)</strong>与之相关联，即执行环境中的变量和函数都保存在这个对象中。<br>我们无法直接获取变量对象这个对象本身并进行操作，但是js解释器会在我们处理变量函数等数据的时候在后台调用它。</p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>简单的讲，作用域链就是将多个变量对象进行链接起来的东东，这样能够保证执行环境能够有序的访问所能访问到的变量和函数。<br>这个链的<strong>最前端</strong>始终都是<strong>当前执行代码所在的变量对象</strong>，如果当前环境是函数的话，那么当前的<strong>活动对象(activation object)</strong>就做为变量对象作为作用域链的最前端。<br><div class="alert alert-info"><i class="fa fa-info"></i>  作用域链的本质是一个指向变量对象指针的列表，只是引用不包含实际变量对象。</div></p>
<h3 id="标识符解析"><a href="#标识符解析" class="headerlink" title="标识符解析"></a>标识符解析</h3><p>标识符解析是沿着作用域链一级一级搜索的。搜索过程从链的最前端逐级向后知道找到标识符或者找不到标识符抛出错误。<br>凡是能访问到的变量就说在作用域链中找到了这个变量。</p>
<h2 id="with语句改变作用域链"><a href="#with语句改变作用域链" class="headerlink" title="with语句改变作用域链"></a><code>with</code>语句改变作用域链</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">initUI</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">with</span>(<span class="built_in">document</span>)&#123;</div><div class="line">        <span class="keyword">var</span> bd=body,</div><div class="line">        links=getElementsByTagName(<span class="string">"a"</span>),</div><div class="line">        i=<span class="number">0</span>,</div><div class="line">        len=links.length;</div><div class="line">        <span class="keyword">while</span>(i &lt; len)&#123;</div><div class="line">            update(links[i++]);</div><div class="line">        &#125;</div><div class="line">        getElementById(<span class="string">"btnInit"</span>).onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            doSomething();</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>向上面的代码，通过当代码运行到<code>with(document)</code>的时候，<code>initUI</code>的运行环境中的作用域链被改变了，改变如下：</p>
<ol>
<li>创建一个新的变量对象，并将<code>document</code>变量对象中的所有属性添加进去</li>
<li>将这个新的变量对象放到执行环境作用域链的头部。</li>
</ol>
<p><img src="/assets/images/blog_img/2017-02-14-ECMAScript中的作用域链和闭包/scope_chain_2.png" alt=""></p>
<p style="text-align: center"><em>图片来自网络</em></p>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>了解了上面的执行环境，变量对象、活动对象，作用域链的概念以后闭包就很容易理解了。</p>
<p>就是如果在一个函数内部定义的函数的作用域链中包含创建他的外层函数的活动对象，即使外层函数返回，外层函数的执行环境销毁，但是他的活动对象仍然被内部的函数的作用域链引用着，因此不会被销毁。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html" target="_blank" rel="external">JavaScript 开发进阶：理解 JavaScript 作用域和作用域链</a></li>
<li>《JavaScript高级程序设计(第3版)》</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ECMAScript </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ECMAScript中的OOP-继承]]></title>
      <url>http://pytlab.github.io/2017/02/08/ECMAScript%E4%B8%AD%E7%9A%84OOP-%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<p>本文总结下ECMAScript中继承的几种实现模式。</p>
<h2 id="继承模式"><a href="#继承模式" class="headerlink" title="继承模式"></a>继承模式</h2><p>许多OO语言都支持两种继承模式：</p>
<ol>
<li>接口继承</li>
<li>实现继承</li>
</ol>
<p>C++中可以通过纯虚函数，虚函数来实现接口继承，同时如果不是虚函数则再派生中无法修改函数的实现，便是实现继承。而js中没有函数签名则无法仅继承接口，只支持实现继承，实现的方式便是<strong>原型链</strong></p>
<a id="more"></a>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>原型链的本质就是<strong>用父类的实例替换掉子类构造函数的原型对象</strong>。</p>
<p><img src="/assets/images/blog_img/2017-02-11-ECMAScript中的OOP-继承/prototype_0.png" alt=""></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</div><div class="line">... this.firstName = <span class="string">'father'</span>;</div><div class="line">... this.lastName = <span class="string">'shao'</span>;</div><div class="line">... &#125;</div><div class="line">&gt; Father.prototype.getFirstName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">... console.log(<span class="keyword">this</span>.firstName);</div><div class="line">... &#125;</div><div class="line">[<span class="built_in">Function</span>]</div><div class="line">&gt; Father.prototype.getLastName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">... console.log(<span class="keyword">this</span>.lastName);</div><div class="line">... &#125;</div><div class="line">[<span class="built_in">Function</span>]</div></pre></td></tr></table></figure>
<p>首先先创建一个<code>Father</code>类，然后我们通过原型链来实现<code>Son</code>类继承<code>Father</code>类。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;</div><div class="line">... this.firstName = <span class="string">'son'</span>;</div><div class="line">... &#125;</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; Son.prototype = <span class="keyword">new</span> Father();</div><div class="line">Father &#123; <span class="attr">firstName</span>: <span class="string">'father'</span>, <span class="attr">lastName</span>: <span class="string">'shao'</span> &#125;</div></pre></td></tr></table></figure></p>
<p>这个时候我用一个<code>Father</code>类的实例重写（替换）了<code>Son</code>类的原型对象，这个时候如果<code>Son</code>的实例中没有找到相应的属性便会去<code>Son</code>类的原型中去找，这个时候<code>Son</code>类的原型是<code>Father</code>的实例，也就是继承了<code>Father</code>类了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">var</span> father = <span class="keyword">new</span> Father();</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; <span class="keyword">var</span> son = <span class="keyword">new</span> Son();</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; son.firstName</div><div class="line"><span class="string">'son'</span></div><div class="line">&gt; father.firstName</div><div class="line"><span class="string">'father'</span></div><div class="line">&gt; son.lastName </div><div class="line"><span class="string">'shao'</span>  <span class="comment">// 这个时候的这个属性是Father实例中的</span></div><div class="line">&gt; father.lastName</div><div class="line"><span class="string">'shao'</span></div><div class="line">&gt; <span class="built_in">Object</span>.getPrototypeOf(son).constructor</div><div class="line">[<span class="built_in">Function</span>: Father]  <span class="comment">// son原型是一个Father实例</span></div></pre></td></tr></table></figure></p>
<p>这样，若要新的类需要继承自<code>Son</code>，则需要用<code>Son</code>的实例替换掉子类的原型对象，这样便形成了一个链，多个构造函数通过这个链实现了继承的效果，这便是原型链了。</p>
<p><img src="/assets/images/blog_img/2017-02-11-ECMAScript中的OOP-继承/prototype_chain.png" alt=""></p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li><p>最主要的问题：原型中包含引用值，这样不同的实例引用同一个对象。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</div><div class="line">... this.items = [<span class="string">'car'</span>, <span class="string">'house'</span>, <span class="string">'money'</span>];</div><div class="line">... &#125;</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; Son.prototype = <span class="keyword">new</span> Father()</div><div class="line">Father &#123; <span class="attr">items</span>: [ <span class="string">'car'</span>, <span class="string">'house'</span>, <span class="string">'money'</span> ] &#125;</div><div class="line">&gt; <span class="keyword">var</span> s1 = <span class="keyword">new</span> Son()</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; <span class="keyword">var</span> s2 = <span class="keyword">new</span> Son()</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; s1.items</div><div class="line">[ <span class="string">'car'</span>, <span class="string">'house'</span>, <span class="string">'money'</span> ]</div><div class="line">&gt; s2.items</div><div class="line">[ <span class="string">'car'</span>, <span class="string">'house'</span>, <span class="string">'money'</span> ]</div></pre></td></tr></table></figure>
<p> 这个时候我们修改<code>s1</code>的<code>items</code>对象也会修改<code>s2</code>的<code>items</code>对象，因为items对象都是对原型对象中的<code>items</code>引用。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; s2.items.push(<span class="string">'watch'</span>)</div><div class="line"><span class="number">4</span></div><div class="line">&gt; s1.items</div><div class="line">[ <span class="string">'car'</span>, <span class="string">'house'</span>, <span class="string">'money'</span>, <span class="string">'watch'</span> ]</div><div class="line">&gt; s2.items</div><div class="line">[ <span class="string">'car'</span>, <span class="string">'house'</span>, <span class="string">'money'</span>, <span class="string">'watch'</span> ]</div></pre></td></tr></table></figure>
</li>
<li><p>在创建子类实例时，不能向父类的构造函数中传递参数</p>
</li>
</ol>
<h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><p>为了解决在单独使用原型链中的问题，我们可以使用一种叫做借用构造函数(constructor stealing)的方法，也就是<strong>在子类构造函数中调用父类的构造函数</strong>，有点像我们在Python中使用<code>super(SonClass, self).__init__(*args, **kwargs)</code>，这样我们就可以在子类中创建属于子类实例的属性副本而不是共享对象的引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name, age</span>)</span>&#123;</div><div class="line">... this.name = name;</div><div class="line">... this.age = age;</div><div class="line">... &#125;</div></pre></td></tr></table></figure>
<p>我们在<code>Son</code>构造函数中调用<code>Father</code>的构造函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age</span>)</span>&#123;</div><div class="line">... Father.call(<span class="keyword">this</span>, name, age);</div><div class="line">... this.job = <span class="string">'student'</span>;</div><div class="line">... &#125;</div><div class="line">&gt; <span class="keyword">var</span> s = <span class="keyword">new</span> Son(<span class="string">'shaozj'</span>, <span class="number">25</span>)</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; s</div><div class="line">Son &#123; <span class="attr">name</span>: <span class="string">'shaozj'</span>, <span class="attr">age</span>: <span class="number">25</span>, <span class="attr">job</span>: <span class="string">'student'</span> &#125;</div><div class="line">&gt; <span class="keyword">var</span> f = <span class="keyword">new</span> Father(<span class="string">'shaols'</span>, <span class="number">51</span>)</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; f</div><div class="line">Father &#123; <span class="attr">name</span>: <span class="string">'shaols'</span>, <span class="attr">age</span>: <span class="number">51</span> &#125;</div></pre></td></tr></table></figure></p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>如果仅仅使用构造函数而不使用原型链的话，那方法只能在构造函数中定义，这样每个实例都有自己的方法对象便无法实现方法的复用了。</p>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合继承就是将<strong>原型链</strong>和<strong>借用构造函数</strong>的技术组合到一起来实现继承，也就是我在子类构造函数中调用父类构造函数的同时，也将原型对象替换成父类的一个实例，然后<strong>重新指定子类原型的<code>constructor</code></strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 父类</span></div><div class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name, age</span>)</span>&#123;</div><div class="line">... this.name = name;</div><div class="line">... this.age = age;</div><div class="line">... &#125;</div><div class="line">&gt; Father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">... console.log(<span class="keyword">this</span>.name);</div><div class="line">... &#125;</div><div class="line"></div><div class="line"><span class="comment">// 子类</span></div><div class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age</span>)</span>&#123;</div><div class="line">... Father.call(<span class="keyword">this</span>, name, age);</div><div class="line">... this.job = <span class="string">'student'</span>;</div><div class="line">... &#125;</div><div class="line"><span class="comment">// 原型链</span></div><div class="line">&gt; Son.prototype = <span class="keyword">new</span> Father(<span class="string">'shao'</span>, <span class="number">0</span>)</div><div class="line">Father &#123; <span class="attr">name</span>: <span class="string">'shao'</span>, <span class="attr">age</span>: <span class="number">0</span> &#125;</div><div class="line"><span class="comment">// 修改constructor</span></div><div class="line">&gt; Son.prototype.constructor</div><div class="line">[<span class="built_in">Function</span>: Father]</div><div class="line">&gt; Son.prototype.constructor = Son</div><div class="line">[<span class="built_in">Function</span>: Son]</div><div class="line"></div><div class="line">&gt; <span class="keyword">var</span> s = <span class="keyword">new</span> Son(<span class="string">'shaozj'</span>, <span class="number">25</span>)</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; s</div><div class="line">Son &#123; <span class="attr">name</span>: <span class="string">'shaozj'</span>, <span class="attr">age</span>: <span class="number">25</span>, <span class="attr">job</span>: <span class="string">'student'</span> &#125;</div><div class="line">&gt; <span class="keyword">var</span> f = <span class="keyword">new</span> Father(<span class="string">'shaols'</span>, <span class="number">51</span>)</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; f</div><div class="line">Father &#123; <span class="attr">name</span>: <span class="string">'shaols'</span>, <span class="attr">age</span>: <span class="number">51</span> &#125;</div></pre></td></tr></table></figure></p>
<p><code>instanceof</code>和<code>isPrototypeOf()</code>可以识别基于组合继承创建的对象，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; s</div><div class="line">Son &#123; <span class="attr">name</span>: <span class="string">'shaozj'</span>, <span class="attr">age</span>: <span class="number">25</span>, <span class="attr">job</span>: <span class="string">'student'</span> &#125;</div><div class="line">&gt; s <span class="keyword">instanceof</span> Son</div><div class="line"><span class="literal">true</span></div><div class="line">&gt; s <span class="keyword">instanceof</span> Father</div><div class="line"><span class="literal">true</span></div><div class="line">&gt; <span class="built_in">Object</span>.getPrototypeOf(s)</div><div class="line">Son &#123; <span class="attr">name</span>: <span class="string">'shao'</span>, <span class="attr">age</span>: <span class="number">0</span>, <span class="attr">constructor</span>: [<span class="built_in">Function</span>: Son] &#125;</div></pre></td></tr></table></figure></p>
<div class="alert alert-info"><i class="fa fa-info"></i>  组合继承避免了原型链和借用构造函数的缺陷，融合了他们的有点，是js中最常用的继承模式</div>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>调用了两次父类的构造函数：一次是在子类构造函数中，一次是在创建子类原型对象的时候。</p>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>原型式继承一句话总结可以是：对父类对象进行一次浅复制而得到子类对象。</p>
<p>实现的方式是通过将父类实例赋给子类（临时）构造函数的原型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">    F.prototype = o;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ECMAScript5提供了<code>Object.create()</code>方法来规范化原型式继承。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">var</span> father = &#123;</div><div class="line">... lastName: <span class="string">'shao'</span>,</div><div class="line">... &#125;</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; <span class="keyword">var</span> s1 = <span class="built_in">Object</span>.create(father)</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; <span class="keyword">var</span> s2 = <span class="built_in">Object</span>.create(father)</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; s1.name === s2.name</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点:"></a>缺点:</h3><p>不同实例的属性都是对父类对象（传入）的属性的引用，因此折合使用<a href="http://pytlab.org/2017/02/06/ECMAScript中的OOP-创建对象/#原型模式" target="_blank" rel="external"><strong>原型模式</strong></a>创建对象的效果是一样的。<br>因此在完全没有必要兴师动众的创建构造函数，而只是想让一个对象与另一个对象保持类似（浅复制）的情况下，我们可以使用原型继承模式。</p>
<h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>就是再原型式的基础上将子类对象的属性添加都封装进函数中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createOne</span>(<span class="params">o</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> clone = object(o);  <span class="comment">// 使用原型式浅复制创建副本</span></div><div class="line">    clone.saySomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="string">"hi"</span>);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> clone;</div></pre></td></tr></table></figure></p>
<h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><p>使用寄生式继承来为对象添加函数，会造成无法复用而降低效率，类似构造模式创建对象一样。</p>
<h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>由于组合式继承有调用两次父类构造函数的缺陷，寄生组合是继承便通过寄生继承用于子类原型的创建，也就是说我们通过寄生函数创建父类原型对象的一个副本，然后<strong>用这个副本去当子类的原型</strong>，这样就避免了第一次的父类构造函数的调用。</p>
<p>完整的实现：</p>
<ol>
<li><p>先来个返回浅复制副本的函数，此函数不需要调用父类构造函数便可返回父类原型对象的副本</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">o</span>)</span>&#123;</div><div class="line">... function F()&#123;&#125;;</div><div class="line">... F.prototype = o;</div><div class="line">... return <span class="keyword">new</span> F();</div><div class="line">... &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>再来个辅助函数将父类和子类通过原型链联系起来</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123;</div><div class="line">... var prototype = clone(superType.prototype);  <span class="comment">// 获取父类原型副本</span></div><div class="line">... prototype.constructor = subType;             <span class="comment">// 使constructor指向子类构造函数</span></div><div class="line">... subType.prototype = prototype;               <span class="comment">// 替换子类构造函数原型对象</span></div><div class="line">... &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>借用构造函数继承</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">... this.name = name;</div><div class="line">... &#125;</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; Father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">... console.log(<span class="keyword">this</span>.name);</div><div class="line">... &#125;</div><div class="line">[<span class="built_in">Function</span>]</div><div class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age</span>)</span>&#123;</div><div class="line">... Father.call(<span class="keyword">this</span>, name);</div><div class="line">... this.age = age;</div><div class="line">... &#125;</div><div class="line"><span class="literal">undefined</span></div><div class="line"><span class="comment">// 关联原型</span></div><div class="line">&gt; inheritPrototype(Son, Father)</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; Son.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">... console.log(<span class="keyword">this</span>.age);</div><div class="line">... &#125;</div><div class="line">[<span class="built_in">Function</span>]</div><div class="line">&gt; <span class="keyword">var</span> f = <span class="keyword">new</span> Father(<span class="string">'ls'</span>)</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; <span class="keyword">var</span> s = <span class="keyword">new</span> Son(<span class="string">'zj'</span>, <span class="number">25</span>)</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; f</div><div class="line">Father &#123; <span class="attr">name</span>: <span class="string">'ls'</span> &#125;</div><div class="line">&gt; s</div><div class="line">Son &#123; <span class="attr">name</span>: <span class="string">'zj'</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;</div><div class="line">&gt; f.sayName()</div><div class="line">ls</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; s.sayName()</div><div class="line">zj</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; s.sayAge()</div><div class="line"><span class="number">25</span></div><div class="line"><span class="literal">undefined</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>这样我们充分利用了构造函数和原型链的优点有避免了重复的调用和重复的属性赋值，构造函数负责属性，原型链负责共享方法。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ECMAScript </tag>
            
            <tag> JavaScript </tag>
            
            <tag> OOP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ECMAScript中的OOP-对象创建]]></title>
      <url>http://pytlab.github.io/2017/02/06/ECMAScript%E4%B8%AD%E7%9A%84OOP-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<p>在ECMAScript中我们总不能使用<code>Object</code>构造函数或者字面量直接定义对象，这样将会产生大量的重复代码。</p>
<p>这里将ECMAScript中几种面向对象中的创建对象的方法进行总结, 其中包括：</p>
<ul>
<li>工厂模式</li>
<li>构造函数模式</li>
<li>原型模式</li>
<li>组合使用构造函数和原型模式</li>
<li>动态原型模式</li>
</ul>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>就是将对象的创建以及属性的添加等细节都封装在一个能够接受参数的函数中。</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">... var person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">... person.name = name;</div><div class="line">... person.age = age;</div><div class="line">... person.job = job;</div><div class="line">... person.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">..... console.log(<span class="keyword">this</span>.name);</div><div class="line">..... &#125;</div><div class="line">... return person;</div><div class="line">... &#125;</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; p1 = createPerson(<span class="string">'shao'</span>, <span class="number">24</span>, <span class="string">'student'</span>)</div><div class="line">&#123; <span class="attr">name</span>: <span class="string">'shao'</span>, <span class="attr">age</span>: <span class="number">24</span>, <span class="attr">job</span>: <span class="string">'student'</span>, <span class="attr">sayName</span>: [<span class="built_in">Function</span>] &#125;</div><div class="line">&gt; p2 = createPerson(<span class="string">'zhao'</span>, <span class="number">25</span>, <span class="string">'saler'</span>)</div><div class="line">&#123; <span class="attr">name</span>: <span class="string">'zhao'</span>, <span class="attr">age</span>: <span class="number">25</span>, <span class="attr">job</span>: <span class="string">'saler'</span>, <span class="attr">sayName</span>: [<span class="built_in">Function</span>] &#125;</div></pre></td></tr></table></figure>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>仅仅通过一个普通的工厂函数无法解决对象识别的问题，即无法知道一个对象的类型。</p>
<h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><p>像<code>Object</code>，<code>Array</code>这些都有原生的构造函数并且运行是会自动加载到执行环境中，我们可以用来创建相应的对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div></pre></td></tr></table></figure></p>
<p>我们也可以自己创建自定义的构造函数，定义自定义的对象属性和方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<div class="alert alert-info"><i class="fa fa-info"></i>  与普通工厂相比，构造函数有如下不同：
<li>没有显式的创建对象</li>
<li>直接将属性和方法赋给<code>this</code></li>
<li>没有<code>return</code>语句</li></div>
<p>创建该对象使用<code>new</code>操作符:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'shao'</span>, <span class="number">24</span>, <span class="string">'student'</span>)</div></pre></td></tr></table></figure></p>
<div class="alert alert-warning"><i class="fa fa-bell"></i>  使用<code>new</code>操作符调用构造函数创建对象经历了如下的步骤：
<li>创建新<code>Object</code>对象</li>
<li>将构造函数的作用于赋给新的对象，也就是将<code>this</code>指向该对象</li>
<li>执行中括号中的函数体代码</li>
<li>返回该对象</li></div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">typeof</span> person</div><div class="line"><span class="string">'object'</span></div><div class="line">&gt; person <span class="keyword">instanceof</span> Person</div><div class="line"><span class="literal">true</span></div><div class="line">&gt; person <span class="keyword">instanceof</span> <span class="built_in">Object</span></div><div class="line"><span class="literal">true</span></div><div class="line">&gt; person.constructor</div><div class="line">[<span class="built_in">Function</span>: Person]</div></pre></td></tr></table></figure>
<p>可见<code>person</code>对象仍是<code>Object</code>实例，当然也是<code>Person</code>实例。</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>如果方法的绑定在构造函数中则不同的实例的同名函数是不同的函数对象，使其无法在不同实例中共享。</li>
<li>若将函数定义为全局函数，但如果对象需要定义很多方法，就要定义很多全局函数，便也没有什么<strong>封装性</strong>可言了。</li>
</ul>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p><img src="/assets/images/blog_img/2017-02-06-ECMAScript中的OOP-创建对象/prototype.jpg" alt=""></p>
<p>我先总结一下原型对象与构造函数以及实例之间的关系：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line">... this.name = name;</div><div class="line">... this.age = age;</div><div class="line">... this.job = job;</div><div class="line">... &#125;</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">... console.log(<span class="keyword">this</span>.name);</div><div class="line">... &#125;</div><div class="line">[<span class="built_in">Function</span>]</div><div class="line">&gt; <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'shao'</span>, <span class="number">24</span>, <span class="string">'student'</span>)</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'zhao'</span>, <span class="number">25</span>, <span class="string">'saler'</span>)</div><div class="line"><span class="literal">undefined</span></div></pre></td></tr></table></figure>
<ol>
<li><p><strong>原型对象</strong>与<strong>构造函数</strong></p>
<ul>
<li>无论什么时候创建了一个新函数，就会根据一定的规则为这个函数创建一个原型对象，这个函数对象中有一个属性<code>prototype</code>指向这个原型对象。</li>
<li><p>原型对象中也有一个<code>constructor</code>属性指向构造函数</p>
<p>这样原型对象与构造函数都可以互相访问。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; Person.prototype</div><div class="line">Person &#123; <span class="attr">sayName</span>: [<span class="built_in">Function</span>] &#125;</div><div class="line">&gt; Person.prototype.constructor</div><div class="line">[<span class="built_in">Function</span>: Person]</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>原型对象</strong>与<strong>实例</strong><br> 实例内部将包含一个指针（内部属性）<code>[[prototype]]</code>指向原型对象<br> 虽然是内部属性我们无法直接访问，但是我们可以借助<code>Object.getPrototypeOf()</code>函数来获取实例的原型对象。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">Object</span>.getPrototypeOf(p1)</div><div class="line">Person &#123; <span class="attr">sayName</span>: [<span class="built_in">Function</span>] &#125;</div><div class="line">&gt; <span class="built_in">Object</span>.getPrototypeOf(p1) === <span class="built_in">Object</span>.getPrototypeOf(p2)</div><div class="line"><span class="literal">true</span></div><div class="line">&gt; Person.prototype.isPrototypeOf(p1)</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>构造函数</strong>与<strong>实例</strong><br> 实例访问<code>constructor</code>的时候会进行一次搜索，从实例 -&gt; 原型对象然后将<code>constructor</code>返回，实例也就能够通过<code>constructor</code>访问构造函数本身了。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; p1.constructor</div><div class="line">[<span class="built_in">Function</span>: Person]</div><div class="line">&gt; p1.constructor === p2.constructor</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="原型与in操作符"><a href="#原型与in操作符" class="headerlink" title="原型与in操作符"></a>原型与<code>in</code>操作符</h3><p>只要是实例能够访问到相应的属性，无论该属性是原型对象中还是对象本身的，<code>in</code>操作符就会返回<code>true</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; Person.prototype.name = <span class="string">'shao'</span></div><div class="line"><span class="string">'shao'</span></div><div class="line">&gt; Person.prototype.age = <span class="number">24</span></div><div class="line"><span class="number">24</span></div><div class="line">&gt; <span class="keyword">var</span> person = <span class="keyword">new</span> Person()</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; person.job = <span class="string">'student'</span></div><div class="line"><span class="string">'student'</span></div><div class="line">&gt; <span class="string">'job'</span> <span class="keyword">in</span> person</div><div class="line"><span class="literal">true</span></div><div class="line">&gt; <span class="string">'name'</span> <span class="keyword">in</span> person</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure></p>
<h3 id="Object-keys-和-Object-getOwnPropertyNames"><a href="#Object-keys-和-Object-getOwnPropertyNames" class="headerlink" title="Object.keys() 和 Object.getOwnPropertyNames()"></a><code>Object.keys()</code> 和 <code>Object.getOwnPropertyNames()</code></h3><p>这两个方法都是返回属于实例本身的属性，不向上到原型中继续查找。区别在于是否能返回不可枚举的属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">Object</span>.getOwnPropertyNames(person)</div><div class="line">[ <span class="string">'job'</span> ]</div><div class="line">&gt; <span class="built_in">Object</span>.keys(person)</div><div class="line">[ <span class="string">'job'</span> ]</div><div class="line">&gt; <span class="built_in">Object</span>.getOwnPropertyNames(Person.prototype)</div><div class="line">[ <span class="string">'constructor'</span>, <span class="string">'name'</span>, <span class="string">'age'</span> ]</div><div class="line">&gt; <span class="built_in">Object</span>.keys(Person.prototype)</div><div class="line">[ <span class="string">'name'</span>, <span class="string">'age'</span> ]</div></pre></td></tr></table></figure></p>
<h3 id="更简单的原型模式写法"><a href="#更简单的原型模式写法" class="headerlink" title="更简单的原型模式写法"></a>更简单的原型模式写法</h3><p>可以通过直接将构造函数的原型对象替换成新的对象来简化写法，不需要再写一堆<code>.prototype</code>了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; Person.prototype = &#123;</div><div class="line">... name: <span class="string">'shao'</span>,</div><div class="line">... age: <span class="number">24</span></div><div class="line">... &#125;</div><div class="line">&#123; <span class="attr">name</span>: <span class="string">'shao'</span>, <span class="attr">age</span>: <span class="number">24</span> &#125;</div><div class="line">&gt; <span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">'constructor'</span>, &#123;</div><div class="line">... enumerable: <span class="literal">false</span>,</div><div class="line">... value: Person&#125;)</div><div class="line">Person &#123; <span class="attr">name</span>: <span class="string">'shao'</span>, <span class="attr">age</span>: <span class="number">24</span> &#125;</div></pre></td></tr></table></figure></p>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>忽略了构造函数初始化参数的传递</li>
<li>所有属性都是共享的</li>
</ul>
<h2 id="组合使用构造函数和原型模式"><a href="#组合使用构造函数和原型模式" class="headerlink" title="组合使用构造函数和原型模式"></a>组合使用构造函数和原型模式</h2><p>这样使得实例都有自己的属性副本，共享方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</div><div class="line">... this.name = name;</div><div class="line">... this.age = age;</div><div class="line">... &#125;</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">... console.log(<span class="keyword">this</span>.name);</div><div class="line">... &#125;</div><div class="line">[<span class="built_in">Function</span>]</div><div class="line">&gt; <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'shao'</span>, <span class="number">24</span>)</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'zhao'</span>, <span class="number">25</span>)</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; p1.sayName()</div><div class="line">shao</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; p2.sayName()</div><div class="line">zhao</div><div class="line"><span class="literal">undefined</span></div><div class="line">&gt; p1.sayName === p2.sayName</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<p>这种混合模式是目前使用最广泛的一种创建自定义类型的方法。</p>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><p>构造函数和原型是相互独立的（算是缺点么？</p>
<h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><p>这种模式就将属性添加和原型的操作都封装到了构造函数中,之所以叫动态原型，我们在构造函数中需要动态的判断是否要给原型对象添加属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> Person.prototype.sayName != <span class="string">'function'</span>)&#123;</div><div class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说只有在第一次调用构造函数创建实例的时候条件才满足，才会给原型对象添加属性，这也就是多个实例共享一个方法。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ECMAScript </tag>
            
            <tag> JavaScript </tag>
            
            <tag> OOP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ECMAScript对象属性小结]]></title>
      <url>http://pytlab.github.io/2017/02/05/ECMAScript%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>最近两天过了一遍JS高程的前7章，第一次了解ECMAScript中基于原型(prototype-based)的面向对象的实现。思想看起来是那么的顺理成章并不难理解，但是由于属于新事物，所以打算对ECMAScript的OOP进行一下简单的小结，方便以后回来温习。</p>
<h3 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h3><p>ECMAScript对象中有两种属性：</p>
<ul>
<li>数据属性</li>
<li>访问器属性</li>
</ul>
<h3 id="属性特征值-characteristic"><a href="#属性特征值-characteristic" class="headerlink" title="属性特征值(characteristic)"></a>属性特征值(characteristic)</h3><p>ECMAScript对象创建时都带有一些特征值，JS通过这些特征值来定义对象属性的行为。</p>
<a id="more"></a>
<p>先创建一个对象为后面提供例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'shao'</span>,</div><div class="line">    <span class="attr">age</span>: <span class="number">24</span>,</div><div class="line">    <span class="attr">job</span>: <span class="string">'student'</span>,</div><div class="line">    <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="数据属性和访问器属性共有的属性特性"><a href="#数据属性和访问器属性共有的属性特性" class="headerlink" title="数据属性和访问器属性共有的属性特性"></a>数据属性和访问器属性共有的属性特性</h3><h4 id="Configurable"><a href="#Configurable" class="headerlink" title="[[Configurable]]"></a><code>[[Configurable]]</code></h4><p>表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性。<br>直接在对象上定义的属性，默认为<code>true</code>。</p>
<p>也就是说如果对象的某个属性的<code>[[configurable]]</code>特性值改为<code>false</code>，则就不能再修改这个属性的特性了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'name'</span>)</div><div class="line">&#123; <span class="attr">value</span>: <span class="string">'shao'</span>,</div><div class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">configurable</span>: <span class="literal">true</span> &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
<p>可见，默认情况下，<code>configurable</code>的值为<code>true</code>。这时我们修改<code>name</code>的值或者删除<code>name</code>属性都是可以的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; person.name = <span class="string">'zhao'</span></div><div class="line"><span class="string">'zhao'</span></div><div class="line">&gt; <span class="keyword">delete</span> person.name</div><div class="line"><span class="literal">true</span></div><div class="line">&gt; person</div><div class="line">&#123; <span class="attr">age</span>: <span class="number">24</span>, <span class="attr">job</span>: <span class="string">'student'</span>, <span class="attr">sayName</span>: [<span class="built_in">Function</span>] &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></p>
<p>但是，如果我将<code>configuratble</code>修改为<code>false</code>,这时再重复上述操作就被禁止了。</p>
<p>修改了<code>name</code>属性的<code>configurable</code>属性为<code>false</code>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">Object</span>.defineProperty(person, <span class="string">'name'</span>, &#123;<span class="attr">configurable</span>: <span class="literal">false</span>&#125;)</div><div class="line">&#123; <span class="attr">age</span>: <span class="number">24</span>, <span class="attr">job</span>: <span class="string">'student'</span>, <span class="attr">sayName</span>: [<span class="built_in">Function</span>], <span class="attr">name</span>: <span class="string">'shao'</span> &#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; person.name = <span class="string">'zhao'</span></div><div class="line"><span class="string">'zhao'</span></div><div class="line">&gt; person.name</div><div class="line"><span class="string">'zhao'</span></div><div class="line">&gt; <span class="keyword">delete</span> person.name</div><div class="line"><span class="literal">false</span></div><div class="line">&gt; person.name</div><div class="line"><span class="string">'zhao'</span></div></pre></td></tr></table></figure>
<p>可见，我们还是可以对该属性的值进行修改的，但是如果我们想删除这个属性的时候便会失败。</p>
<p>看看如果我们再想将<code>[[configurable]]</code>属性特性再修改回<code>true</code>会怎样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">Object</span>.defineProperty(person, <span class="string">'name'</span>, &#123;<span class="attr">configurable</span>: <span class="literal">true</span>&#125;)</div><div class="line"><span class="built_in">TypeError</span>: Cannot redefine property: name</div><div class="line">    at <span class="built_in">Function</span>.defineProperty (native)</div><div class="line">    at repl:<span class="number">1</span>:<span class="number">8</span></div><div class="line">    at REPLServer.defaultEval (repl.js:<span class="number">252</span>:<span class="number">27</span>)</div><div class="line">    at bound (domain.js:<span class="number">287</span>:<span class="number">14</span>)</div><div class="line">    at REPLServer.runBound [<span class="keyword">as</span> <span class="built_in">eval</span>] (domain.js:<span class="number">300</span>:<span class="number">12</span>)</div><div class="line">    at REPLServer.&lt;anonymous&gt; (repl.js:<span class="number">417</span>:<span class="number">12</span>)</div><div class="line">    at emitOne (events.js:<span class="number">82</span>:<span class="number">20</span>)</div><div class="line">    at REPLServer.emit (events.js:<span class="number">169</span>:<span class="number">7</span>)</div><div class="line">    at REPLServer.Interface._onLine (readline.js:<span class="number">210</span>:<span class="number">10</span>)</div><div class="line">    at REPLServer.Interface._line (readline.js:<span class="number">549</span>:<span class="number">8</span>)</div><div class="line">&gt; person</div></pre></td></tr></table></figure></p>
<h4 id="Enumerable"><a href="#Enumerable" class="headerlink" title="[[Enumerable]]"></a><code>[[Enumerable]]</code></h4><p>表示能否通过<code>for-in</code>循环返回该属性，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">for</span> (i <span class="keyword">in</span> person) &#123;</div><div class="line">... console.log(i);</div><div class="line">... &#125;</div><div class="line">name</div><div class="line">age</div><div class="line">job</div><div class="line">sayName</div><div class="line">&gt;</div></pre></td></tr></table></figure></p>
<p>可见这个对象的所有属性默认的<code>[[Enumerable]]</code>属性都为<code>true</code>。</p>
<p>但如果我将<code>name</code>的<code>[[Enumerable]]</code>改为<code>false</code>，输出中便不会出现<code>name</code>属性了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">Object</span>.defineProperty(person, <span class="string">'name'</span>, &#123;<span class="attr">enumerable</span>: <span class="literal">false</span>&#125;)</div><div class="line">&#123; <span class="attr">age</span>: <span class="number">24</span>, <span class="attr">job</span>: <span class="string">'student'</span>, <span class="attr">sayName</span>: [<span class="built_in">Function</span>] &#125;</div><div class="line">&gt; <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">'name'</span>)</div><div class="line">&#123; <span class="attr">value</span>: <span class="string">'shao'</span>,</div><div class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</div><div class="line">  <span class="attr">configurable</span>: <span class="literal">true</span> &#125;</div><div class="line">&gt; <span class="keyword">for</span> (i <span class="keyword">in</span> person) &#123;</div><div class="line">... console.log(i);</div><div class="line">... &#125;</div><div class="line">age</div><div class="line">job</div><div class="line">sayName</div><div class="line">&gt;</div></pre></td></tr></table></figure>
<h3 id="数据属性特性"><a href="#数据属性特性" class="headerlink" title="数据属性特性"></a>数据属性特性</h3><h4 id="Writable"><a href="#Writable" class="headerlink" title="[[Writable]]"></a><code>[[Writable]]</code></h4><p>该属性表示能否修改属性的值，默认值为<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">Object</span>.defineProperty(person, <span class="string">'name'</span>, &#123;<span class="attr">writable</span>: <span class="literal">false</span>&#125;)</div><div class="line">&#123; <span class="attr">name</span>: <span class="string">'shao'</span>, <span class="attr">age</span>: <span class="number">24</span>, <span class="attr">job</span>: <span class="string">'student'</span> &#125;</div><div class="line">&gt; person.name = <span class="string">'zhao'</span></div><div class="line"><span class="string">'zhao'</span></div><div class="line">&gt; person.name</div><div class="line"><span class="string">'shao'</span></div></pre></td></tr></table></figure>
<p>可见我们无法修改<code>name</code>属性的值了。</p>
<h4 id="Value"><a href="#Value" class="headerlink" title="[[Value]]"></a><code>[[Value]]</code></h4><p>这个包含这个属性的数据值。读取属性的时候再这个位置读取;写入数据的时候把新值保存再这个位置。这个位置的值默认值为<code>undefined</code>。</p>
<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><h4 id="Get"><a href="#Get" class="headerlink" title="[[Get]]"></a><code>[[Get]]</code></h4><p>这个属性特性就是在读取属性的时候调用的函数，相当与Python描述符中的<code>__get__()</code>方法，也就是属性的<code>getter</code>方法。</p>
<h4 id="Set"><a href="#Set" class="headerlink" title="[[Set]]"></a><code>[[Set]]</code></h4><p>这个属性特性就是在写入属性的时候调用的函数，相当于Python描述符中的<code>__set__()</code>方法。</p>
<p>具体的来个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">var</span> person = &#123;</div><div class="line">... _name: <span class="string">'shao'</span>,</div><div class="line">... age: <span class="number">24</span></div><div class="line">... &#125;</div><div class="line"></div><div class="line">&gt; <span class="built_in">Object</span>.defineProperty(person, <span class="string">'name'</span>, &#123;</div><div class="line">... get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">..... return <span class="keyword">this</span>._name;</div><div class="line">..... &#125;,</div><div class="line">... set: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">..... this._name = name;</div><div class="line">..... &#125;</div><div class="line">... &#125;)</div><div class="line">&#123; <span class="attr">_name</span>: <span class="string">'shao'</span>, <span class="attr">age</span>: <span class="number">24</span> &#125;</div><div class="line">&gt; person.name</div><div class="line"><span class="string">'shao'</span></div><div class="line">&gt; person.name = <span class="string">'zhao'</span></div><div class="line"><span class="string">'zhao'</span></div><div class="line">&gt; person.name</div><div class="line"><span class="string">'zhao'</span></div></pre></td></tr></table></figure>
<h3 id="关于描述符"><a href="#关于描述符" class="headerlink" title="关于描述符"></a>关于描述符</h3><p>虽然都叫描述符(descriptor)，但是ECMAScript中和Python的完全是两个不同的概念。</p>
<ul>
<li>在JS中，描述符就是个对象(object)，这个对象描述了对象的属性，也就是一个包含<code>configurable</code>, <code>writable</code>, <code>enumerable</code>, <code>value</code>, <code>get</code>, <code>set</code>的对象而已。</li>
<li>而在Python中描述符是一个实现描述符协议的对象，类似js中的访问器属性。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ECMAScript </tag>
            
            <tag> JavaScript </tag>
            
            <tag> OOP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python多进程并行编程实践-multiprocessing模块]]></title>
      <url>http://pytlab.github.io/2017/01/19/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5-multiprocessing%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>并行计算是使用并行计算机来减少单个计算问题所需要的时间，我们可以通过利用编程语言显式的说明计算中的不同部分如何再不同的处理器上同时执行来设计我们的并行程序，最终达到大幅度提升程序效率的目的。</p>
<p>众所周知，Python中的GIL限制了Python多线程并行对多核CPU的利用，但是我们仍然可以通过各种其他的方式来让Python真正利用多核资源, 例如通过C/C++扩展来实现多线程/多进程, 以及直接利用Python的多进程模块multiprocessing来进行多进程编程。</p>
<p>本文主要尝试仅仅通过python内置的multiprocessing模块对自己的动力学计算程序来进行优化和效率提升，其中:</p>
<ul>
<li>实现了单机利用多核资源来实现并行并进行加速对比</li>
<li>使用manager模块实现了简单的多机的分布式计算</li>
</ul>
<a id="more"></a>
<p>本文并不是对Python的multiprocessing模块的接口进行翻译介绍，需要熟悉multiprocessing的童鞋可以参考官方文档<a href="https://docs.python.org/2/library/multiprocessing.html。" target="_blank" rel="external">https://docs.python.org/2/library/multiprocessing.html。</a></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>最近想用自己的微观动力学程序进行一系列的求解并将结果绘制成二维Map图进行可视化，这样就需要对二维图上的多个点进行计算并将结果收集起来并进行绘制，由于每个点都需要进行一次ODE积分以及牛顿法求解方程组，因此要串行地绘制整张图可能会遇到极低的效率问题尤其是对参数进行测试的时候，每画一张图都需要等很久的时间。其中绘制的二维图中每个点都是独立计算的，于是很自然而然的想到了进行并行化处理。</p>
<h3 id="串行的原始版本"><a href="#串行的原始版本" class="headerlink" title="串行的原始版本"></a>串行的原始版本</h3><p>由于脚本比较长，而且实现均为自己的程序，脚本的大致结构如下, 本质是一个二重循环，循环的变量分别为反应物气体（O2 和 CO）的分压的值:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"><span class="comment"># 省略若干...</span></div><div class="line"></div><div class="line">pCOs = np.linspace(<span class="number">1e-5</span>, <span class="number">0.5</span>, <span class="number">10</span>)</div><div class="line">pO2s = np.linspace(<span class="number">1e-5</span>, <span class="number">0.5</span>, <span class="number">10</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="string">"__main__"</span> == __name__:</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        start = time.time()</div><div class="line">        <span class="keyword">for</span> i, pO2 <span class="keyword">in</span> enumerate(pO2s):</div><div class="line">            <span class="comment"># ...</span></div><div class="line">            <span class="keyword">for</span> j, pCO <span class="keyword">in</span> enumerate(pCOs):</div><div class="line">                <span class="comment"># 针对当前的分压值 pCO, pO2进行动力学求解</span></div><div class="line">                <span class="comment"># 具体代码略...</span></div><div class="line">        end = time.time()</div><div class="line">        t = end - start</div><div class="line">    <span class="keyword">finally</span>:</div><div class="line">        <span class="comment"># 收集计算的结果并进行处理绘图</span></div></pre></td></tr></table></figure></p>
<p>整体过程就这么简单，我需要做的就是使用multiprocessing的接口来对这个二重循环进行并行化。</p>
<p>使用单核串行绘制100个点所需要的时间如下, 总共花了240.76秒：<br><img src="/assets/images/blog_img/2017-01-19-Python多进程并行编程实践-multiprocessing模块/serial_time.png" alt=""></p>
<p>二维map图绘制的效果如下:<br><img src="/assets/images/blog_img/2017-01-19-Python多进程并行编程实践-multiprocessing模块/map.png" alt=""></p>
<h3 id="进行多进程并行处理"><a href="#进行多进程并行处理" class="headerlink" title="进行多进程并行处理"></a>进行多进程并行处理</h3><h4 id="multiprocessing模块"><a href="#multiprocessing模块" class="headerlink" title="multiprocessing模块"></a>multiprocessing模块</h4><p>multiprocessing模块提供了类似threading模块的接口，并对进程的各种操作进行了良好的封装，提供了各种进程间通信的接口例如<code>Pipe</code>, <code>Queue</code>等等，可以帮助我们实现进程间的通信，同步等操作。</p>
<h4 id="使用Process类来动态创建进程实现并行"><a href="#使用Process类来动态创建进程实现并行" class="headerlink" title="使用Process类来动态创建进程实现并行"></a>使用<code>Process</code>类来动态创建进程实现并行</h4><p>multiprocessing模块提供了<code>Process</code>能让我们通过创建进程对象并执行该进程对象的<code>start</code>方法来创建一个真正的进程来执行任务，该接口类似<code>threading</code>模块中的线程类<code>Thread</code>.</p>
<p>但是当被操作对象数目不大的时候可以使用<code>Process</code>动态生成多个进程，但是如果需要的进程数一旦很多的时候，手动限制进程的数量以及处理不同进程返回值会变得异常的繁琐，因此这个时候我们需要使用<strong>进程池</strong>来简化操作。</p>
<h4 id="使用进程池来管理进程"><a href="#使用进程池来管理进程" class="headerlink" title="使用进程池来管理进程"></a>使用进程池来管理进程</h4><p>multiprocessing模块提供了一个进程池<code>Pool</code>类，负责创建进程池对象，并提供了一些方法来讲运算任务offload到不同的子进程中执行，并很方便的获取返回值。例如我们现在要进行的循环并行便很容易的将其实现。</p>
<p>对于这里的单指令多数据流的并行，我们可以直接使用<code>Pool.map()</code>来将函数映射到参数列表中。<code>Pool.map</code>其实是map函数的并行版本，此函数将会阻塞直到所有进程全部结束，而且此函数返回的结果顺序仍然不变。</p>
<p>首先，我先把针对每对分压数据的处理过程封装成一个函数，这样可以将函数对象传递给子进程执行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</div><div class="line"></div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"><span class="comment"># 省略若干...</span></div><div class="line"></div><div class="line">pCOs = np.linspace(<span class="number">1e-5</span>, <span class="number">0.5</span>, <span class="number">10</span>)</div><div class="line">pO2s = np.linspace(<span class="number">1e-5</span>, <span class="number">0.5</span>, <span class="number">10</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(pO2)</span>:</span></div><div class="line">    <span class="string">'''接受一个O2分压，根据当前的CO分压进行动力学求解'''</span></div><div class="line">    <span class="comment"># 代码细节省略...</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="string">"__main__"</span> == __name__:</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        start = time.time()</div><div class="line">        pool = Pool()                <span class="comment"># 创建进程池对象，进程数与multiprocessing.cpu_count()相同</span></div><div class="line">        tofs = pool.map(task, pCOs)  <span class="comment"># 并行执行函数</span></div><div class="line">        end = time.time()</div><div class="line">        t = end - start</div><div class="line">    <span class="keyword">finally</span>:</div><div class="line">        <span class="comment"># 收集计算的结果并进行处理绘图</span></div></pre></td></tr></table></figure>
<p>使用两个核心进行计算，计算时间从240.76s降到了148.61秒, 加速比为1.62</p>
<p><img src="/assets/images/blog_img/2017-01-19-Python多进程并行编程实践-multiprocessing模块/two_cores.png" alt=""></p>
<h4 id="对不同核心的加速效果进行测试"><a href="#对不同核心的加速效果进行测试" class="headerlink" title="对不同核心的加速效果进行测试"></a>对不同核心的加速效果进行测试</h4><p>为了查看使用不同核心数对程序效率的改善，我对不同的核心数和加速比进行了测试绘图，效果如下:</p>
<p>运行核心数与程序运行时间：</p>
<p><img src="/assets/images/blog_img/2017-01-19-Python多进程并行编程实践-multiprocessing模块/corevstime.png" alt=""></p>
<p>运行核心数与加速比：<br><img src="/assets/images/blog_img/2017-01-19-Python多进程并行编程实践-multiprocessing模块/corevsacceleration.png" alt=""></p>
<p>可见，由于我外层循环只循环了10次因此使用的核心数超过10以后核心数的增加并不能对程序进行加速，也就是多余的核心都浪费掉了。</p>
<h3 id="使用manager实现简单的分布式计算"><a href="#使用manager实现简单的分布式计算" class="headerlink" title="使用manager实现简单的分布式计算"></a>使用manager实现简单的分布式计算</h3><p>前面使用了multiprocessing包提供的接口我们使用了再一台机器上进行多核心计算的并行处理，但是multiprocessing的用处还有更多，通过multiprocessing.managers模块，我们可以实现简单的多机分布式并行计算，将计算任务分布到不同的计算机中运行。</p>
<p>Managers提供了另外的多进程通信工具，他提供了在多台计算机之间共享数据的接口和数据对象，这些数据对象全部都是通过代理类实现的，比如<code>ListProxy</code>和<code>DictProxy</code>等等，他们都实现了与原生<code>list</code>和<code>dict</code>相同的接口，但是他们可以通过网络在不同计算机中的进程中进行共享。</p>
<p>关于managers模块的接口的详细使用可以参考官方文档：<a href="https://docs.python.org/2/library/multiprocessing.html#managers" target="_blank" rel="external">https://docs.python.org/2/library/multiprocessing.html#managers</a></p>
<p>好了现在我们开始尝试将绘图程序改造成可以在多台计算机中分布式并行的程序。改造的主要思想是：</p>
<ol>
<li>使用一台计算机作为服务端(server)，此台计算机通过一个Manager对象来管理共享对象，任务分配以及结果的接收，并再收集结果以后进行后处理（绘制二维map图）。</li>
<li>其他多台计算机可以作为客户端来接收server的数据进行计算，并将结果传到共享数据中，让server可以收集。同时再client端可以同时进行上文所实现的多进程并行来充分利用计算机的多核优势。</li>
</ol>
<p>大致可总结为下图:<br><img src="/assets/images/blog_img/2017-01-19-Python多进程并行编程实践-multiprocessing模块/distribution.png" alt=""></p>
<h4 id="服务进程"><a href="#服务进程" class="headerlink" title="服务进程"></a>服务进程</h4><p><strong>首先服务端需要一个manager对象来管理共享对象</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_manager</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">'''创建服务端manager对象.</span></div><div class="line">    '''</div><div class="line"></div><div class="line">    <span class="comment"># 自定义manager类</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">JobManager</span><span class="params">(BaseManager)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">    <span class="comment"># 创建任务队列，并将此数据对象共享在网络中</span></div><div class="line">    jobid_queue = Queue()</div><div class="line">    JobManager.register(<span class="string">'get_jobid_queue'</span>, callable=<span class="keyword">lambda</span>: jobid_queue)</div><div class="line"></div><div class="line">    <span class="comment"># 创建列表代理类，并将其共享再网络中</span></div><div class="line">    tofs = [<span class="keyword">None</span>]*N</div><div class="line">    JobManager.register(<span class="string">'get_tofs_list'</span>, callable=<span class="keyword">lambda</span>: tofs, proxytype=ListProxy)</div><div class="line"></div><div class="line">    <span class="comment"># 将分压参数共享到网络中</span></div><div class="line">    JobManager.register(<span class="string">'get_pCOs'</span>, callable=<span class="keyword">lambda</span>: pCOs, proxytype=ListProxy)</div><div class="line">    JobManager.register(<span class="string">'get_pO2s'</span>, callable=<span class="keyword">lambda</span>: pCOs, proxytype=ListProxy)</div><div class="line"></div><div class="line">    <span class="comment"># 创建manager对象并返回</span></div><div class="line">    manager = JobManager(address=(ADDR, PORT), authkey=AUTHKEY)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> manager</div></pre></td></tr></table></figure></p>
<ol>
<li><p><code>BaseManager.register</code>是一个类方法，它可以将某种类型或者可调用的对象绑定到manager对象并共享到网络中，使得其他在网络中的计算机能够获取相应的对象。<br> 例如，</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">JobManager.register(<span class="string">'get_jobid_queue'</span>, callable=<span class="keyword">lambda</span>: jobid_queue)</div></pre></td></tr></table></figure>
<p> 我就将一个返回任务队列的函数对象同manager对象绑定并共享到网络中，这样在网络中的进程就可以通过自己的manager对象的<code>get_jobid_queue</code>方法得到相同的队列，这样便实现了数据的共享.</p>
</li>
<li>创建manager对象的时候需要两个参数，<ul>
<li>address, 便是manager所在的ip以及用于监听与服务端连接的端口号，例如我如果是在内网中的<code>192.168.0.1</code>地址的<code>5000</code>端口进行监听，那么此参数可以是<code>(&#39;192.169.0.1</code>, 5000)`</li>
<li>authkey, 顾名思义，就是一个认证码，用于验证客户端时候可以连接到服务端，此参数必须是一个字符串对象.</li>
</ul>
</li>
</ol>
<p><strong>进行任务分配</strong></p>
<p>上面我们将一个任务队列绑定到了manager对象中，现在我需要将队列进行填充，这样才能将任务发放到不同的客户端来进行并行执行。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill_jobid_queue</span><span class="params">(manager, nclient)</span>:</span></div><div class="line">    indices = range(N)</div><div class="line">    interval = N/nclient</div><div class="line">    jobid_queue = manager.get_jobid_queue()</div><div class="line">    start = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(nclient):</div><div class="line">        jobid_queue.put(indices[start: start+interval])</div><div class="line">        start += interval</div><div class="line">    <span class="keyword">if</span> N % nclient &gt; <span class="number">0</span>:</div><div class="line">        jobid_queue.put(indices[start:])</div></pre></td></tr></table></figure></p>
<p>这里所谓的任务其实就是相应参数在list中的index值，这样不同计算机中得到的结果可以按照相应的index将结果填入到结果列表中，这样服务端就能在共享的网络中收集各个计算机计算的结果。</p>
<p><strong>启动服务端进行监听</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_server</span><span class="params">()</span>:</span></div><div class="line">    <span class="comment"># 获取manager</span></div><div class="line">    manager = get_manager()</div><div class="line">    <span class="keyword">print</span> <span class="string">"Start manager at &#123;&#125;:&#123;&#125;..."</span>.format(ADDR, PORT)</div><div class="line">    <span class="comment"># 创建一个子进程来启动manager</span></div><div class="line">    manager.start()</div><div class="line">    <span class="comment"># 填充任务队列</span></div><div class="line">    fill_jobid_queue(manager, NNODE)</div><div class="line">    shared_job_queue = manager.get_jobid_queue()</div><div class="line">    shared_tofs_list = manager.get_tofs_list()</div><div class="line"></div><div class="line">    queue_size = shared_job_queue.qsize()</div><div class="line"></div><div class="line">    <span class="comment"># 循环进行监听，直到结果列表被填满</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">None</span> <span class="keyword">in</span> shared_tofs_list:</div><div class="line">        <span class="keyword">if</span> shared_job_queue.qsize() &lt; queue_size:</div><div class="line">            queue_size = shared_job_queue.qsize()</div><div class="line">            <span class="keyword">print</span> <span class="string">"Job picked..."</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> manager</div></pre></td></tr></table></figure></p>
<h4 id="任务进程"><a href="#任务进程" class="headerlink" title="任务进程"></a>任务进程</h4><p>服务进程负责进行简单的任务分配和调度，任务进程则只负责获取任务并进行计算处理。</p>
<p>在任务进程（客户端）中基本代码与我们上面单机中的多核运行的脚本基本相同（因为都是同一个函数处理不同的数据），但是我们也需要为客户端创建一个manager来进行任务的获取和返回。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_manager</span><span class="params">()</span>:</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WorkManager</span><span class="params">(BaseManager)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">    <span class="comment"># 由于只是从共享网络中获取，因此只需要注册名字即可</span></div><div class="line">    WorkManager.register(<span class="string">'get_jobid_queue'</span>)</div><div class="line">    WorkManager.register(<span class="string">'get_tofs_list'</span>)</div><div class="line">    WorkManager.register(<span class="string">'get_pCOs'</span>)</div><div class="line">    WorkManager.register(<span class="string">'get_pO2s'</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 这里的地址和验证码要与服务端相同才可以进行数据共享</span></div><div class="line">    manager = WorkManager(address=(ADDR, PORT), authkey=AUTHKEY)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> manager</div></pre></td></tr></table></figure>
<p>在客户端我们仍然可以多进程利用多核资源来加速计算。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="string">"__main__"</span> == __name__:</div><div class="line"></div><div class="line">    manager = get_manager()</div><div class="line">    <span class="keyword">print</span> <span class="string">"work manager connect to &#123;&#125;:&#123;&#125;..."</span>.format(ADDR, PORT)</div><div class="line"></div><div class="line">    <span class="comment"># 将客户端本地的manager连接到相应的服务端manager</span></div><div class="line">    manager.connect()</div><div class="line"></div><div class="line">    <span class="comment"># 获取共享的结果收集列表</span></div><div class="line">    shared_tofs_list = manager.get_tofs_list()</div><div class="line"></div><div class="line">    <span class="comment"># 获取共享的任务队列</span></div><div class="line">    shared_jobid_queue = manager.get_jobid_queue()</div><div class="line"></div><div class="line">    <span class="comment"># 从服务端获取计算参数</span></div><div class="line">    pCOs = manager.get_pCOs()</div><div class="line">    shared_pO2s = manager.get_pO2s()</div><div class="line"></div><div class="line">    <span class="comment"># 创建进程池在本地计算机进行多核并行</span></div><div class="line">    pool = Pool()</div><div class="line"></div><div class="line">    <span class="keyword">while</span> <span class="number">1</span>:</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            indices = shared_jobid_queue.get_nowait()</div><div class="line">            pO2s = [shared_pO2s[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices]</div><div class="line">            <span class="keyword">print</span> <span class="string">"Run &#123;&#125;"</span>.format(str(pO2s))</div><div class="line">            tofs_2d = pool.map(task, pO2s)</div><div class="line"></div><div class="line">            <span class="comment"># Update shared tofs list.</span></div><div class="line">            <span class="keyword">for</span> idx, tofs_1d <span class="keyword">in</span> zip(indices, tofs_2d):</div><div class="line">                shared_tofs_list[idx] = tofs_1d</div><div class="line">        <span class="comment"># 直到将任务队列中的任务全部取完，结束任务进程</span></div><div class="line">        <span class="keyword">except</span> Queue.Empty:</div><div class="line">            <span class="keyword">break</span></div></pre></td></tr></table></figure></p>
<p>下面我将在3台在同一局域网中的电脑来进行简单的分布式计算测试，</p>
<ul>
<li>其中一台是实验室器群中的管理节点, 内网ip为<code>10.10.10.245</code></li>
<li>另一台为集群中的一个节点, 共有12个核心</li>
<li>最后一台为自己的本本，4个核心</li>
</ul>
<ol>
<li><p>先在服务端运行服务脚本进行任务分配和监听:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">python</span> server.<span class="keyword">py</span></div></pre></td></tr></table></figure>
</li>
<li><p>在两个客户端运行任务脚本来获取任务队列中的任务并执行</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">python</span> worker.<span class="keyword">py</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>当任务队列为空且任务完成时，任务进程终止; 当结果列表中的结果收集完毕时，服务进程也会终止。</p>
<p>执行过程如图:<br><img src="/assets/images/blog_img/2017-01-19-Python多进程并行编程实践-multiprocessing模块/dist_run.png" alt=""></p>
<p>执行结果如下图:<br><img src="/assets/images/blog_img/2017-01-19-Python多进程并行编程实践-multiprocessing模块/dist_run_result.png" alt=""><br>上面的panel为服务端监听，左下为自己的笔记本运行结果，右下panel为集群中的其中一个节点。</p>
<p>可见运行时间为56.86s，无奈，是我的本子脱了后腿(-_-!)</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过python内置模块multiprocessing实现了单机内多核并行以及简单的多台计算机的分布式并行计算，multiprocessing为我们提供了封装良好并且友好的接口来使我们的Python程序更方面利用多核资源加速自己的计算程序，希望能对使用python实现并行话的童鞋有所帮助。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://docs.python.org/2/library/multiprocessing.html" target="_blank" rel="external">https://docs.python.org/2/library/multiprocessing.html</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431929340191970154d52b9d484b88a7b343708fcc60000" target="_blank" rel="external">分布式进程-廖雪峰的官方网站</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> Parallel Computing </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python优化第一步: 性能分析实践]]></title>
      <url>http://pytlab.github.io/2016/12/20/Python%E4%BC%98%E5%8C%96%E7%AC%AC%E4%B8%80%E6%AD%A5-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. – Donald Knuth</p>
</blockquote>
<p>先扔上一句名言来镇楼。</p>
<p>当我们的确是有需要开始真正优化我们的Python程序的时候，我们要做的第一步并不是盲目的去做优化，而是对我们现有的程序进行分析，发现程序的性能瓶颈进而进行针对性的优化。这样才会使我们花时间和精力去做的优化获得最大的效果。</p>
<p>本文主要介绍Python内置的性能分析器的优雅使用方法，并以作者的一个化学动力学的程序为例子进行性能分析实践, 介绍了常用的性能分析可视化工具的使用，最后对Python程序进行初步的性能优化尝试。</p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="关于性能分析"><a href="#关于性能分析" class="headerlink" title="关于性能分析"></a>关于性能分析</h3><p>性能分析就是分析代码和正在使用的资源之间有着怎样的联系，它可以帮助我们分析运行时间从而找到程序运行的瓶颈，也可以帮助我们分析内存的使用防止内存泄漏的发生。</p>
<p>帮助我们进行性能分析的工具便是性能分析器，它主要分为两类：</p>
<ol>
<li>基于事件的性能分析(event-based profiling)</li>
<li>统计式的性能分析(statistical profiling)</li>
</ol>
<p>关于性能分析详细的概念参考: <a href="https://zh.wikipedia.org/wiki/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90" target="_blank" rel="external">性能分析-维基百科</a></p>
<h3 id="Python的性能分析器"><a href="#Python的性能分析器" class="headerlink" title="Python的性能分析器"></a>Python的性能分析器</h3><p>Python中最常用的性能分析工具主要有：cProfiler, line_profiler以及memory_profiler等。他们以不同的方式帮助我们分析Python代码的性能。我们这里主要关注Python内置的cProfiler，并使用它帮助我们分析并优化程序。</p>
<h3 id="cProfiler"><a href="#cProfiler" class="headerlink" title="cProfiler"></a>cProfiler</h3><h4 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h4><p>这里我先拿上官方文档的一个简单例子来对cProfiler的简单使用进行简单介绍。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cProfile</div><div class="line"><span class="keyword">import</span> re</div><div class="line">cProfile.run(<span class="string">'re.compile("foo|bar")'</span>)</div></pre></td></tr></table></figure></p>
<p>分析结果：<br><figure class="highlight profile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">  <span class="number">197</span> function calls (<span class="number">192</span> primitive calls) in <span class="number">0.002</span> seconds</div><div class="line"></div><div class="line">Ordered by: standard name</div><div class="line"></div><div class="line"><span class="keyword">ncalls</span>  <span class="keyword">tottime</span>  percall  <span class="keyword">cumtime</span>  percall <span class="keyword">filename</span>:lineno(function)</div><div class="line">     <span class="number">1</span>    <span class="number">0.000</span>    <span class="number">0.000</span>    <span class="number">0.001</span>    <span class="number">0.001</span> &lt;string&gt;:<span class="number">1</span>(<span class="string">&lt;module&gt;</span>)</div><div class="line">     <span class="number">1</span>    <span class="number">0.000</span>    <span class="number">0.000</span>    <span class="number">0.001</span>    <span class="number">0.001</span> re.py:<span class="number">212</span>(<span class="string">compile</span>)</div><div class="line">     <span class="number">1</span>    <span class="number">0.000</span>    <span class="number">0.000</span>    <span class="number">0.001</span>    <span class="number">0.001</span> re.py:<span class="number">268</span>(<span class="string">_compile</span>)</div><div class="line">     <span class="number">1</span>    <span class="number">0.000</span>    <span class="number">0.000</span>    <span class="number">0.000</span>    <span class="number">0.000</span> sre_compile.py:<span class="number">172</span>(<span class="string">_compile_charset</span>)</div><div class="line">     <span class="number">1</span>    <span class="number">0.000</span>    <span class="number">0.000</span>    <span class="number">0.000</span>    <span class="number">0.000</span> sre_compile.py:<span class="number">201</span>(<span class="string">_optimize_charset</span>)</div><div class="line">     <span class="number">4</span>    <span class="number">0.000</span>    <span class="number">0.000</span>    <span class="number">0.000</span>    <span class="number">0.000</span> sre_compile.py:<span class="number">25</span>(<span class="string">_identityfunction</span>)</div><div class="line">   <span class="number">3</span>/<span class="number">1</span>    <span class="number">0.000</span>    <span class="number">0.000</span>    <span class="number">0.000</span>    <span class="number">0.000</span> sre_compile.py:<span class="number">33</span>(<span class="string">_compile</span>)</div></pre></td></tr></table></figure></p>
<p>从分析报告结果中我们可以得到很多信息：</p>
<ol>
<li>整个过程一共有197个函数调用被监控，其中192个是原生调用（即不涉及递归调用）</li>
<li>总共执行的时间为0.002秒</li>
<li>结果列表中是按照标准名称进行排序，也就是按照字符串的打印方式（数字也当作字符串）</li>
<li>在列表中：<ul>
<li><code>ncalls</code>表示函数调用的次数（有两个数值表示有递归调用，总调用次数/原生调用次数）</li>
<li><code>tottime</code>是函数内部调用时间（不包括他自己调用的其他函数的时间）</li>
<li><code>percall</code>等于 <code>tottime</code>/<code>ncalls</code></li>
<li><code>cumtime</code>累积调用时间，与tottime相反，它包含了自己内部调用函数的时间</li>
<li>最后一列，文件名，行号，函数名</li>
</ul>
</li>
</ol>
<h4 id="优雅的使用"><a href="#优雅的使用" class="headerlink" title="优雅的使用"></a>优雅的使用</h4><p>Python给我们提供了很多接口方便我们能够灵活的进行性能分析，其中主要包含两个类cProfile模块的<code>Profile</code>类和pstat模块的<code>Stats</code>类。</p>
<p>我们可以通过这两个类来将代码分析的功能进行封装以便在项目的其他地方能够灵活重复的使用进行分析。</p>
<p>这里还是需要对<code>Profile</code>以及<code>Stats</code>的几个常用接口进行简单总结：</p>
<ul>
<li><code>Profile</code>类:<ul>
<li><code>enable()</code>: 开始收集性能分析数据</li>
<li><code>disable()</code>: 停止收集性能分析数据</li>
<li><code>create_stats()</code>: 停止收集分析数据，并为已收集的数据创建<code>stats</code>对象</li>
<li><code>print_stats()</code>: 创建stats对象并打印分析结果</li>
<li><code>dump_stats(filename)</code>: 把当前性能分析的结果写入文件(二进制格式)</li>
<li><code>runcall(func, *args, **kwargs)</code>: 收集被调用函数<code>func</code>的性能分析数据</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>Stats</code>类<br>  pstats模块提供的<code>Stats</code>类可以帮助我们读取和操作stats文件（二进制格式）</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pstats</div><div class="line">p = pstats.Stats(<span class="string">'stats.prof'</span>)</div></pre></td></tr></table></figure>
<p>  <code>Stats</code>类可以接受stats文件名，也可以直接接受<code>cProfile.Profile</code>对象作为数据源。</p>
<ul>
<li><code>strip_dirs()</code>: 删除报告中所有函数文件名的路径信息</li>
<li><code>dump_stats(filename)</code>: 把stats中的分析数据写入文件（效果同<code>cProfile.Profile.dump_stats()</code>)</li>
<li><code>sort_stats(*keys)</code>: 对报告列表进行排序，函数会依次按照传入的参数排序，关键词包括<code>calls</code>, <code>cumtime</code>等，具体参数参见<a href="https://docs.python.org/2/library/profile.html#pstats.Stats.sort_stats" target="_blank" rel="external">https://docs.python.org/2/library/profile.html#pstats.Stats.sort_stats</a></li>
<li><code>reverse_order()</code>: 逆反当前的排序</li>
<li><code>print_stats(*restrictions)</code>: 把信息打印到标准输出。<code>*restrictions</code>用于控制打印结果的形式, 例如<code>(10, 1.0, &quot;.*.py.*&quot;)</code>表示打印所有py文件的信息的前10行结果。</li>
</ul>
</li>
</ul>
<p>有了上面的接口我们便可以更<strong>优雅</strong>的去使用分析器来分析我们的程序，例如可以通过写一个<strong>带有参数的装饰器</strong>，这样想分析项目中任何一个函数，便可方便的使用装饰器来达到目的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cProfile</div><div class="line"><span class="keyword">import</span> pstats</div><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line"><span class="comment"># 性能分析装饰器定义</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_cprofile</span><span class="params">(filename)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Decorator for function profiling.</div><div class="line">    """</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">profiled_func</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line"></div><div class="line">            <span class="comment"># Flag for do profiling or not.</span></div><div class="line">            DO_PROF = os.getenv(<span class="string">"PROFILING"</span>)</div><div class="line"></div><div class="line">            <span class="keyword">if</span> DO_PROF:</div><div class="line">                profile = cProfile.Profile()</div><div class="line">                profile.enable()</div><div class="line">                result = func(*args, **kwargs)</div><div class="line">                profile.disable()</div><div class="line">                <span class="comment"># Sort stat by internal time.</span></div><div class="line">                sortby = <span class="string">"tottime"</span></div><div class="line">                ps = pstats.Stats(profile).sort_stats(sortby)</div><div class="line">                ps.dump_stats(filename)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                result = func(*args, **kwargs)</div><div class="line">            <span class="keyword">return</span> result</div><div class="line">        <span class="keyword">return</span> profiled_func</div><div class="line">    <span class="keyword">return</span> wrapper</div></pre></td></tr></table></figure></p>
<p>这样我们可以在我们想进行分析的地方进行性能分析, 例如我想分析我的<code>MicroKineticModel</code>类中的<code>run</code>方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MicroKineticModel</span><span class="params">(km.KineticModel)</span>:</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line"></div><div class="line">    <span class="comment"># 应用装饰器来分析函数</span></div><div class="line"><span class="meta">    @do_cprofile("./mkm_run.prof")</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, **kwargs)</span>:</span></div><div class="line">        <span class="comment"># ...</span></div></pre></td></tr></table></figure></p>
<p>装饰器函数中通过<code>sys.getenv</code>来获取环境变量判断是否需要进行分析，因此可以通过设置环境变量来告诉程序是否进行性能分析:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> PROFILING=y</div><div class="line"></div><div class="line"><span class="comment"># run the program...</span></div></pre></td></tr></table></figure></p>
<p>程序跑完后便会在当前路径下生成mkm_run.prof的分析文件，我们便可以通过打印或者可视化工具来对这个函数进行分析。</p>
<h3 id="性能分析实践"><a href="#性能分析实践" class="headerlink" title="性能分析实践"></a>性能分析实践</h3><p>下面我就通过分析自己的动力学程序中<code>MicroKineticModel</code>类中的方法来进行实践，并使用常用的几种性能分析可视化工具来帮助分析并进行初步的优化和效率对比。</p>
<p>注： 本次测试的程序主要包含数值求解微分方程以及牛顿法求解多元非线性方程组的求解，其中程序中的公式推导部分全部通过字符串操作完成。</p>
<h4 id="生成性能分析报告"><a href="#生成性能分析报告" class="headerlink" title="生成性能分析报告"></a>生成性能分析报告</h4><p>按照上文的方法，我们通过装饰器对<code>run</code>方法进行修饰来进行性能分析，这样我们便可以像正常一样去跑程序，但是不同的是当前路径下会生成性能分析报告文件。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 设置环境变量</span></div><div class="line">export PROFILING=y</div><div class="line"></div><div class="line"><span class="comment"># 执行运行脚本</span></div><div class="line">python <span class="keyword">run</span>.<span class="bash">py</span></div></pre></td></tr></table></figure>
<p>在看似正常的运行之后，在当前路径下我们会生成一个分析报告, <code>mkm_run.prof</code>, 它是一个二进制文件，我们需要用python的pstats模块的接口来读取。</p>
<p><img src="/assets/images/blog_img/2016-12-20-Python优化第一步-性能分析实践/print_stats.png" alt=""></p>
<p>我们只按照累积时间进行降序排序并输出了前十行，整个函数只运行了0.106秒。可见程序大部分时间主要花在牛顿法求解的过程中，其中获取解析Jacobian Matrix的过程是一个主要耗时的部分。</p>
<p>虽然我们可以通过命令行查看函数调用关系，但是我并不想花时间在反人类的黑白框中继续分析程序，下面我打算上直观的可视化工具了。</p>
<h4 id="分析数据可视化"><a href="#分析数据可视化" class="headerlink" title="分析数据可视化"></a>分析数据可视化</h4><h4 id="gprof2dot"><a href="#gprof2dot" class="headerlink" title="gprof2dot"></a>gprof2dot</h4><p>Gprof2Dot可将多种Profiler的数据转成Graphviz可处理的图像表述。配合dot命令，即可得到不同函数所消耗的时间分析图。具体使用方法详见: <a href="https://github.com/jrfonseca/gprof2dot" target="_blank" rel="external">https://github.com/jrfonseca/gprof2dot</a></p>
<p>因此我们可以利用它来为我们的程序生成分析图:<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gprof2dot -f pstats mkm_run.prof <span class="string">| dot -Tpng -o mkm_run.png</span></div></pre></td></tr></table></figure></p>
<p>于是我们路径下面就生成了mkm_run.png</p>
<p><img src="/assets/images/blog_img/2016-12-20-Python优化第一步-性能分析实践/gprof2dot.png" alt=""></p>
<p>我倒是蛮喜欢这个时间分析图，顺着浅色方格的看下去很容易发现程序的瓶颈部分，</p>
<ul>
<li><p>每个node的信息如下:</p>
  <figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="code">+------------------------------+</span></div><div class="line">|        function name         |</div><div class="line">| total time % ( self time % ) |</div><div class="line"><span class="section">|         total calls          |</span></div><div class="line">+------------------------------+</div></pre></td></tr></table></figure>
</li>
<li><p>每个edge的信息如下:</p>
  <figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">           total <span class="built_in">time</span> %</div><div class="line">              calls</div><div class="line"><span class="function"><span class="title">parent</span> --------------------&gt;</span> children</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="vprof"><a href="#vprof" class="headerlink" title="vprof"></a>vprof</h4><p>也是一个不错的工具来提供交互式的分析数据可视化，详情参见: <a href="https://github.com/nvdv/vprof" target="_blank" rel="external">https://github.com/nvdv/vprof</a></p>
<p>他是针对文件进行执行并分析，并在浏览器中生成可视化图标<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 生成CPU flame图</span></div><div class="line">vprof -c c <span class="keyword">run</span>.<span class="bash">py</span></div></pre></td></tr></table></figure></p>
<p><img src="/assets/images/blog_img/2016-12-20-Python优化第一步-性能分析实践/vprof.png" alt=""></p>
<h4 id="RunSnakeRun"><a href="#RunSnakeRun" class="headerlink" title="RunSnakeRun"></a>RunSnakeRun</h4><p>RunSnakeRun是另一个可对性能分析结果进行可视化的工具，它使用wxPython讲Profiler的数据可视化</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">runsnake</span> <span class="selector-tag">mkm_run</span><span class="selector-class">.prof</span></div></pre></td></tr></table></figure>
<p>效果图:</p>
<p><img src="/assets/images/blog_img/2016-12-20-Python优化第一步-性能分析实践/runsnakerun.png" alt=""></p>
<h4 id="KCacheGrind-amp-pyprof2calltree"><a href="#KCacheGrind-amp-pyprof2calltree" class="headerlink" title="KCacheGrind &amp; pyprof2calltree"></a>KCacheGrind &amp; pyprof2calltree</h4><p>KCacheGrind是Linux中常用的分析数据可视化软件，他默认处理valgrind的输出，但是我们结合<a href="https://pypi.python.org/pypi/pyprof2calltree/" target="_blank" rel="external">pyprof2calltree</a>工具可以把cProfile的输出转换成KCacheGrind支持的格式。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">pyprof2calltree</span> -i mkm_run.prof -k  <span class="comment"># 转换格式并立即运行KCacheGrind</span></div></pre></td></tr></table></figure>
<p><img src="/assets/images/blog_img/2016-12-20-Python优化第一步-性能分析实践/KCacheGrind.png" alt=""></p>
<h3 id="初步优化"><a href="#初步优化" class="headerlink" title="初步优化"></a>初步优化</h3><p>通过直观的可视化工具我们可以迅速找到程序中可以优化的部分，</p>
<p><img src="/assets/images/blog_img/2016-12-20-Python优化第一步-性能分析实践/opt.png" alt=""></p>
<p>可以看到我们在求解Jacobian矩阵的时候，会调用很多次求导函数，并且占据了比较大的时间，于是我们可以尝试通过<strong>函数返回值缓存</strong>的方式进行初步优化。</p>
<p>为了能将函数的返回值进行缓存，我们添加了一个描述符:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memoized</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></div><div class="line">        self.func = func</div><div class="line">        self.results = &#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, cls)</span>:</span></div><div class="line">        self.instance = instance</div><div class="line">        <span class="keyword">return</span> self</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args)</span>:</span></div><div class="line">        key = args</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            <span class="keyword">return</span> self.results[key]</div><div class="line">        <span class="keyword">except</span> KeyError:</div><div class="line">            self.results[key] = self.func(self.instance, *args)</div><div class="line">            <span class="keyword">return</span> self.results[key]</div></pre></td></tr></table></figure></p>
<p>这样，在我们需要进行返回值缓存的函数上面使用此描述符，便可以将返回值缓存到描述符对象中，当我们使用相同参数进行重复调用时候，便可以直接返回数值，复杂度将为O(1)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Memoized</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">poly_adsorbate_derivation</span><span class="params">(self, adsorbate_name, poly_expression)</span>:</span></div><div class="line">    <span class="comment"># ...</span></div></pre></td></tr></table></figure>
<p>优化后我们再来进行一次分析:</p>
<p><img src="/assets/images/blog_img/2016-12-20-Python优化第一步-性能分析实践/after_opt.png" alt=""></p>
<p>同一个函数，运行时间从<strong>0.106秒</strong>降到了<strong>0.061</strong>秒效率提升近了<strong>40%!</strong></p>
<p>看一下函数调用关系图:</p>
<p><img src="/assets/images/blog_img/2016-12-20-Python优化第一步-性能分析实践/calltree_opt.png" alt=""></p>
<p>而且函数调用次数明显减少了，可以看到<code>poly_adsorbate_derivation</code>的调用次数从36次降到了9次，<code>__total_term_adsorbate_derivation</code>从192次降到了48次。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对Python内置的性能分析器cProfile的使用进行了介绍，并以作者项目中的代码为例进行了实例分析和数据可视化，并使用了缓存的方式对Python程序进行了初步的优化，希望能借此帮助大家熟悉工具并分析自己Python程序性能的瓶颈写出更好更高效的Python程序。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> profiling </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[有效的python属性管理: 描述符的使用]]></title>
      <url>http://pytlab.github.io/2016/12/10/%E6%9C%89%E6%95%88%E7%9A%84python%E5%B1%9E%E6%80%A7%E7%AE%A1%E7%90%86-%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近使用描述符对自己的催化动力学模拟程序进行了改进，在Python描述符的帮助下实现了更加灵活而且强大有效的属性管理，使得程序各个组件的数据封装更加完善管理也更加有条理。</p>
<p>本文就以自己程序中运用描述符来进行有效的python属性管理为例子，介绍python中描述符的概念以及如何更好的使用描述符这个强有力的工具帮助我们有效管理python程序中的数据访问控制。</p>
<a id="more"></a>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在其他语言中我们经常会在类中实现<code>getter</code>和<code>setter</code>等工具方法，这样有助于定义类的接口，也使得开发者能够方便的封装功能，例如验证用法或者进行取值范围的检测。但是在Python中我们一般都是直接从<code>public</code>属性写起，但是当我们对属性有特殊需求，例如进行类型验证(Python是动态类型)，数值范围检测，返回深复制(而不是引用）的时候，我们一般会考虑使用:</p>
<ol>
<li>内建的<code>@property</code>装饰器</li>
<li>使用描述符</li>
</ol>
<p><code>@property</code>装饰器使用起来方便快捷，例如<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">KineticModel</span><span class="params">(obejct)</span>:</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kB</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.__kB</div><div class="line"></div><div class="line"><span class="meta">    @property.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kB</span><span class="params">(self, kB)</span>:</span></div><div class="line">        <span class="comment">#...</span></div></pre></td></tr></table></figure></p>
<p>但是<code>@property</code>的缺点就在于他无法被复用，同一套逻辑不能在不同的属性之间重复使用，这样除了对波尔兹曼常数进行处理外如果还有普朗克常数需要做同样的处理，难道要重复写一次<code>setter</code>和<code>getter</code>函数？这显然已经”Repeat yourself”了。</p>
<p>这时候就要召唤Python的描述符机制了，他的存在是python开发者能够复用与属性相关的逻辑。</p>
<h3 id="描述符协议"><a href="#描述符协议" class="headerlink" title="描述符协议"></a>描述符协议</h3><p>Python描述符协议是一种再模型中引用属性时将要发生事件的方法。Python会对属性的访问操作进行一定的转译，这种转译的方式就是由描述符协议确定的。借助Python提供给我们的描述符协议，我们就可以用来以Python的方式实现与私有变量类似的功能。</p>
<p>描述符协议包括几个方法：</p>
<ul>
<li><code>descr.__get__(self, obj, type=None)</code> –&gt; value, 用于访问属性</li>
<li><code>descr.__set__(self, obj, value)</code> –&gt; None, 用于设置属性的值</li>
<li><code>descr.__delete__(self, obj)</code> –&gt; None, 控制属性的删除操作</li>
</ul>
<p>任何对象如果定义了上面的任何一个方法便实现了描述符协议，也就变成了一个描述符了。我们通过将之前的<code>getter</code>和<code>setter</code>方法中的逻辑重写到<code>__get__</code>和<code>__set__</code>方法中，便可以把同一套逻辑运用在不同类中不同的属性上面了。</p>
<h3 id="创建描述符"><a href="#创建描述符" class="headerlink" title="创建描述符"></a>创建描述符</h3><p>这里只介绍使用类方法创建描述符。</p>
<p>我的动力学模型中的KineticModel需要很多类属性，例如基本的基元反应式<code>rxn_expression</code>（这里我用了一个包含string的list来表示）、模型反应发生的温度<code>temperature</code>（用一个float类型表示）。</p>
<p>为了能够在对属性进行赋值的时候进行相应的类型检测，我就定义了几个基本类型的描述符，提供了检测数据类型的相应逻辑，下面是个简单的整型描述符（当然这不是最后的使用的版本）:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Float</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line">        self.name = name</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self)</span>:</span></div><div class="line">        private_name = <span class="string">"_&#123;&#125;__&#123;&#125;"</span>.format(instance.__class__.__name__, self.name)</div><div class="line">        <span class="keyword">if</span> private_name <span class="keyword">not</span> <span class="keyword">in</span> instance.__dict__:</div><div class="line">            instance.__dict__[private_name] = self.default</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></div><div class="line">        <span class="comment"># 检测类型</span></div><div class="line">        <span class="keyword">if</span> type(value) <span class="keyword">is</span> <span class="keyword">not</span> float:</div><div class="line">            msg = <span class="string">"&#123;&#125; (&#123;&#125;) is not a float number"</span>.format(self.name, value)</div><div class="line">            <span class="keyword">raise</span> ValueError(msg)</div><div class="line">        <span class="comment"># 将对象的相应属性进行赋值，注意这里我使用了`mangled name`用来进行私有化处理</span></div><div class="line">        private_name = <span class="string">"_&#123;&#125;__&#123;&#125;"</span>.format(instance.__class__.__name__, self.name)</div><div class="line">        instance.__dict__[private_name] = value</div></pre></td></tr></table></figure>
<p>这样我们就可以在我们类中相应的类属性定义成相应的描述符对象，后面我们就可以像使用正常属性一样使用他，但是他却拥有了类型检测功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">KineticModel</span><span class="params">(obejct)</span>:</span></div><div class="line"></div><div class="line">    <span class="comment"># 设置temperature为类属性</span></div><div class="line">    temperature = Float(<span class="string">"temperature"</span>)</div><div class="line"></div><div class="line">...</div></pre></td></tr></table></figure>
<p>当我试图向其赋值一个字符串时,便会抛出异常：<br><img src="/assets/images/blog_img/2016-12-10-有效的python属性管理-描述符的使用/Float_descriptor.png" alt=""></p>
<h3 id="描述符的原理"><a href="#描述符的原理" class="headerlink" title="描述符的原理"></a>描述符的原理</h3><p>上面进行了基本的描述符创建和使用效果，那么描述符是如何工作的才能让我们以这种方式操作属性呢？</p>
<p>一句话总结就是通过将属性访问进行了<strong>转译</strong>。</p>
<h4 id="描述符触发"><a href="#描述符触发" class="headerlink" title="描述符触发"></a>描述符触发</h4><p>当我们进行属性访问时便会触发描述符（如果这个属性具有描述符定义的时候），当我们对对象<code>obj</code>的属性<code>d</code>进行访问时候，<code>obj.d</code>，描述符的触发过程大致：先在对象obj的字典中寻找d,如果<code>d</code>是个含有<code>__get__()</code>的对象，则直接调用<code>d.__get__(obj)</code>.</p>
<p>官方文档中对具体的触发细节进行了更详细的描述，具体的触发又分为我们访问的是类属性还是实例属性：</p>
<ol>
<li><p>如果是对实例属性进行访问，则属性访问转译的关键就在于基类<code>object</code>的<code>__getattribute__</code>方法，我们知道这个内置方法是在进行属性访问的时候无条件调用的，因此这个方法中将<code>obj.d</code>转译成了<code>type(obj).__dict__[&#39;d&#39;].__get__(obj, type(obj))</code><br> 其实现的C代码参见:<a href="https://docs.python.org/3/c-api/object.html#c.PyObject_GenericGetAttr" target="_blank" rel="external">https://docs.python.org/3/c-api/object.html#c.PyObject_GenericGetAttr</a></p>
</li>
<li><p>如果是对类对象的属性进行访问，则属性的访问转译关键在于元类<code>type</code>的<code>__getattribute__</code>方法，它将<code>cls.d</code>转译成<code>cls.__dict__[&#39;d&#39;].__get__(None, cls)</code>，这里<code>__get__()</code>的<code>instance</code>没有也就是相应的<code>None</code>了。<br> 其实现的C代码参见:<a href="https://hg.python.org/cpython/file/3.5/Objects/typeobject.c#l2936" target="_blank" rel="external">https://hg.python.org/cpython/file/3.5/Objects/typeobject.c#l2936</a></p>
</li>
</ol>
<h4 id="描述符优先级"><a href="#描述符优先级" class="headerlink" title="描述符优先级"></a>描述符优先级</h4><p>首先，<strong>描述符和描述符之间也是有区别的</strong>:</p>
<ol>
<li>如果一个对象同时定义了<code>__get__()</code>和<code>__set__()</code>方法，则这个描述符被称为<strong>data descriptor</strong></li>
<li>如果一个对象只定义了<code>__get__()</code>方法，则这个描述符被称为<strong>non-data descriptor</strong></li>
</ol>
<p>我们对属性进行访问的时候需要几行打交道的基本上包含这几个对象：</p>
<ol>
<li>data descriptor</li>
<li>non-data descriptor</li>
<li>实例的字典</li>
<li>内置的<code>__getattr__()</code>函数</li>
</ol>
<p>他们几个的优先级顺序是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data descriptor  &gt;&gt;  instance&apos;s dict  &gt;&gt;  non-data descriptor  &gt;&gt;   __getattr__()</div></pre></td></tr></table></figure></p>
<p>也就是说如果实例<code>obj</code>重现了同名的data descriptor <code>d</code> 和 实例属性<code>d</code>, 当我们访问<code>d</code>的时候，由于data descriptor具有更高的优先级，python便会调用<code>type(obj).__dict__[&#39;d&#39;].__get__(obj, type(obj))</code>而不是返回<code>obj.__dict__[&#39;d&#39;]</code></p>
<p>但是如果描述符是个non-data descriptor，则正好相反，python会返回<code>obj.__dict__[&#39;d&#39;]</code></p>
<h3 id="描述符实现惰性访问（按需访问）"><a href="#描述符实现惰性访问（按需访问）" class="headerlink" title="描述符实现惰性访问（按需访问）"></a>描述符实现惰性访问（按需访问）</h3><p>很多时候一个类的属性，我们并不需要在这个类初始化的时候就进行初始化，我们可以在第一次使用这个属性的时候<strong>顺便</strong>将这个属性初始化，这样在后面重复使用这个属性的时候便直接返回结果就可以了，这样既可以减少计算的次数，也在一定程度上减少了内存的需求。</p>
<p>因此我在定义自己的描述符<code>__get__()</code>的时候进行了判断是否该相应的实例属性已经初始化，若未初始化则进行初始化，若已初始化直接返回，达到了惰性访问的目的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></div><div class="line">    private_name = <span class="string">"_&#123;&#125;__&#123;&#125;"</span>.format(instance.__class__.__name__, self.name)</div><div class="line">    <span class="comment"># 是否实例属性已存在</span></div><div class="line">    <span class="keyword">if</span> private_name <span class="keyword">not</span> <span class="keyword">in</span> instance.__dict__:</div><div class="line">        instance.__dict__[private_name] = self.default</div><div class="line">    <span class="keyword">return</span> instance.__dict__[private_name]</div></pre></td></tr></table></figure>
<h3 id="创建只读描述符"><a href="#创建只读描述符" class="headerlink" title="创建只读描述符"></a>创建只读描述符</h3><p>当我们想让一个属性（描述符）禁止调用者进行修改的时候，可以通过在<code>__set__()</code>方法中抛出<code>AttributeError</code>异常来实现，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></div><div class="line">    private_name = <span class="string">"_&#123;&#125;__&#123;&#125;"</span>.format(instance.__class__.__name__, self.name)</div><div class="line">    <span class="comment"># 在第一次赋值后便无法修改属性的值</span></div><div class="line">    <span class="keyword">if</span> private_name <span class="keyword">not</span> <span class="keyword">in</span> instance.__dict__:</div><div class="line">        instance.__dict__[private_name] = value</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        msg =<span class="string">"Changing value of &#123;&#125;.&#123;&#125; is not allowed"</span>.format(instance.__class__.__name__,</div><div class="line">                                                             self.name)</div><div class="line">        <span class="keyword">raise</span> AttributeError(msg)</div></pre></td></tr></table></figure></p>
<p>这样便实现了私有变量的效果，可以将数据更安全的进行封装，防止在外部调用的时候意外修改了对象的数据造成不想要的结果。</p>
<h3 id="对于mutable的变量可以使用深复制"><a href="#对于mutable的变量可以使用深复制" class="headerlink" title="对于mutable的变量可以使用深复制"></a>对于mutable的变量可以使用深复制</h3><p>如果实例属性是字典或者列表这类的变量，python都会返回对象的引用，因此在获取其值以后也是有可能修改其内部数据的，因此如果真的想要是这个属性不被做任何的修改，可以使用<code>deepcopy</code>直接返回对象的深复制，这样在外部无论怎么蹂躏这个对象，都跟返回他的对象本身没有关系了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></div><div class="line">    private_name = <span class="string">"_&#123;&#125;__&#123;&#125;"</span>.format(instance.__class__.__name__, self.name)</div><div class="line">    <span class="keyword">if</span> private_name <span class="keyword">not</span> <span class="keyword">in</span> instance.__dict__:</div><div class="line">        instance.__dict__[private_name] = self.default</div><div class="line">    <span class="keyword">if</span> self.deepcopy:</div><div class="line">        <span class="keyword">return</span> copy.deepcopy(instance.__dict__[private_name])</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> instance.__dict__[private_name]</div></pre></td></tr></table></figure></p>
<h3 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h3><p>描述符都是针对类属性，因此如果把数据存放在描述符对象中的时候，会出现意想不到的结果。<br>例如我想针对每个学生类创建对应的身高描述符，而且把身高数据放在描述符中，我可以这样定义描述符：<br><img src="/assets/images/blog_img/2016-12-10-有效的python属性管理-描述符的使用/note.png" alt=""><br>我们创建了两个学生实例，但是身高属性却是同一个对象，这是因为描述符是类属性，因此每个实例中进行访问的时候都是访问的类属性的<strong>引用</strong>。</p>
<p>这个时候我们可以不把数据放在描述符中，而是在相应的实例对象中创建私有变量，这样不同的对象的私有变量是不同的变量，便不会出想上图的问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Height</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line">        self.name = name</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, cls)</span>:</span></div><div class="line">        <span class="keyword">return</span> getattr(instance, self.name)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></div><div class="line">        setattr(instance, self.name, value)</div></pre></td></tr></table></figure>
<p>同时也可以将相应的对象和值以字典的键值对存到描述符的字典中，但是这样会造成引用计数无法为0导致无法进行垃圾回收从而导致内存泄漏的风险，因此这个方法就不详细描述了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文总结了Python中的描述符相关的概念和使用，描述符可以帮助我们实现强大而灵活的属性管理，通过结合使用描述符可以实现优雅的编程，但是同时也应该保持谨慎的态度，避免由于覆盖普通对象行为而产生不必要的代码复杂性。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://docs.python.org/3/howto/descriptor.html" target="_blank" rel="external">https://docs.python.org/3/howto/descriptor.html</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/opensource/os-pythondescriptors/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/opensource/os-pythondescriptors/</a></li>
<li><a href="https://book.douban.com/subject/26312313/" target="_blank" rel="external">Effective Python</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> descriptor </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[std::vector<bool> 中的‘坑’]]></title>
      <url>http://pytlab.github.io/2016/11/29/std-vector-bool-%E4%B8%AD%E7%9A%84%E2%80%98%E5%9D%91%E2%80%99/</url>
      <content type="html"><![CDATA[<p>这两天打算对自己新增的KMC部分进行并行化，其中涉及到对包含有boolean值的vector进行分散和归约操作,但是在使用MPI接口进行编写的时候发现了个问题，当我对<code>std::vector&lt;bool&gt;</code>中的元素进行取址的时候编译器傲娇了。</p>
<p>我本意是想把多个进程的bool向量进行逻辑或归约然后分散到所有进程中，这就需要取不同进程中bool序列的地址，大致的代码简化如下:</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mpi.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></div><div class="line">&#123;</div><div class="line">    MPI::Init(argc, argv);</div><div class="line">    <span class="keyword">int</span> rank = MPI::COMM_WORLD.Get_rank();</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; send(<span class="number">6</span>, <span class="literal">false</span>);</div><div class="line">    <span class="keyword">if</span> (rank == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</div><div class="line">        &#123;</div><div class="line">            send[i] = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Proc 0: "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>.width(<span class="number">3</span>);</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; send[i];</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rank == <span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; <span class="number">6</span>; ++i)</div><div class="line">        &#123;</div><div class="line">            send[i] = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Proc 1: "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>.width(<span class="number">3</span>);</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; send[i];</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; recv(<span class="number">6</span>, <span class="literal">false</span>);</div><div class="line"></div><div class="line">    MPI_Allreduce(&amp;send[<span class="number">0</span>],</div><div class="line">                  &amp;recv[<span class="number">0</span>],</div><div class="line">                  <span class="number">6</span>,</div><div class="line">                  MPI::BOOL,</div><div class="line">                  MPI::LOR,</div><div class="line">                  MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (rank == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"After all_reduct: "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>.width(<span class="number">3</span>);</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; recv[i];</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    MPI_Finalize();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译报错说我去了一个临时值的地址：<br><img src="/assets/images/blog_img/2016-11-29-std-vector-bool-中的‘坑’/error.png" alt=""></p>
<p>为什么之前的<code>std::vector&lt;int&gt;</code>和<code>std::vector&lt;double&gt;</code>都不会出现这种问题？</p>
<p>于是还是要求助与万能的谷歌。。。</p>
<p>原来这个问题在Scott Meyers的Effective系列的条例里面都有，他说<code>std::vector&lt;bool&gt;</code>并不是一个STL容器，他里面存放的也不是真正的<code>bool</code>变量。</p>
<p>在cppreference里面也专门对这个进行了<a href="http://www.cplusplus.com/reference/vector/vector-bool/" target="_blank" rel="external">描述</a>：</p>
<blockquote>
<p>Vector of bool<br>This is a specialized version of vector, which is used for elements of type bool and optimizes for space.</p>
<p>It behaves like the unspecialized version of vector, with the following changes:</p>
<ul>
<li>The storage is not necessarily an array of bool values, but the library implementation may optimize storage so that each value is stored in a single bit.</li>
<li>Elements are not constructed using the allocator object, but their value is directly set on the proper bit in the internal storage.</li>
<li>Member function flip and a new signature for member swap.</li>
<li>A special member type, reference, a class that accesses individual bits in the container’s internal storage with an interface that emulates a bool reference. Conversely, member type const_reference is a plain bool.</li>
<li>The pointer and iterator types used by the container are not necessarily neither pointers nor conforming iterators, although they shall simulate most of their expected behavior.</li>
</ul>
</blockquote>
<p>也就是说为了空间节省，C++标准显式的将<code>vector&lt;bool&gt;</code>处理成每个bool值只用一位来存储而不是使用一个字节来存储真正的<code>bool</code>值，但是当我们使用<code>[]</code>运算符取值的时候，容器会返回一个代理类，这个代理类能够看起来像<code>bool</code>值一样被操作，但是对他直接进行取值或者取地址的时候却会出问题，因为他只是个代理对象的临时变量，于是看来我还是尽量不要用<code>vector</code>来存储<code>bool</code>, 上最原始的数组吧。。。so</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mpi.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></div><div class="line">&#123;</div><div class="line">    MPI::Init(argc, argv);</div><div class="line">    <span class="keyword">int</span> rank = MPI::COMM_WORLD.Get_rank();</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> send[<span class="number">6</span>] = &#123;<span class="literal">false</span>&#125;;</div><div class="line">    <span class="keyword">if</span> (rank == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</div><div class="line">        &#123;</div><div class="line">            send[i] = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Proc 0: "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>.width(<span class="number">3</span>);</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; send[i];</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rank == <span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; <span class="number">6</span>; ++i)</div><div class="line">        &#123;</div><div class="line">            send[i] = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Proc 1: "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>.width(<span class="number">3</span>);</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; send[i];</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> recv[<span class="number">6</span>] = &#123;<span class="literal">false</span>&#125;;</div><div class="line"></div><div class="line">    MPI_Allreduce(&amp;send[<span class="number">0</span>],</div><div class="line">                  &amp;recv[<span class="number">0</span>],</div><div class="line">                  <span class="number">6</span>,</div><div class="line">                  MPI::BOOL,</div><div class="line">                  MPI::LOR,</div><div class="line">                  MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (rank == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"After all_reduct: "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>.width(<span class="number">3</span>);</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; recv[i];</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    MPI_Finalize();</div></pre></td></tr></table></figure>
<p>这个时候便不会出问题了。</p>
<p><img src="/assets/images/blog_img/2016-11-29-std-vector-bool-中的‘坑’/right.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用VASPy快速处理VASP文件以及数据可视化]]></title>
      <url>http://pytlab.github.io/2016/11/26/%E4%BD%BF%E7%94%A8VASPy%E5%BF%AB%E9%80%9F%E5%A4%84%E7%90%86VASP%E6%96%87%E4%BB%B6%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文为作者对其开源项目<a href="https://github.com/PytLab/VASPy" target="_blank" rel="external">VASPy</a>的说明文章。<a href="https://github.com/PytLab/VASPy" target="_blank" rel="external">VASPy</a>是一个纯Python编写的处理VASP文件数据以及进行数据快速可视化的库，基于OOP的思想提供了操作VASP文件的友好的接口，可以帮助使用者快速编写处理VASP相关文件的脚本，以提升效率。VASPy的项目仍处于起步阶段，希望大家可以都贡献出自己的力量使其壮大起来。</p>
<h2 id="VASP简介"><a href="#VASP简介" class="headerlink" title="VASP简介"></a>VASP简介</h2><p>对于广大做计算化学或者材料模拟的同学肯定听说过VASP的大名或者其科学研究与其息息相关。<br>VASP的全称是Vienna Ab-initio Simulation Package，是维也纳大学Hafner课题组开发的进行电子结构计算和量子力学-分子动力学模拟的软件包，目前是材料模拟和计算物质科学研究中最流行的商业软件之一。关于VASP的详细介绍可以参见其官方主页(<a href="http://www.vasp.at/" target="_blank" rel="external">http://www.vasp.at/</a>)</p>
<a id="more"></a>
<h2 id="VASPy项目简介"><a href="#VASPy项目简介" class="headerlink" title="VASPy项目简介"></a>VASPy项目简介</h2><p>VASPy的思想是将VASP相关的文件都视为可操作的对象，通过友好的接口对一个或者多个VASP对象进行快速的操作以提升工作效率。目前已兼容Python2 和 Python3。</p>
<ul>
<li>VASPy的GitHub地址：<a href="https://github.com/PytLab/VASPy" target="_blank" rel="external">https://github.com/PytLab/VASPy</a></li>
<li>VASPy的PyPI地址：<a href="https://pypi.python.org/pypi/vaspy/" target="_blank" rel="external">https://pypi.python.org/pypi/vaspy/</a></li>
</ul>
<p><img src="/assets/images/blog_img/2016-11-26-使用VASPy快速处理VASP文件以及数据可视化/VASPy_PyPI.png" alt=""></p>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>VASPy库已上传至PyPI可以通过pip来进行安装:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pip <span class="keyword">install</span> vaspy</div></pre></td></tr></table></figure>
<p>从源码安装:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git clone git@github<span class="selector-class">.com</span>:PytLab/VASPy<span class="selector-class">.git</span></div><div class="line"></div><div class="line">$ cd vaspy</div><div class="line"></div><div class="line">$ python setup<span class="selector-class">.py</span> install</div></pre></td></tr></table></figure></p>
<p>VASPy同时内部也使用了Mayavi进行可视化，如果需要使用mayavi推荐直接安装canopy集成环境，我不觉得会有很多人喜欢手动在各种平台上安装mayavi的那种酸爽是无与伦比的。</p>
<p>下载好<a href="https://store.enthought.com/downloads/#default" target="_blank" rel="external">canopy</a>后，可以在配置文件中设置别名方便调用canopy中的python，jupyter等等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alias canopy=&apos;/Users/&lt;yourname&gt;/Library/Enthought/Canopy/edm/envs/User/bin/python&apos;</div><div class="line">alias canopy-pip=&apos;/Users/&lt;yourname&gt;/Library/Enthought/Canopy/edm/envs/User/bin/pip&apos;</div><div class="line">alias canopy-ipython=&apos;/Users/&lt;yourname&gt;/Library/Enthought/Canopy/edm/envs/User/bin/ipython&apos;</div><div class="line">alias canopy-jupyter=&apos;/Users/&lt;yourname&gt;/Library/Enthought/Canopy/edm/envs/User/bin/jupyter&apos;</div></pre></td></tr></table></figure>
<p>然后便可以将VASPy安装到canopy中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">canopy-pip install vaspy</div></pre></td></tr></table></figure>
<h3 id="VASPy包的文件结构"><a href="#VASPy包的文件结构" class="headerlink" title="VASPy包的文件结构"></a>VASPy包的文件结构</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">VASPy/</div><div class="line">├── LICENSE</div><div class="line">├── MANIFEST</div><div class="line">├── MANIFEST<span class="selector-class">.in</span></div><div class="line">├── README<span class="selector-class">.rst</span></div><div class="line">├── requirements<span class="selector-class">.txt</span></div><div class="line">├── scripts</div><div class="line">│   ├── change_incar_parameters<span class="selector-class">.py</span></div><div class="line">│   ├── create_inputs<span class="selector-class">.py</span></div><div class="line">│   └── ...</div><div class="line">├── setup<span class="selector-class">.cfg</span></div><div class="line">├── setup<span class="selector-class">.py</span></div><div class="line">├── tests</div><div class="line">│   ├── incar_test<span class="selector-class">.py</span></div><div class="line">│   ├── __init__<span class="selector-class">.py</span></div><div class="line">│   ├── oszicar_test<span class="selector-class">.py</span></div><div class="line">│   ├── outcar_test<span class="selector-class">.py</span></div><div class="line">│   ├── testdata</div><div class="line">│   │   ├── CONTCAR</div><div class="line">│   │   ├── DOS_SUM</div><div class="line">│   │   ├── ELFCAR</div><div class="line">│   │   └── ...</div><div class="line">│   └── ...</div><div class="line">└── vaspy</div><div class="line">    ├── __init__<span class="selector-class">.py</span></div><div class="line">    ├── iter<span class="selector-class">.py</span></div><div class="line">    ├── matstudio<span class="selector-class">.py</span></div><div class="line">    └── ...</div></pre></td></tr></table></figure>
<h3 id="文件操作举例"><a href="#文件操作举例" class="headerlink" title="文件操作举例"></a>文件操作举例</h3><p>目前VASPy提供了操作INCAR、POSCAR、OUTCAR、XDATCAR、ELFCAR等的接口，这里对其中的部分进行简要的举例介绍。</p>
<h4 id="操作INCAR文件"><a href="#操作INCAR文件" class="headerlink" title="操作INCAR文件"></a>操作<code>INCAR</code>文件</h4><p><code>INCAR</code>是VASP做电子结构计算的参数设置文件，VASPy提供了<code>InCar</code>类可以方便获取INCAR文件的信息以及进行自定义的修改并生成新的INCAR文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> vaspy.incar <span class="keyword">import</span> InCar</div><div class="line"></div><div class="line">In [<span class="number">2</span>]: incar = InCar(<span class="string">"INCAR"</span>)    <span class="comment"># 创建InCar对象</span></div><div class="line"></div><div class="line">In [<span class="number">3</span>]: incar.IBRION              <span class="comment"># 读取参数信息</span></div><div class="line">Out[<span class="number">3</span>]: <span class="string">'1'</span></div><div class="line"></div><div class="line">In [<span class="number">4</span>]: incar.ISIF</div><div class="line">Out[<span class="number">4</span>]: <span class="string">'2'</span></div><div class="line"></div><div class="line">In [<span class="number">5</span>]: incar.ISIF = <span class="number">3</span>             <span class="comment"># 修改参数</span></div><div class="line"></div><div class="line">In [<span class="number">6</span>]: incar.tofile(<span class="string">"INCAR_new"</span>)  <span class="comment"># 生成新的INCAR文件</span></div></pre></td></tr></table></figure>
<p>通过此类操作便可以快速写出批量修改INCAR文件的脚本，附上代码链接(<a href="https://github.com/PytLab/VASPy/blob/master/scripts/change_incar_parameters.py" target="_blank" rel="external">https://github.com/PytLab/VASPy/blob/master/scripts/change_incar_parameters.py</a>)</p>
<h4 id="操作POSCAR-CONTCAR-XDATCAR等含有结构坐标的文件"><a href="#操作POSCAR-CONTCAR-XDATCAR等含有结构坐标的文件" class="headerlink" title="操作POSCAR/CONTCAR/XDATCAR等含有结构坐标的文件"></a>操作<code>POSCAR</code>/<code>CONTCAR</code>/<code>XDATCAR</code>等含有结构坐标的文件</h4><p>操作结构文件可以获取相应结构的信息，例如晶胞参数、晶胞体积等。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">7</span>]: <span class="keyword">from</span> vaspy.atomco <span class="keyword">import</span> PosCar</div><div class="line"></div><div class="line">In [<span class="number">8</span>]: poscar = PosCar(<span class="string">"POSCAR"</span>)</div><div class="line"></div><div class="line">In [<span class="number">9</span>]: poscar.bases</div><div class="line">Out[<span class="number">9</span>]: </div><div class="line">array([[  <span class="number">7.29321435</span>,  <span class="number">-4.21073927</span>,   <span class="number">0.</span>        ],</div><div class="line">       [  <span class="number">0.</span>        ,   <span class="number">8.42147853</span>,   <span class="number">0.</span>        ],</div><div class="line">       [ <span class="number">-0.</span>        ,   <span class="number">0.</span>        ,  <span class="number">16.87610843</span>]])</div><div class="line"></div><div class="line">In [<span class="number">10</span>]: poscar.get_volume()</div><div class="line">Out[<span class="number">10</span>]: <span class="number">1036.5246404472209</span></div><div class="line"></div><div class="line">In [<span class="number">11</span>]: poscar.data</div><div class="line">Out[<span class="number">11</span>]: </div><div class="line">array([[ <span class="number">0.24466667</span>,  <span class="number">0.224</span>     ,  <span class="number">0.13581544</span>],</div><div class="line">       [ <span class="number">0.02244444</span>,  <span class="number">0.11288889</span>,  <span class="number">0.27163089</span>],</div><div class="line">       [ <span class="number">0.13355555</span>,  <span class="number">0.00177777</span>,  <span class="number">0.</span>        ],</div><div class="line">       ...                                   ])</div></pre></td></tr></table></figure></p>
<p>同时结构坐标类中还提供了三维空间坐标转换接口，例如Cartisan坐标与Direct坐标的相互转换。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">14</span>]: poscar.cart2dir(self.bases, self.data)</div><div class="line">Out[<span class="number">14</span>]: ...</div><div class="line"></div><div class="line">In [<span class="number">15</span>]: poscar.dir2cart(self.bases, self.data)</div><div class="line">Out[<span class="number">15</span>]: ...</div></pre></td></tr></table></figure>
<p>从XDATCAR中获取迭代的结构信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> vaspy.atomco <span class="keyword">import</span> XdatCar</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>xdatcar = XdatCar(<span class="string">"XDATCAR"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> step, data <span class="keyword">in</span> xdatcar:</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>    print(step)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>    print(xdatcar.dir2cart(xdatcar.bases, data))</div></pre></td></tr></table></figure>
<h4 id="操作OUTCAR文件"><a href="#操作OUTCAR文件" class="headerlink" title="操作OUTCAR文件"></a>操作OUTCAR文件</h4><p><code>OUTCAR</code>是VASP最重要的输出文件，我们可以从中获取计算过程中基本上所有的信息。</p>
<p>获取迭代过程中原子的受力信息：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">4</span>]: <span class="keyword">from</span> vaspy.iter <span class="keyword">import</span> OutCar</div><div class="line"></div><div class="line">In [<span class="number">5</span>]: outcar = OutCar(<span class="string">"OUTCAR_freq"</span>, poscar=<span class="string">'POSCAR_freq'</span>)</div><div class="line"></div><div class="line">In [<span class="number">9</span>]: outcar.forces()  <span class="comment"># 最近一次迭代中结构中原子在各个方向上的受力</span></div><div class="line">Out[<span class="number">9</span>]: </div><div class="line">([[<span class="number">2.79563</span>, <span class="number">0.85618</span>, <span class="number">1.19698</span>],</div><div class="line">  [<span class="number">4.47844</span>, <span class="number">0.86375</span>, <span class="number">4.78817</span>],</div><div class="line">  [<span class="number">2.37243</span>, <span class="number">-0.5474</span>, <span class="number">3.59093</span>],</div><div class="line">  [<span class="number">3.91022</span>, <span class="number">-0.54961</span>, <span class="number">7.26487</span>],</div><div class="line">  ...                        ])</div></pre></td></tr></table></figure></p>
<p>如果要获取所以迭代步中的受力信息，需要使用OutCar提供的受力信息迭代器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> forces <span class="keyword">in</span> outcar.force_iterator:</div><div class="line">    <span class="comment"># Do something with forces tuple.</span></div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>OutCar类对于含有频率计算的信息的文件会做频率收取操作，可以方便获取频率相关数据:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">16</span>]: outcar.freq_info</div><div class="line">Out[<span class="number">16</span>]: (<span class="string">'index'</span>, <span class="string">'freq_type'</span>, <span class="string">'THz'</span>, <span class="string">'2PiTHz'</span>, <span class="string">'cm-1'</span>, <span class="string">'meV'</span>, <span class="string">'coordinates'</span>, <span class="string">'deltas'</span>)</div><div class="line"></div><div class="line">In [<span class="number">17</span>]: outcar.freq_types</div><div class="line">Out[<span class="number">17</span>]: [[<span class="string">'f'</span>, <span class="string">'f'</span>, <span class="string">'f'</span>], [<span class="string">'f'</span>, <span class="string">'f'</span>, <span class="string">'f/i'</span>]]</div><div class="line"></div><div class="line">In [<span class="number">19</span>]: outcar.zpe</div><div class="line">Out[<span class="number">19</span>]: <span class="number">0.1117761635</span></div><div class="line"></div><div class="line">In [<span class="number">20</span>]: <span class="keyword">for</span> freq_info <span class="keyword">in</span> outcar.freq_iterator:</div><div class="line">    ...:     <span class="comment"># Do something with frequency data</span></div><div class="line">    ...:     ...</div></pre></td></tr></table></figure>
<p>对于其他文件的操作这里就不进行一一介绍了。</p>
<h3 id="VASP数据可视化"><a href="#VASP数据可视化" class="headerlink" title="VASP数据可视化"></a>VASP数据可视化</h3><h4 id="可视化分割后的DOS-态密度-数据"><a href="#可视化分割后的DOS-态密度-数据" class="headerlink" title="可视化分割后的DOS(态密度)数据"></a>可视化分割后的DOS(态密度)数据</h4><p>可视化的过程中可以选择进行d-band center的计算并显示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> vaspy.electro <span class="keyword">import</span> DosX</div><div class="line"></div><div class="line">In [<span class="number">2</span>]: dos = DosX(<span class="string">'DOS_SUM'</span>)</div><div class="line"></div><div class="line">In [<span class="number">3</span>]: dos.plotsum(<span class="number">0</span>, (<span class="number">5</span>, <span class="number">10</span>))</div></pre></td></tr></table></figure>
<p>效果图:<br><img src="/assets/images/blog_img/2016-11-26-使用VASPy快速处理VASP文件以及数据可视化/DOS.png" alt=""></p>
<h4 id="ELFCAR-CHGCAR数据的可视化"><a href="#ELFCAR-CHGCAR数据的可视化" class="headerlink" title="ELFCAR/CHGCAR数据的可视化"></a><code>ELFCAR</code>/<code>CHGCAR</code>数据的可视化</h4><p>电荷数据主要是通过对三维矩阵进行处理后进行绘制，可以选择surface以及二维map和标量场的显示模式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> vaspy.electro <span class="keyword">import</span> ElfCar</div><div class="line"></div><div class="line">In [<span class="number">2</span>]: elfcar = ElfCar(<span class="string">"ELFCAR"</span>)</div><div class="line"></div><div class="line">In [<span class="number">3</span>]: elfcar.plot_contour()</div></pre></td></tr></table></figure>
<p><img src="/assets/images/blog_img/2016-11-26-使用VASPy快速处理VASP文件以及数据可视化/contour2d.png" alt=""></p>
<p>3D 等值线图, 这需要安装Mayavi模块来进行绘制。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">4</span>]: elfcar.plot_contour3d()</div></pre></td></tr></table></figure>
<p><img src="/assets/images/blog_img/2016-11-26-使用VASPy快速处理VASP文件以及数据可视化/contour3d.png" alt=""></p>
<p>绘制标量场，同样需要Mayavi的支持。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">5</span>]: elfcar.plot_field()</div></pre></td></tr></table></figure>
<p><img src="/assets/images/blog_img/2016-11-26-使用VASPy快速处理VASP文件以及数据可视化/field.png" alt=""></p>
<p>CHGCAR也是Fortran顺序的三维矩阵，绘制道理相同，因此可以用继承自ElfCar的ChgCar类来进行CHGCAR相关的绘制，例如差分电荷图。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">4</span>]: <span class="keyword">from</span> vaspy.electro <span class="keyword">import</span> ChgCar</div><div class="line"></div><div class="line">In [<span class="number">5</span>]: chgcar = ChgCar(<span class="string">"CHGCAR_diff"</span>)</div><div class="line"></div><div class="line">In [<span class="number">6</span>]: chgcar.plot_contour()</div></pre></td></tr></table></figure>
<p><img src="/assets/images/blog_img/2016-11-26-使用VASPy快速处理VASP文件以及数据可视化/contourf.png" alt=""></p>
<h4 id="操作MaterialStudio中的xsd以及xtd等文件的接口"><a href="#操作MaterialStudio中的xsd以及xtd等文件的接口" class="headerlink" title="操作MaterialStudio中的xsd以及xtd等文件的接口"></a>操作MaterialStudio中的xsd以及xtd等文件的接口</h4><p>VASPy还提供了一个方便将Material Studio中的<code>xsd</code>文件与VASP文件互通的接口，通过VASPy中的<code>XsdFile</code>和<code>XtdFile</code>类可以抽取文件中的晶格结构信息并结合VASP相关的类进行VASP文件的创建，同样可以方便的讲VASP的文件生成相应的用Material Studio可以显示的文件包括讲XDATCAR生成相应的<code>*.arc</code>和<code>*.xtd</code>来显示动画效果。</p>
<p>附上脚本的链接，此脚本就是利用VASPy的接口将Material Studio文件和VASP的文件进行相互转换。</p>
<ul>
<li><a href="https://github.com/PytLab/VASPy/blob/master/scripts/create_inputs.py" target="_blank" rel="external">由MaterialStudio的xsd文件生成VASP输入文件的脚本</a></li>
<li><a href="https://github.com/PytLab/VASPy/blob/master/scripts/create_xsd.py" target="_blank" rel="external">由VASP的输出文件生成相应的MaterialStudio可以显示的xsd文件的脚本</a></li>
<li><a href="https://github.com/PytLab/VASPy/blob/master/scripts/create_neb_inputs.py" target="_blank" rel="external">由MaterialStudio的轨迹文件生成VASP进行NEB搜索过渡态的输入文件的脚本</a></li>
</ul>
<p>由VASP结果生成MaterialStudio的轨迹文件的动画效果图:</p>
<p><img src="/assets/images/blog_img/2016-11-26-使用VASPy快速处理VASP文件以及数据可视化/sn2_my.gif" alt=""></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>VASPy最初的想法是通过Python优雅简洁的特点将VASP的文件处理进行模块化，从而省去了重复写脚本的所花费的精力，使操作VASP文件像操作变量一样简单有效。<br>目前本项目都是在作者工作需要的基础上不断对其功能和接口进行完善，但仍只是冰山一角，希望做计算模拟使用VASP的Pythoner们能不断参与进来，使其更加出色和高效。</p>
]]></content>
      
        <categories>
            
            <category> 学术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> VASP </tag>
            
            <tag> VASPy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TEDxCaohejing志愿-与C++之父Bjarne的近距离接触]]></title>
      <url>http://pytlab.github.io/2016/10/25/TEDxCaohejing%E5%BF%97%E6%84%BF-%E4%B8%8ECpp%E4%B9%8B%E7%88%B6Bjarne%E7%9A%84%E8%BF%91%E8%B7%9D%E7%A6%BB%E6%8E%A5%E8%A7%A6/</url>
      <content type="html"><![CDATA[<p>看到这次TEDxCaohejing把C++之父Bjarne Stroustrup请来了我真是非常激动，毫不犹豫的报名了TEDxCaohejing的志愿者希望能与C++之父有近距离的接触。最终如愿以偿，听了Bjarne的报告关于C++的过去和未来以及他对C++的期望和看法。最近一直再用C++写kinetic Monte Carlo程序，希望借此机会能让Bjarne保佑我靠你的C++帮我发出文章出来！</p>
<p>志愿者期间也认识了许多的新朋友，Jade，Snow，Vivian，刘紫伦等等跟你们交流也学到了很多新的东西。关于这次TED我一直坐在场边，当Bjarne上台时我也是无比激动的。</p>
<a id="more"></a>
<p>Bjarne从他小时候谈起，谈到他父亲对他入行的影响，以及后来他在剑桥，贝尔实验室的探索与发明C++编程语言的心路历程。结合汽车，火箭，火星车，搜索引擎，Bjarne的初心是C++让人们的生活更加美好。。</p>
<p>在他的报告里我看到Fortran， C这些老前辈的影子（C++也算是老前辈了吧），为了讲C++的抽象编程，Bjarne特地拿出了vector的模板定义进行了讲解。。。茶歇期间有很多人围住了Bjarne向他问问题，只可惜我没能插进去，只能在一旁默默的听，也算是有些收获吧哈哈。</p>
<p>不过作为志愿者的福利我抓住了最后结束以后接触Bjarne的机会和他合了张影，真是超级满足哈哈哈。</p>
<p><img src="/assets/images/blog_img/2016-10-30-TEDxCaohejing志愿-与Cpp之父Bjarne的近距离接触/IMG_20161025_170702.jpg" alt=""></p>
<p><img src="/assets/images/blog_img/2016-10-30-TEDxCaohejing志愿-与Cpp之父Bjarne的近距离接触/IMG_20161025_170705.jpg" alt=""></p>
<p>不要问我问什么没看镜头（因为我也不知道。。。估计当时很激动不知道看哪里了吧。。。</p>
<p>贴上一些我自己手机拍的一些照片吧。</p>
<p><img src="/assets/images/blog_img/2016-10-30-TEDxCaohejing志愿-与Cpp之父Bjarne的近距离接触/IMG_20161024_200128.jpg" alt=""></p>
<p><img src="/assets/images/blog_img/2016-10-30-TEDxCaohejing志愿-与Cpp之父Bjarne的近距离接触/IMG_20161024_202859.jpg" alt=""></p>
<p>前一晚上的照片</p>
<p><img src="/assets/images/blog_img/2016-10-30-TEDxCaohejing志愿-与Cpp之父Bjarne的近距离接触/IMG_20161025_103740.jpg" alt=""></p>
<p><img src="/assets/images/blog_img/2016-10-30-TEDxCaohejing志愿-与Cpp之父Bjarne的近距离接触/IMG_20161025_115311.jpg" alt=""></p>
<p><img src="/assets/images/blog_img/2016-10-30-TEDxCaohejing志愿-与Cpp之父Bjarne的近距离接触/IMG_20161025_140129.jpg" alt=""></p>
<p>趁机在台下码了两行C++嘿嘿</p>
<p><img src="/assets/images/blog_img/2016-10-30-TEDxCaohejing志愿-与Cpp之父Bjarne的近距离接触/IMG_20161025_180050.jpg" alt=""></p>
<p><img src="/assets/images/blog_img/2016-10-30-TEDxCaohejing志愿-与Cpp之父Bjarne的近距离接触/IMG_20161025_175538.jpg" alt=""></p>
<p><img src="/assets/images/blog_img/2016-10-30-TEDxCaohejing志愿-与Cpp之父Bjarne的近距离接触/IMG_20161025_180243.jpg" alt=""></p>
<p><img src="/assets/images/blog_img/2016-10-30-TEDxCaohejing志愿-与Cpp之父Bjarne的近距离接触/IMG_20161025_180706.jpg" alt=""></p>
<p>最后漕河泾这边也让我们志愿者参加了他们的酒会</p>
]]></content>
      
        <categories>
            
            <category> 我的日常 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++的delegation constructor]]></title>
      <url>http://pytlab.github.io/2016/10/20/C-%E7%9A%84delegation-constructor/</url>
      <content type="html"><![CDATA[<p>昨晚给KMCLibX的Process类添加了一个新的构造函数，目的是想快速添加slow_flag到process中。结果我想能不能在一个构造函数中调用同类中的另一个构造函数，于是我发现了C++11有了个新特性叫做<a href="https://en.wikipedia.org/wiki/C%2B%2B11#Object_construction_improvement" target="_blank" rel="external">delegation constructor</a></p>
<p>在C++03中是不允许在一个构造函数中调用另一个构造函数的，要实现这种效果需要写一个共有的初始化函数然后再不同的构造函数中调用，例如：<br><a id="more"></a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Foo</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Foo(<span class="keyword">char</span> x);</div><div class="line">    Foo(<span class="keyword">char</span> x, <span class="keyword">int</span> y);</div><div class="line">    ...</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">char</span> x, <span class="keyword">int</span> y)</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Foo::Foo(<span class="keyword">char</span> x)</div><div class="line">&#123;</div><div class="line">    init(x, <span class="keyword">int</span>(x) + <span class="number">7</span>);</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo::Foo(<span class="keyword">char</span> x, <span class="keyword">int</span> y)</div><div class="line">&#123;</div><div class="line">    init(x, y);</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Foo::init(<span class="keyword">char</span> x, <span class="keyword">int</span> y)</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>C++11允许了我们直接在一个构造函数中直接调用另一个构造函数。语法如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> SomeType</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> number;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    SomeType(<span class="keyword">int</span> new_number) : number(new_number) &#123;&#125;</div><div class="line">    SomeType() : SomeType(<span class="number">42</span>) &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>注意并不是说直接可以再函数体中调用，而是要在<strong>初始化列表</strong>中调用，并且初始化列表中只能由这一个初始化语句。</p>
<p>现在的Process多态构造函数就象这样了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Process::Process(<span class="keyword">const</span> Configuration &amp; first,</div><div class="line">                 <span class="keyword">const</span> Configuration &amp; second,</div><div class="line">                 <span class="keyword">const</span> <span class="keyword">double</span> rate,</div><div class="line">                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; basis_sites,</div><div class="line">                 <span class="keyword">const</span> <span class="keyword">bool</span> slow) :</div><div class="line">    Process(first, second, rate, basis_sites, &#123;&#125;, &#123;&#125;, <span class="number">-1</span>, &#123;&#125;, slow)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// NOTHING HERE.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> delegation constructor </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python模块的打包与发布小结]]></title>
      <url>http://pytlab.github.io/2016/09/16/python%E6%A8%A1%E5%9D%97%E7%9A%84%E6%89%93%E5%8C%85%E4%B8%8E%E5%8F%91%E5%B8%83%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天把自己的VASP文件处理库进行了打包并上传到PyPI，现在可以直接通过<code>pip</code>和<code>easy_install</code>来安装VASPy啦，</p>
<ul>
<li>VASPy的GotHub地址：<a href="https://github.com/PytLab/VASPy" target="_blank" rel="external">https://github.com/PytLab/VASPy</a></li>
<li>VASPy的PyPI地址：<a href="https://pypi.python.org/pypi/vaspy/" target="_blank" rel="external">https://pypi.python.org/pypi/vaspy/</a></li>
</ul>
<p>由于自己的记性真是不咋地，怕时间久了就忘了，于是在这里趁热打铁以自己的VASPy程序为例对python的打包和上传进行下总结。</p>
<a id="more"></a>
<h2 id="VASPy包文件结构"><a href="#VASPy包文件结构" class="headerlink" title="VASPy包文件结构"></a>VASPy包文件结构</h2><p>首先写贴上来VASPy包的整个文件结构, 后面的内容都是以此为例进行说明：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">VASPy/</div><div class="line">├── LICENSE</div><div class="line">├── MANIFEST</div><div class="line">├── MANIFEST<span class="selector-class">.in</span></div><div class="line">├── README<span class="selector-class">.rst</span></div><div class="line">├── requirements<span class="selector-class">.txt</span></div><div class="line">├── scripts</div><div class="line">│   ├── change_incar_parameters<span class="selector-class">.py</span></div><div class="line">│   ├── create_inputs<span class="selector-class">.py</span></div><div class="line">│   └── ...</div><div class="line">├── setup<span class="selector-class">.cfg</span></div><div class="line">├── setup<span class="selector-class">.py</span></div><div class="line">├── tests</div><div class="line">│   ├── incar_test<span class="selector-class">.py</span></div><div class="line">│   ├── __init__<span class="selector-class">.py</span></div><div class="line">│   ├── oszicar_test<span class="selector-class">.py</span></div><div class="line">│   ├── outcar_test<span class="selector-class">.py</span></div><div class="line">│   ├── testdata</div><div class="line">│   │   ├── CONTCAR</div><div class="line">│   │   ├── DOS_SUM</div><div class="line">│   │   ├── ELFCAR</div><div class="line">│   │   └── ...</div><div class="line">│   └── ...</div><div class="line">└── vaspy</div><div class="line">    ├── __init__<span class="selector-class">.py</span></div><div class="line">    ├── iter<span class="selector-class">.py</span></div><div class="line">    ├── matstudio<span class="selector-class">.py</span></div><div class="line">    └── ...</div><div class="line"></div><div class="line"><span class="number">4</span> directories, <span class="number">54</span> files</div></pre></td></tr></table></figure>
<h2 id="打包和安装第三方包的工具"><a href="#打包和安装第三方包的工具" class="headerlink" title="打包和安装第三方包的工具"></a>打包和安装第三方包的工具</h2><ul>
<li><p>这里我们需要借助<code>setuptools</code>和<code>pip</code>等工具进行自己包的打包和发布以及安装，如果需要构建成wheel还需要安装<code>wheel</code>模块。如果python版本&gt;=2.7.9或者&gt;=3.4，setuptools和pip是已经安装好的，可能需要进行更新到最新版本。</p>
  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip <span class="keyword">install</span> -U pip setuptools</div></pre></td></tr></table></figure>
</li>
<li><p>可以使用包管理工具，例如</p>
  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum <span class="keyword">install</span> pip</div></pre></td></tr></table></figure>
  <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-<span class="keyword">get</span> install pip</div></pre></td></tr></table></figure>
</li>
<li><p>通过<code>get-pip.py</code>脚本安装，如果检测到没有安装<code>wheel</code>和<code>setuptools</code>也会自动安装。</p>
  <figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">python</span> <span class="built_in">get</span>-pip.<span class="keyword">py</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>具体的工具安装和介绍就不多讲了，可以请参考<a href="https://packaging.python.org/installing/#installing-requirements" target="_blank" rel="external">requirements for installing packages</a></p>
<h2 id="包中不同文件的作用"><a href="#包中不同文件的作用" class="headerlink" title="包中不同文件的作用"></a>包中不同文件的作用</h2><h3 id="setup-py"><a href="#setup-py" class="headerlink" title="setup.py"></a><code>setup.py</code></h3><p>这个文件是打包整个项目最重要的文件，它里面提供了两个主要的功能：</p>
<ol>
<li><code>setup()</code>函数，此函数的参数指定了如何配置自己的项目。</li>
<li>命令行工具，包括打包，测试，发布等。可以通过下面的命令查看； <figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">python</span> setup.<span class="keyword">py</span> --<span class="keyword">help</span>-commands</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="setup-cfg"><a href="#setup-cfg" class="headerlink" title="setup.cfg"></a><code>setup.cfg</code></h3><p>此文件包含了构建时候的一些默认参数例如构建<code>bdist_wheel</code>的时候的<code>--universal</code>参数<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="section">[bdist_wheel]</span></div><div class="line"><span class="attr">universal</span>=<span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>这样每次打包的时候就会默认使用<code>--universal</code>参数了，效果类似：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python setup<span class="selector-class">.py</span> bdist_wheel --universal</div></pre></td></tr></table></figure></p>
<h3 id="README-rst"><a href="#README-rst" class="headerlink" title="README.rst"></a><code>README.rst</code></h3><p>这个最初我是用markdown写的，打包发布到PyPI之后发现PyPI不支持markdown的渲染，页面上真是一片混乱，于是就用reStrutruedText的语法重新写了一遍。毕竟标记语言语法基本上可以秒上手，实在不行找个模板比葫芦画瓢就行。<br>reStructureText的语法规则可参考官方文档:<a href="http://docutils.sourceforge.net/docs/user/rst/quickref.html" target="_blank" rel="external">Quick <em>re</em>Structured<em>Text</em></a></p>
<p>其实还有一种方法就是使用pandoc将markdown转换成rst格式，一种省事的方式就是使用<code>pyandoc</code>模块在发布的时候自动转换。<br>具体方法可以参考：<a href="https://coderwall.com/p/qawuyq/use-markdown-readme-s-in-python-modules" target="_blank" rel="external">Use Markdown README’s in Python modules</a></p>
<h3 id="MANIFEST-in"><a href="#MANIFEST-in" class="headerlink" title="MANIFEST.in"></a><code>MANIFEST.in</code></h3><p>此文件在打包的时候告诉setuptools还需要额外打包那些文件，例如我VASPy中的单元测试的测试数据文件我就使用这个文件将其包含进来。当然README，LICENSE这些也可以通过它来一起打包进来。<br>下面是我自己的<code>MANIFEST.in</code>的内容：<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">include</span> README.rst</div><div class="line"><span class="keyword">include</span> requirements.txt</div><div class="line"><span class="keyword">include</span> LICENSE</div><div class="line"><span class="keyword">recursive</span>-<span class="keyword">include</span> scripts *</div><div class="line"><span class="keyword">recursive</span>-<span class="keyword">include</span> tests *</div></pre></td></tr></table></figure></p>
<p>具体的语法规则可以参考：<a href="https://docs.python.org/2/distutils/sourcedist.html#the-manifest-in-template" target="_blank" rel="external">The MANIFEST.in template</a></p>
<h3 id="vaspy"><a href="#vaspy" class="headerlink" title="vaspy/"></a><code>vaspy/</code></h3><p>此文件夹就是vaspy源代码所在的包。</p>
<h3 id="tests"><a href="#tests" class="headerlink" title="tests/"></a><code>tests/</code></h3><p>此文件夹也是一个子包，包含了单元测试脚本，为了能使用<code>python setup.py test</code>进行单元测试，特地添加了<code>__init__.py</code>s使其成为一个包。</p>
<h2 id="setup-的参数"><a href="#setup-的参数" class="headerlink" title="setup()的参数"></a><code>setup()</code>的参数</h2><p>这里只介绍我使用的几个参数，其他参数的具体使用可以参考：<a href="https://docs.python.org/3/distutils/setupscript.html" target="_blank" rel="external">https://docs.python.org/3/distutils/setupscript.html</a></p>
<h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">versions</span> = <span class="string">"vaspy"</span></div></pre></td></tr></table></figure>
<p>是整个项目的名字，打包后会使用此名字和版本号。</p>
<h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> vaspy import <span class="variable">__version__</span></div><div class="line">version = <span class="variable">__version__</span></div></pre></td></tr></table></figure>
<h3 id="description"><a href="#description" class="headerlink" title="description"></a>description</h3><p>是一个简短的对项目的描述，一般一句话就好，会显示在pypi上名字下端。</p>
<h3 id="long-description"><a href="#long-description" class="headerlink" title="long_description"></a>long_description</h3><p>是一个长的描述，相当于对项目的一个简洁，如果此字符串是<code>rst</code>格式的，PyPI会自动渲染成HTML显示。这里可以直接读取<code>README.rst</code>中的内容。</p>
<h3 id="url"><a href="#url" class="headerlink" title="url"></a>url</h3><p>包的连接，通常为GitHub上的链接或者readthedocs的链接。</p>
<h3 id="packages"><a href="#packages" class="headerlink" title="packages"></a>packages</h3><p>需要包含的子包列表，setuptools提供了<code>find_packages()</code>帮助我们在根路径下寻找包，这个函数distutil是没有的。</p>
<h3 id="setup-requires"><a href="#setup-requires" class="headerlink" title="setup_requires"></a>setup_requires</h3><p>这个参数定义了VASPy安装和顺利运行所需要的其他依赖项（最基本的），使用pip安装的时候会对这些依赖项进行安装。<br>关于这个参数与requirements.txt的区别可以参考：<a href="https://packaging.python.org/requirements/#install-requires-vs-requirements-files" target="_blank" rel="external">install_requires vs Requirements files</a></p>
<h3 id="classifier"><a href="#classifier" class="headerlink" title="classifier"></a>classifier</h3><p>这个参数提供了一系列的分类，在PyPI上会将其放入不同的目录中讲项目进行归类。<br>具体的categories的名称和规则参考：<a href="https://pypi.python.org/pypi?%3Aaction=list_classifiers" target="_blank" rel="external">https://pypi.python.org/pypi?%3Aaction=list_classifiers</a></p>
<h3 id="test-suite"><a href="#test-suite" class="headerlink" title="test_suite"></a>test_suite</h3><p>这个参数可以帮助我们使用<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python setup<span class="selector-class">.py</span> test</div></pre></td></tr></table></figure></p>
<p>来跑单元测试，再也不需要单独再写一个脚本例如<code>run_tests.py</code>这样来跑单元测试了。<br>此参数的官方解释：</p>
<blockquote>
<p>A string naming a unittest.TestCase subclass (or a package or module containing one or more of them, or a method of such a subclass), or naming a function that can be called with no arguments and returns a unittest.TestSuite. If the named suite is a module, and the module has an additional_tests() function, it is called and the results are added to the tests to be run. If the named suite is a package, any submodules and subpackages are recursively added to the overall test suite.</p>
</blockquote>
<p>也就是说这个参数可以接受多种类型的参数：</p>
<ol>
<li>接收<code>unittest.TestCase</code>子类，我们可以讲所有单元测试写入一个测试用例中，然后import进来，再传你给<code>test_suite</code></li>
<li>接收函数对象，此函数对象没有任何参数，且返回一个<code>unittest.TestSuite</code>.这样我们就可以单独写一个函数，将多个测试用例合并成一个suite然后返回，然后再将函数import进来传给<code>test_suite</code>。</li>
<li>模块和包名称，我就是使用这种方式，之前自己的测试都是分开的多个脚本，这样我添加一个<code>__init__.py</code>就可以将其变成一个包，将包名传给<code>test_suite</code>，setuptools就会神奇的将此包下的所有测试全部跑一边，这样我以后再加测试脚本的时候直接就添加新的脚本就好了，其他的都不需要改动了。<br> 运行效果： <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">zjshao@SHAO-PC:/mnt/d/Dropbox/Code/CentOS_code/VASPy$ python setup.py test</div><div class="line">running test</div><div class="line">running egg_info</div><div class="line">creating vaspy.egg-info</div><div class="line">writing vaspy.egg-info/PKG-INFO</div><div class="line">writing top-level names <span class="built_in">to</span> vaspy.egg-info/top_level.txt</div><div class="line">writing dependency_links <span class="built_in">to</span> vaspy.egg-info/dependency_links.txt</div><div class="line">writing manifest <span class="built_in">file</span> <span class="string">'vaspy.egg-info/SOURCES.txt'</span></div><div class="line">reading manifest <span class="built_in">file</span> <span class="string">'vaspy.egg-info/SOURCES.txt'</span></div><div class="line">reading manifest template <span class="string">'MANIFEST.in'</span></div><div class="line">writing manifest <span class="built_in">file</span> <span class="string">'vaspy.egg-info/SOURCES.txt'</span></div><div class="line">running build_ext</div><div class="line">test_compare (tests.incar_test.InCarTest)</div><div class="line">Make sure we can compare <span class="literal">two</span> InCar objects correctly. ... ok</div><div class="line">test_eq (tests.incar_test.InCarTest)</div><div class="line">Test __eq__() <span class="function"><span class="keyword">function</span>. ... <span class="title">ok</span></span></div><div class="line">...</div><div class="line">此处省略若干输出</div><div class="line"></div><div class="line"><span class="comment">----------------------------------------------------------------------</span></div><div class="line">Ran <span class="number">22</span> tests <span class="keyword">in</span> <span class="number">3.574</span>s</div><div class="line"></div><div class="line">OK</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="发布自己的python包"><a href="#发布自己的python包" class="headerlink" title="发布自己的python包"></a>发布自己的python包</h2><ol>
<li><p>首先先去PyPI注册帐号</p>
</li>
<li><p>配置<code>~/.pypirc</code>如下：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[distutils]</div><div class="line">index-servers =</div><div class="line">    pypi</div><div class="line">    pypitest</div><div class="line"></div><div class="line">[pypi]</div><div class="line">username:ShaoZhengjiang</div><div class="line">password:mypassword</div><div class="line"></div><div class="line">[pypitest]</div><div class="line">username:ShaoZhengjiang</div><div class="line">password:mypassword</div></pre></td></tr></table></figure>
</li>
<li><p>然后注册并上传自己的包到测试服务器<br> pypi提供了一个测试服务器，我们可以在这个测试服务器上做测试。</p>
 <figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python <span class="built_in">setup</span>.py <span class="keyword">register</span> -r pypitest</div></pre></td></tr></table></figure>
<p> 然后</p>
 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python setup<span class="selector-class">.py</span> sdist upload -r pypitest</div></pre></td></tr></table></figure>
<p> 若没有问题我们应该不会得到任何错误。</p>
</li>
<li><p>上传至PyPI<br> 若上面的测试成功，我们就可以按照相同的步骤将包注册并上传。</p>
 <figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python <span class="built_in">setup</span>.py <span class="keyword">register</span> -r pypi</div></pre></td></tr></table></figure>
 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python setup<span class="selector-class">.py</span> sdist upload -r pypi</div></pre></td></tr></table></figure>
</li>
</ol>
<p>Ok,之后我们就可以在PyPI上看到我们自己的包了。(<a href="https://pypi.python.org/pypi/vaspy/" target="_blank" rel="external">https://pypi.python.org/pypi/vaspy/</a>)</p>
<p><img src="/assets/images/blog_img/2016-09-16-python模块的打包与发布小结/vaspy_pypi.png" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://coderwall.com/p/qawuyq/use-markdown-readme-s-in-python-modules" target="_blank" rel="external">Use Markdown README’s in Python modules</a></li>
<li><a href="https://packaging.python.org/distributing/#package-data" target="_blank" rel="external">Packaging and Distributing Projects</a></li>
<li><a href="http://stackoverflow.com/questions/50499/how-do-i-get-the-path-and-name-of-the-file-that-is-currently-executing" target="_blank" rel="external">How do I get the path and name of the file that is currently executing?</a></li>
<li><a href="http://peterdowns.com/posts/first-time-with-pypi.html" target="_blank" rel="external">How to submit a package to PyPI</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> setuptools </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[难忘的pycon china 2016]]></title>
      <url>http://pytlab.github.io/2016/09/13/%E9%9A%BE%E5%BF%98%E7%9A%84pycon-china-2016/</url>
      <content type="html"><![CDATA[<p>上次沙龙活动就听说了pycon china，很是想去，于是就在暑假报名了今年的pycon的志愿者，希望能跟更多领域的更多pythoner进行交流和学习。由于做了志愿者就有很多其他的事情要处理，虽然很累，但是收获了不少。在这里就纪念下这次pycon，算是一个不错的回忆，希望能以后能进步更多，有一天能达到会上演讲嘉宾和其他pythoner的水平。</p>
<p>这次大会不知道其他高手们怎么看，有很多东西都是我不知道的，有了这次机会我接触了一些自己不会的东西，对他们有了大致的了解，对我来说这就是干货呀。虽然里面没有人做科学计算的，但是也有数据可是或，人工智能深度学习，量化交易等主题，至少和我擅长的有所交集。</p>
<p>这里我就稍微总结下几个嘉宾的报告内容（纯属个人总结。</p>
<a id="more"></a>
<ol>
<li><p><strong>《聊聊python和量化投资》</strong><br> 这个毕竟知乎上的名人和名项目了，所以之前就听说有很多人是冲着他的报告来的，听了他的报告我也了解了什么事量化交易，知道了他封装C++模块的方法等。<br> 陈晓优首先介绍了什么是量化投资以及量化投资的科学建模方法、计算机驱动以及高速交易等特点，同时又对比了机构管理和散户炒股方法上的本质区别。针对python陈晓优针对从交易员的观点出发列出了使用python完成量化交易框架的几个原因，同时介绍了python做量化投资的从数据收集到实盘交易的工具链其中包括例如numpy，scipy，ipython notebook等著名的工具。针对人气火爆的vnpy框架他详细的介绍了vnpy中的python对交易接口的封装、事件驱动引擎以及活跃的社区等内容，最后介绍了vnpy框架的整体架构。<br> 这里面他使用了<code>boost.python</code>来封装C++交易接口，同时他也提到了为什么选择使用<code>boost.python</code>而不是<code>swig</code>这些，虽然我自己的模块都是swig封装的，但是我对这个boost.python非常的感兴趣，貌似不用写swig的接口文件了，而是尽情地去写C++和python就好了，恩，过段时间去看看<code>boost.python</code>的文档去。</p>
</li>
<li><p><strong>《用高魔的姿势调python程序》</strong><br> 饿了么Python框架负责人郭浩川带来了他在饿了么使用dtrace和systemtap调试python的高魔方法的快速演讲。这两个强有力的工具可以帮助程序员在任何时间任何地点对python进程进行检查和调试，也可以方便的对gevent环境下程序进行性能剖析。针对dtrace和systemtap郭浩川先对这两个工具的特点以及优缺点进行了分析和介绍，最后使用了gevent patch程序的性能剖析的具体事例讲解了如何使用这两个工具进行高逼格的python调优。<br> 这个我是真不了解，一个是现在我也没有使用gevent写过协程，dtrace和systemtap也没有使用过，不过听下报告来，感觉这工具的确是很好用，也可以很好的进行profiling，这几天我就把自己的代码进行profiling了，有机会一定接触解除。</p>
</li>
<li><p><strong>《Python数据可视化的应用与价值》</strong><br> 熟悉数据可视化的杨洁坤首先先介绍了什么是数据可视化以及数据可视化的一些基本概念和基本算法，主要通过社交网站的用户活跃度曲线以及好友数量分布曲线介绍了滤波和拟合算法。<br> 后面他基于三个python数据可视化的实践项目介绍了数据可视化的应用与价值。<br> 第一个是服务器性能监控的滤波和可视化，将统计数据可视化找出肉眼难以识别的重要bug。<br> 第二个是通过绘制彩票的K线图来“赚一点小钱”，通过随机数据的可视化，监控不符合统计规律的异常点总结选号算法。<br> 第三个是通过FR算法和组群识别算法将社交网络的好友关系网络结构可视化来找出“隐秘的红颜知己”</p>
<p> 很有趣的几个例子，很实用，也涉及了一些基本算法，等有机会也做个酷炫的网络关系图玩玩。</p>
</li>
<li><p><strong>《TensorFlow框架剖析及应用》</strong><br> 百纳信息科技有限公司人工智能方向负责人王琛从有名的alpha go和基于深度学习技术的修图APP介绍了机器学习之神经网络的基本概念例如模型训练BackPropagation算法等，同时介绍了python中常用于机器学习的库和模块其中包括Numpy，Scipy、Caffe和Theano等。<br> 之后王琛介绍了Google发起的著名的开源机器学习框架TensorFlow，讲解了TensorFlow的核心需求、架构设计、数据并行以及计算表示模型-数据流图（DataflowGraph），并通过简单的代码实例讲解了tensor flow简单的前端编程接口的使用。<br> 最后，王琛先生以自己团队使用深度学习方法制作类似Prisma的图片风格化应用为例讲解了TensorFlow的具体实战方法和经验。</p>
<p> 这个我是最感兴趣的之一，一个是一直对机器学习的算法感兴趣，虽然现在自己的课题没有涉及到机器学习，也没有机会使用强大tensorflow，希望有一天我能见识下jeff dean大神的这个作品的nb。</p>
</li>
</ol>
<p>由于自己被分配成场内志愿者负责人，所以开会之前我就提前去了两次浦软大厦做准备。不多说了，放几张图吧哈哈。。。</p>
<p>这个是再浦软大厦窗户上向外照的，可以看到2345.com和沪江网的logo<br><img src="/assets/images/blog_img/2016-09-13-难忘的pycon-china-2016/window.jpg" alt=""></p>
<p>当苦工。。。<br><img src="/assets/images/blog_img/2016-09-13-难忘的pycon-china-2016/bags.jpg" alt=""><br><img src="/assets/images/blog_img/2016-09-13-难忘的pycon-china-2016/bags2.jpg" alt=""><br><img src="/assets/images/blog_img/2016-09-13-难忘的pycon-china-2016/pythoner.jpg" alt=""></p>
<p>最后的合照<br><img src="/assets/images/blog_img/2016-09-13-难忘的pycon-china-2016/groupphoto.jpg" alt=""><br><img src="/assets/images/blog_img/2016-09-13-难忘的pycon-china-2016/groupphoto2.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 我的日常 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> PyCon China </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CentOS: Network is unreachable的解决方法]]></title>
      <url>http://pytlab.github.io/2016/09/01/CentOS-Network-is-unreachable/</url>
      <content type="html"><![CDATA[<p>自己的虚拟机上的CentOS连接不上网了，ping外网的ip会显示<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Connetion: Network is unreachable</div></pre></td></tr></table></figure></p>
<p>一开始以为是虚拟机的问题，把虚拟机的网卡卸载又重新安装也还是没用，这时候便是linux本身的问题了。</p>
<p>网络重启也会失败：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ service network restart</div><div class="line">Restarting network (via systemctl): Job <span class="keyword">for</span> network.service failed. See *systemctl status network.service* and *journalctl -xn* <span class="keyword">for</span> details.</div><div class="line">[FAILED]</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>于是我就看了下日志到底是哪里出错<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cat /var/<span class="built_in">log</span>/messages | grep network</div></pre></td></tr></table></figure></p>
<p><img src="/assets/images/blog_img/2016-09-01-CentOS-Network-is-unreachable/error.png" alt=""><br>可见是网卡的物理地址冲突，于是就需要去相应网卡的配置文件去修改物理地址。<br>首先先看目前网卡的真正物理地址是什么:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ip addr</div></pre></td></tr></table></figure></p>
<p><img src="/assets/images/blog_img/2016-09-01-CentOS-Network-is-unreachable/ipaddr.png" alt=""></p>
<p>然后修改配置文件:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vi /etc/sysconfig/network-scripts/ifcfg-eno16777736</div></pre></td></tr></table></figure></p>
<p>将<code>HWADRR</code>的值修改或者添加成当前网卡地址.</p>
<p>最后通过<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ service network restart</div></pre></td></tr></table></figure></p>
<p>重启网卡，或者通过<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ifup eth0</div></pre></td></tr></table></figure></p>
<p>启动网卡（该命令会检查配置文件）.</p>
<p>这样就恢复啦，pip, yum, 可以正常使用了.</p>
]]></content>
      
        <categories>
            
            <category> 我的日常 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> VMWare </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MPI集合通信：N → N]]></title>
      <url>http://pytlab.github.io/2016/08/21/MPI%E9%9B%86%E5%90%88%E9%80%9A%E4%BF%A1%EF%BC%9AN-N/</url>
      <content type="html"><![CDATA[<p>这里总结MPI集合通信中的 N-&gt;N 通信，多个进程将数据经过某种处理以后在发散到同组内的其他进程中，这些进程可以看成是其他 N-&gt;1 和 1-&gt;N 通信的组合。</p>
<h3 id="MPI-Allgather"><a href="#MPI-Allgather" class="headerlink" title="MPI_Allgather"></a><code>MPI_Allgather</code></h3><p>此操作将分散在各个进程中的数据进行收集操作，然后再将收集到的向量广播到同组内的所有进程中，也就是先使用<code>MPI_Gather</code>，然后再使用<code>MPI_Bcast</code>。与<code>MPI_Gather</code>相同，收集到的数据顺序与进程号的顺序相同。<br><a id="more"></a><br><img src="/assets/images/blog_img/2016-08-21-MPI集合通信：N-N/allgather.png" alt=""></p>
<p>看一下函数原型，基本上与<code>MPI_Gather</code>相同，但是这回不需要指定根进程了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">MPI_Allgather(<span class="keyword">void</span>* send_data,</div><div class="line">              <span class="keyword">int</span> send_count,</div><div class="line">              MPI_Datatype send_datatype,</div><div class="line">              <span class="keyword">void</span>* recv_data,</div><div class="line">              <span class="keyword">int</span> recv_count,</div><div class="line">              MPI_Datatype recv_datatype,</div><div class="line">              MPI_Comm communicator)</div></pre></td></tr></table></figure></p>
<p>下面我写了个简单的小例子来看看效果：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mpi.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 5</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> sb[SIZE], rank, nproc;</div><div class="line">    MPI_Comm comm = MPI_COMM_WORLD;</div><div class="line">    <span class="keyword">char</span> outstr[nproc*SIZE*<span class="number">100</span>];</div><div class="line"></div><div class="line">    MPI_Init(&amp;argc, &amp;argv);</div><div class="line">    MPI_Comm_rank(comm, &amp;rank);</div><div class="line">    MPI_Comm_size(comm, &amp;nproc);</div><div class="line"></div><div class="line">    <span class="comment">// Allocate receive buffer.</span></div><div class="line">    <span class="keyword">int</span> * rb = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(nproc*SIZE*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line"></div><div class="line">    <span class="comment">// Fill send buffer.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i)</div><div class="line">    &#123;</div><div class="line">        sb[i] = SIZE*rank + i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    MPI_Allgather(sb, SIZE, MPI_INT, rb, SIZE, MPI_INT, comm);</div><div class="line"></div><div class="line">    <span class="built_in">sprintf</span>(outstr, <span class="string">"proc: %d. "</span>, rank);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE*nproc; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">sprintf</span>(outstr, <span class="string">"%srb[%d] = %d, "</span>,outstr, i, rb[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, outstr);</div><div class="line"></div><div class="line">    <span class="built_in">free</span>(rb);</div><div class="line"></div><div class="line">    MPI_Finalize();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[zjshao@master 4-3-1]$ mpiexec -n 4 -host node01 allgather.x</div><div class="line">proc: 0. rb[0] = 0, rb[1] = 1, rb[2] = 2, rb[3] = 3, rb[4] = 4, rb[5] = 5, rb[6] = 6, rb[7] = 7, rb[8] = 8, rb[9] = 9, rb[10] = 10, rb[11] = 11, rb[12] = 12, rb[13] = 13, rb[14] = 14, rb[15] = 15, rb[16] = 16, rb[17] = 17, rb[18] = 18, rb[19] = 19, </div><div class="line">proc: 1. rb[0] = 0, rb[1] = 1, rb[2] = 2, rb[3] = 3, rb[4] = 4, rb[5] = 5, rb[6] = 6, rb[7] = 7, rb[8] = 8, rb[9] = 9, rb[10] = 10, rb[11] = 11, rb[12] = 12, rb[13] = 13, rb[14] = 14, rb[15] = 15, rb[16] = 16, rb[17] = 17, rb[18] = 18, rb[19] = 19, </div><div class="line">proc: 2. rb[0] = 0, rb[1] = 1, rb[2] = 2, rb[3] = 3, rb[4] = 4, rb[5] = 5, rb[6] = 6, rb[7] = 7, rb[8] = 8, rb[9] = 9, rb[10] = 10, rb[11] = 11, rb[12] = 12, rb[13] = 13, rb[14] = 14, rb[15] = 15, rb[16] = 16, rb[17] = 17, rb[18] = 18, rb[19] = 19, </div><div class="line">proc: 3. rb[0] = 0, rb[1] = 1, rb[2] = 2, rb[3] = 3, rb[4] = 4, rb[5] = 5, rb[6] = 6, rb[7] = 7, rb[8] = 8, rb[9] = 9, rb[10] = 10, rb[11] = 11, rb[12] = 12, rb[13] = 13, rb[14] = 14, rb[15] = 15, rb[16] = 16, rb[17] = 17, rb[18] = 18, rb[19] = 19, </div><div class="line">[zjshao@master 4-3-1]$</div></pre></td></tr></table></figure></p>
<p>这里我没有收集单个数而是一数组，所以输出会比较多。</p>
<h3 id="MPI-Allreduce"><a href="#MPI-Allreduce" class="headerlink" title="MPI_Allreduce"></a><code>MPI_Allreduce</code></h3><p>其实就是将上面的收集操作替换成了规约操作，其他过程是一样的，组内所有进程都作为根执行一次规约操作，操作完毕后所有进程接收缓冲区的数据均相同。这个操作等价于先进程一次<code>MPI_Reduce</code>然后再执行一次<code>MPI_Bcast</code>。<br><img src="/assets/images/blog_img/2016-08-21-MPI集合通信：N-N/mpi_allreduce_1.png" alt=""></p>
<p>函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Allreduce</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *sendbuf,</span></span></div><div class="line">                  <span class="keyword">void</span> *recvbuf,</div><div class="line">                  <span class="keyword">int</span> count,</div><div class="line">                  MPI_Datatype datatype,</div><div class="line">                  MPI_Op op,</div><div class="line">                  MPI_Comm comm)</div></pre></td></tr></table></figure></p>
<p>其中count为发送进程缓冲区中发送数据的个数。</p>
<p>下面写了个小例子来看下效果：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mpi.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> rank, nproc, sb, rb;</div><div class="line">    MPI_Comm comm = MPI_COMM_WORLD;</div><div class="line"></div><div class="line">    MPI_Init(&amp;argc, &amp;argv);</div><div class="line">    MPI_Comm_rank(comm, &amp;rank);</div><div class="line">    MPI_Comm_size(comm, &amp;nproc);</div><div class="line"></div><div class="line">    sb = rank + <span class="number">1</span>;</div><div class="line">    MPI_Allreduce(&amp;sb, &amp;rb, <span class="number">1</span>, MPI_INT, MPI_SUM, comm);</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"process %d: sb = %d, rb = %d\n"</span>, rank, sb, rb);</div><div class="line"></div><div class="line">    MPI_Finalize();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[zjshao@master 4-3-2]$ mpiexec -n 4 allreduce.x</div><div class="line">process 1: sb = 2, rb = 10</div><div class="line">process 3: sb = 4, rb = 10</div><div class="line">process 0: sb = 1, rb = 10</div><div class="line">process 2: sb = 3, rb = 10</div><div class="line">[zjshao@master 4-3-2]$</div></pre></td></tr></table></figure></p>
<p>整个过程可以大致用下图来表示：<br><img src="/assets/images/blog_img/2016-08-21-MPI集合通信：N-N/mpi_allreduce.png" alt=""></p>
<h3 id="MPI-Reduce-scatter"><a href="#MPI-Reduce-scatter" class="headerlink" title="MPI_Reduce_scatter"></a><code>MPI_Reduce_scatter</code></h3><p>本操作首先对多个向量进行规约处理，然后再将规约后的向量发散到同组内的其他进程中。相当于以某个进程为根，执行一次规约操作后跟一次发散操作。<br><img src="/assets/images/blog_img/2016-08-21-MPI集合通信：N-N/mpi_reduce_scatter.png" alt=""></p>
<p>函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Reduce_scatter</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *sendbuf,</span></span></div><div class="line">                       <span class="keyword">void</span> *recvbuf,</div><div class="line">                       <span class="keyword">const</span> <span class="keyword">int</span> recvcounts[],</div><div class="line">                       MPI_Datatype datatype,</div><div class="line">                       MPI_Op op,</div><div class="line">                       MPI_Comm comm)</div></pre></td></tr></table></figure></p>
<p>这里需要注意的是<code>const int * recvcounts</code>这个参数，他并不是个整型而是一个int指针，我么可以向其传递一个数组，数组的长度应该与进程数相同，数组中的数表示每个进程中接收得到的数据个数，下面的例子中全部为1。</p>
<p>来看例子吧：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mpi.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 4</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> rank, nproc, rb;</div><div class="line">    <span class="keyword">int</span> sb[SIZE] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</div><div class="line"></div><div class="line">    MPI_Init(&amp;argc, &amp;argv);</div><div class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);</div><div class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;nproc);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> rcnt[SIZE] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</div><div class="line"></div><div class="line">    MPI_Reduce_scatter(sb, &amp;rb, rcnt, MPI_INT, MPI_SUM, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"process %d: rb = %d\n"</span>, rank, rb);</div><div class="line"></div><div class="line">    MPI_Finalize();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个程序与上面图片的过程相同，执行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[zjshao@master 4-3-3]$ mpiexec -n 4 reduce_scatter.x</div><div class="line">process 1: rb = 8</div><div class="line">process 2: rb = 12</div><div class="line">process 3: rb = 16</div><div class="line">process 0: rb = 4</div><div class="line">[zjshao@master 4-3-3]$</div></pre></td></tr></table></figure></p>
<h3 id="MPI-Alltoall"><a href="#MPI-Alltoall" class="headerlink" title="MPI_Alltoall"></a><code>MPI_Alltoall</code></h3><p>此操作将一个通信子内的所有进程都执行一次发散操作，从图上看类似矩阵转置的效果，只不过这里的0轴是进程。<br><img src="/assets/images/blog_img/2016-08-21-MPI集合通信：N-N/mpi_alltoall.png" alt=""></p>
<p>函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Alltoall</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *sendbuf,</span></span></div><div class="line">                 <span class="keyword">int</span> sendcount,</div><div class="line">                 MPI_Datatype sendtype,</div><div class="line">                 <span class="keyword">void</span> *recvbuf,</div><div class="line">                 <span class="keyword">int</span> recvcount,</div><div class="line">                 MPI_Datatype recvtype,</div><div class="line">                 MPI_Comm comm)</div></pre></td></tr></table></figure></p>
<p>这里需要注意的是<code>int sendcount</code>和<code>int recvcount</code>参数，这里是针对一个进程的发散操作而言的，而不是整体。<br>例如下面这张图中的过程，整两个参数都为<em>1</em>，而不是<em>4</em>！<br><img src="/assets/images/blog_img/2016-08-21-MPI集合通信：N-N/mpi_alltoall_.png" alt=""></p>
<p>下面直接上代码例子吧：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mpi.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 4</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> rank, nproc;</div><div class="line">    <span class="keyword">int</span> sb[SIZE], rb[SIZE];</div><div class="line">    MPI_Comm comm = MPI_COMM_WORLD;</div><div class="line">    <span class="keyword">char</span> outstr[<span class="number">50</span>*SIZE + <span class="number">100</span>];</div><div class="line"></div><div class="line">    MPI_Init(&amp;argc, &amp;argv);</div><div class="line">    MPI_Comm_rank(comm, &amp;rank);</div><div class="line">    MPI_Comm_size(comm, &amp;nproc);</div><div class="line"></div><div class="line">    <span class="comment">// Fill send buffer.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i)</div><div class="line">    &#123;</div><div class="line">        sb[i] = SIZE*rank + i + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// All to all.</span></div><div class="line">    MPI_Alltoall(sb, <span class="number">1</span>, MPI_INT, rb, <span class="number">1</span>, MPI_INT, comm);</div><div class="line"></div><div class="line">    <span class="built_in">sprintf</span>(outstr, <span class="string">"proc %d:\n"</span>, rank);</div><div class="line"></div><div class="line">    <span class="comment">// Output send buffer.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">sprintf</span>(outstr, <span class="string">"%ssb[%d] = %d, "</span>, outstr, i, sb[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">sprintf</span>(outstr, <span class="string">"%s\n"</span>, outstr);</div><div class="line"></div><div class="line">    <span class="comment">// Output receive buffer.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">sprintf</span>(outstr, <span class="string">"%srb[%d] = %d, "</span>, outstr, i, rb[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">sprintf</span>(outstr, <span class="string">"%s\n"</span>, outstr);</div><div class="line"></div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s"</span>, outstr);</div><div class="line"></div><div class="line">    MPI_Finalize();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[zjshao@master 4-3-4]$ mpiexec -n 4 alltoall.x</div><div class="line">proc 0:</div><div class="line">sb[0] = 1, sb[1] = 2, sb[2] = 3, sb[3] = 4, </div><div class="line">rb[0] = 1, rb[1] = 5, rb[2] = 9, rb[3] = 13, </div><div class="line">proc 1:</div><div class="line">sb[0] = 5, sb[1] = 6, sb[2] = 7, sb[3] = 8, </div><div class="line">rb[0] = 2, rb[1] = 6, rb[2] = 10, rb[3] = 14, </div><div class="line">proc 2:</div><div class="line">sb[0] = 9, sb[1] = 10, sb[2] = 11, sb[3] = 12, </div><div class="line">rb[0] = 3, rb[1] = 7, rb[2] = 11, rb[3] = 15, </div><div class="line">proc 3:</div><div class="line">sb[0] = 13, sb[1] = 14, sb[2] = 15, sb[3] = 16, </div><div class="line">rb[0] = 4, rb[1] = 8, rb[2] = 12, rb[3] = 16, </div><div class="line">[zjshao@master 4-3-4]$</div></pre></td></tr></table></figure></p>
<h3 id="MPI-Scan"><a href="#MPI-Scan" class="headerlink" title="MPI_Scan"></a><code>MPI_Scan</code></h3><p>这个是个逐级执行规约操作，即进程i对进程0, 1, … i进行规约，还是看图会直观些：<br><img src="/assets/images/blog_img/2016-08-21-MPI集合通信：N-N/mpi_scan.png" alt=""></p>
<p>其他的没有什么要注意的参数也是规约操作的类似，直接上例子，操作过程如下图：</p>
<p><img src="/assets/images/blog_img/2016-08-21-MPI集合通信：N-N/scan_ex.jpg" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mpi.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> rank, nproc, sb, rb;</div><div class="line">    MPI_Comm comm = MPI_COMM_WORLD;</div><div class="line"></div><div class="line">    MPI_Init(&amp;argc, &amp;argv);</div><div class="line">    MPI_Comm_rank(comm, &amp;rank);</div><div class="line">    MPI_Comm_size(comm, &amp;nproc);</div><div class="line"></div><div class="line">    sb = rank + <span class="number">1</span>;</div><div class="line"></div><div class="line">    MPI_Scan(&amp;sb, &amp;rb, <span class="number">1</span>, MPI_INT, MPI_SUM, comm);</div><div class="line"></div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc: %d, sb = %d, rb = %d.\n"</span>, rank, sb, rb);</div><div class="line"></div><div class="line">    MPI_Finalize();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[zjshao@master 4-3-5]$ mpiexec -n 4 scan.x</div><div class="line">proc: 0, sb = 1, rb = 1.</div><div class="line">proc: 1, sb = 2, rb = 3.</div><div class="line">proc: 2, sb = 3, rb = 6.</div><div class="line">proc: 3, sb = 4, rb = 10.</div><div class="line">[zjshao@master 4-3-5]$</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MPI </tag>
            
            <tag> Parallel Computing </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MPI集合通信：N → 1]]></title>
      <url>http://pytlab.github.io/2016/08/19/MPI%E9%9B%86%E5%90%88%E9%80%9A%E4%BF%A1%EF%BC%9AN-1/</url>
      <content type="html"><![CDATA[<p>N -&gt; 1的集合通信这里只总结收集操作和规约操作。</p>
<h3 id="收集操作MPI-Gather"><a href="#收集操作MPI-Gather" class="headerlink" title="收集操作MPI_Gather"></a>收集操作<code>MPI_Gather</code></h3><p><code>MPI_Gather</code>是<code>MPI_Scatter</code>的逆操作，根进程从其他进程收集不同的消息一次放入自己的接收缓冲区中，接收数据的存放顺序与进程号相同。<br><a id="more"></a></p>
<p><img src="/assets/images/blog_img/2016-08-19-MPI集合通信：N-1/gather.png" alt=""></p>
<p>函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">MPI_Gather(<span class="keyword">void</span>* send_data,</div><div class="line">           <span class="keyword">int</span> send_count,</div><div class="line">           MPI_Datatype send_datatype,</div><div class="line">           <span class="keyword">void</span>* recv_data,</div><div class="line">           <span class="keyword">int</span> recv_count,</div><div class="line">           MPI_Datatype recv_datatype,</div><div class="line">           <span class="keyword">int</span> root,</div><div class="line">           MPI_Comm communicator)</div></pre></td></tr></table></figure></p>
<ul>
<li>在每个进程中都要调用，其中发送数据的地址和数据量以及数据类型每个进程都是相同的；</li>
<li>但是接收，只有root进程需要真正的设置接收缓冲区的地址以及接收数量<code>recv_count</code>，其他的进程可以开辟缓冲区但是并不会使用，这个时候可以在其他进程中调用此函数的时候想<code>recv_data</code>这里传递空指针<code>NULL</code>。</li>
<li>需要注意的是<code>recv_count</code>,这里并不是传接收数据的总量，而是从<strong>每个进程</strong>那里接收的数据的量。</li>
</ul>
<p>下面还是写个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mpi.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> rank, nproc;</div><div class="line">    <span class="keyword">int</span> root = <span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> sbuf[SIZE];</div><div class="line">    <span class="keyword">int</span> scnt = SIZE, rcnt = SIZE;</div><div class="line"></div><div class="line">    MPI_Init(&amp;argc, &amp;argv);</div><div class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);</div><div class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;nproc);</div><div class="line"></div><div class="line">    <span class="comment">// Fill the send buffer.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i)</div><div class="line">    &#123;</div><div class="line">        sbuf[i] = rank*SIZE + i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Allocate buffer for data receiving.</span></div><div class="line">    <span class="keyword">int</span> * rbuf = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(nproc*SIZE*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (rank == root)</div><div class="line">    &#123;</div><div class="line">        MPI_Gather(sbuf, scnt, MPI_INT, rbuf, rcnt, MPI_INT, root, MPI_COMM_WORLD);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        MPI_Gather(sbuf, scnt, MPI_INT, <span class="literal">NULL</span>, rcnt, MPI_INT, root, MPI_COMM_WORLD);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (rank == root)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"process %d, receive.\n"</span>, rank);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nproc*SIZE; ++i)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"rbuf[%d] = %d\n"</span>, i, rbuf[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    MPI_Finalize();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该程序会根据进程总数动态分配接收缓冲区大小，然后每个进程会将生成与自己进程号相同的数收集到root进程，这里我将进程号为2的进程设为根进程来收集数据。</p>
<p>过程如下图所示：<br><img src="/assets/images/blog_img/2016-08-19-MPI集合通信：N-1/gather_pattern.png" alt=""></p>
<p>执行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[zjshao@master 4-2-1]$ mpicc gather.c -std=c99 -o gather.x</div><div class="line">[zjshao@master 4-2-1]$ mpiexec -n 4 -host node01 gather.x</div><div class="line">process 2, receive.</div><div class="line">rbuf[0] = 0</div><div class="line">rbuf[1] = 1</div><div class="line">rbuf[2] = 2</div><div class="line">rbuf[3] = 3</div><div class="line">[zjshao@master 4-2-1]$</div></pre></td></tr></table></figure></p>
<h3 id="规约操作MPI-Reduce"><a href="#规约操作MPI-Reduce" class="headerlink" title="规约操作MPI_Reduce"></a>规约操作<code>MPI_Reduce</code></h3><p>看到reduce就应该很熟悉了才对，这个效果跟Python中的<code>reduce()</code>函数相同，将一系列数据进行规约处理，累加、累乘都属于这一范畴。<br><img src="/assets/images/blog_img/2016-08-19-MPI集合通信：N-1/reduce.png" alt=""></p>
<p>来看一下函数原型<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Reduce</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *sendbuf,</span></span></div><div class="line">               <span class="keyword">void</span> *recvbuf,</div><div class="line">               <span class="keyword">int</span> count,</div><div class="line">               MPI_Datatype datatype,</div><div class="line">               MPI_Op op,</div><div class="line">               <span class="keyword">int</span> root,</div><div class="line">               MPI_Comm comm)</div></pre></td></tr></table></figure></p>
<ul>
<li>同理，规约操作的接收缓冲区也只有根进程真正需要，可以在代码实现中进行判断从而在一定程度上节省内存。</li>
<li>接收的个数也是从每个进程中接收的数据量，并不是总量</li>
<li>这里的<code>MPI_Op</code>是一个规约操作，MPI内置定义了些常用的规约操作：<br>  <img src="/assets/images/blog_img/2016-08-19-MPI集合通信：N-1/reduce_tab.png" alt=""><br>  当然也可以自定义规约操作，这里我就不总结了，等以后需要的话我再单独去弄。</li>
</ul>
<p>下面我就写了个简单的例子来测试下规约操作，是对一个数组进行平方后求和的并行程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mpi.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> rank, nproc, namelen;</div><div class="line">    <span class="keyword">int</span> root = <span class="number">0</span>;</div><div class="line">    MPI_Comm comm = MPI_COMM_WORLD;</div><div class="line">    <span class="keyword">char</span> processor_name[MPI_MAX_PROCESSOR_NAME];</div><div class="line">    <span class="keyword">int</span> number, square, sum;</div><div class="line"></div><div class="line">    MPI_Init(&amp;argc, &amp;argv);</div><div class="line">    MPI_Comm_rank(comm, &amp;rank);</div><div class="line">    MPI_Comm_size(comm, &amp;nproc);</div><div class="line">    MPI_Get_processor_name(processor_name, &amp;namelen);</div><div class="line"></div><div class="line">    <span class="comment">// Data to be scattered.</span></div><div class="line">    <span class="keyword">int</span> * seq = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(nproc*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nproc; ++i)</div><div class="line">    &#123;</div><div class="line">        seq[i] = i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Scatter data to all processes.</span></div><div class="line">    MPI_Scatter(seq, <span class="number">1</span>, MPI_INT, &amp;number, <span class="number">1</span>, MPI_INT, root, comm);</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"process %d on %s receive %d from process %d\n"</span>,</div><div class="line">            rank, processor_name, number, root);</div><div class="line"></div><div class="line">    <span class="comment">// Calculate square.</span></div><div class="line">    square = number*number;</div><div class="line"></div><div class="line">    <span class="comment">// Reduce to root processor.</span></div><div class="line">    MPI_Reduce(&amp;square, &amp;sum, <span class="number">1</span>, MPI_INT, MPI_SUM, root, comm);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (rank == root)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc: %d sum = %d\n"</span>, rank, sum);</div><div class="line">        <span class="built_in">free</span>(seq);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    MPI_Finalize();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里将进程0设为根进程。</p>
<p>执行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[zjshao@master 4-2-2]$ mpiexec -n 4 -host node01 reduce.x</div><div class="line">process 1 on node01 receive 1 from process 0</div><div class="line">process 2 on node01 receive 2 from process 0</div><div class="line">process 3 on node01 receive 3 from process 0</div><div class="line">process 0 on node01 receive 0 from process 0</div><div class="line">proc: 0 sum = 14</div><div class="line">[zjshao@master 4-2-2]$</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MPI </tag>
            
            <tag> Parallel Computing </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MPI集合通信：1 → N]]></title>
      <url>http://pytlab.github.io/2016/08/18/MPI%E9%9B%86%E5%90%88%E9%80%9A%E4%BF%A1%EF%BC%9A1-N/</url>
      <content type="html"><![CDATA[<p>之前的点到点通信是两个进程之间的相互通信，而集合通信则是在一个通信子内<strong>所有</strong>进程参与的通信。</p>
<h3 id="广播操作MPI-Bcast"><a href="#广播操作MPI-Bcast" class="headerlink" title="广播操作MPI_Bcast"></a>广播操作<code>MPI_Bcast</code></h3><p>广播操作就是一个进程将相同的数据发送到同通信子中的其他进程中，它的一个重要通途就是将同一份输入数据发送给不同的进程方便进行进一步的并行计算。<br><a id="more"></a><br><img src="/assets/images/blog_img/2016-08-18-MPI集合通信：1-N/broadcast_pattern.png" alt=""></p>
<p>自己顺便也做了张图：<br><img src="/assets/images/blog_img/2016-08-18-MPI集合通信：1-N/broadcast.png" alt=""></p>
<p>下面是个广播操作的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mpi.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> rank, nproc, value;</div><div class="line"></div><div class="line">    MPI_Init(&amp;argc, &amp;argv);</div><div class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);</div><div class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;nproc);</div><div class="line"></div><div class="line">    <span class="keyword">do</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (rank == <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Please enter a value, -1 means finish:\n"</span>);</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;value);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        MPI_Bcast(&amp;value, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, MPI_COMM_WORLD);</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Process %d got %d\n"</span>, rank, value);</div><div class="line">    &#125;<span class="keyword">while</span>(value &gt;= <span class="number">0</span>);</div><div class="line"></div><div class="line">    MPI_Finalize();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">[zjshao@master 4-1-1]$ mpicc bcast.c -o bcast.x</div><div class="line">[zjshao@master 4-1-1]$ mpiexec -n 4 -host node01 bcast.x</div><div class="line">Please enter a value, -1 means finish:</div><div class="line">6</div><div class="line">Process 0 got 6</div><div class="line">Please enter a value, -1 means finish:</div><div class="line">Process 1 got 6</div><div class="line">Process 2 got 6</div><div class="line">Process 3 got 6</div><div class="line">7</div><div class="line">Process 0 got 7</div><div class="line">Please enter a value, -1 means finish:</div><div class="line">Process 1 got 7</div><div class="line">Process 2 got 7</div><div class="line">Process 3 got 7</div><div class="line">-1</div><div class="line">Process 0 got -1</div><div class="line">Process 1 got -1</div><div class="line">Process 2 got -1</div><div class="line">Process 3 got -1</div><div class="line">[zjshao@master 4-1-1]</div></pre></td></tr></table></figure></p>
<p>可见广播操作所有的进程都要执行<code>MPI_Bcast()</code>函数，但是执行的操作却不同。跟进程通过调用<code>MPI_Bcast()</code>将数据的副本发送出去，其他进程调用<code>MPI_Bcast()</code>则启动接收操作，将数据数组填满。<br>通过第一个输入可知道，在根进程阻塞的时候，其他的进程执行到<code>MPI_Bcast</code>也阻塞来等待跟进程发来的数据。</p>
<h3 id="发散操作MPI-Scatter"><a href="#发散操作MPI-Scatter" class="headerlink" title="发散操作MPI_Scatter"></a>发散操作<code>MPI_Scatter</code></h3><p>与广播操作发送相同的数据到其他进程不同，发散操作则是将一个数组进行分散然后将不同的部分分发到其他进程中。如下图：<br><img src="/assets/images/blog_img/2016-08-18-MPI集合通信：1-N/scatter_pattern.png" alt=""></p>
<p>先看看发散函数的函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">MPI_Scatter(<span class="keyword">void</span>* send_data,</div><div class="line">            <span class="keyword">int</span> send_count,</div><div class="line">            MPI_Datatype send_datatype,</div><div class="line">            <span class="keyword">void</span>* recv_data,</div><div class="line">            <span class="keyword">int</span> recv_count,</div><div class="line">            MPI_Datatype recv_datatype,</div><div class="line">            <span class="keyword">int</span> root,</div><div class="line">            MPI_Comm communicator)</div></pre></td></tr></table></figure></p>
<p><code>send_data</code>是在根进程中的要发送数据的首地址。<br>第二个和第三个参数则描述了如何向其他进程发送数据，例如如果<code>send_datatype</code>是<code>MPI_INT</code>则<code>send_count</code>为2，就将前两个int数据发送到第0个进程，以此类推。。。<br><img src="/assets/images/blog_img/2016-08-18-MPI集合通信：1-N/scatter.png" alt=""></p>
<p>下面直接上代码好了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mpi.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 4</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> rank, nproc, scnt, rcnt, src;</div><div class="line">    <span class="keyword">float</span> sb[SIZE][SIZE] = &#123;</div><div class="line">        &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>&#125;,</div><div class="line">        &#123;<span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>&#125;,</div><div class="line">        &#123;<span class="number">9.0</span>, <span class="number">10.0</span>, <span class="number">11.0</span>, <span class="number">12.0</span>&#125;,</div><div class="line">        &#123;<span class="number">13.0</span>, <span class="number">14.0</span>, <span class="number">15.0</span>, <span class="number">16.0</span>&#125;,</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">float</span> rb[SIZE];</div><div class="line">    MPI_Comm comm = MPI_COMM_WORLD;</div><div class="line"></div><div class="line">    MPI_Init(&amp;argc, &amp;argv);</div><div class="line">    MPI_Comm_rank(comm, &amp;rank);</div><div class="line">    MPI_Comm_size(comm, &amp;nproc);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (nproc == SIZE)</div><div class="line">    &#123;</div><div class="line">        src = <span class="number">1</span>;</div><div class="line">        scnt = SIZE;</div><div class="line">        rcnt = SIZE;</div><div class="line"></div><div class="line">        MPI_Scatter(sb, scnt, MPI_FLOAT,</div><div class="line">                    rb, rcnt, MPI_FLOAT,</div><div class="line">                    src, comm);</div><div class="line">                    rb, rcnt, MPI_FLOAT,</div><div class="line">                    src, comm);</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"rank = %d Results: %f %f %f %f\n"</span>, rank, rb[<span class="number">0</span>], rb[<span class="number">1</span>], rb[<span class="number">2</span>], rb[<span class="number">3</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Must specify %d processors. Terminating.\n"</span>, SIZE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    MPI_Finalize();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[zjshao@master 4-1-2]$ mpiexec -n 4 -host node01 scatter.x</div><div class="line">rank = 1 Results: 5.000000 6.000000 7.000000 8.000000</div><div class="line">rank = 2 Results: 9.000000 10.000000 11.000000 12.000000</div><div class="line">rank = 3 Results: 13.000000 14.000000 15.000000 16.000000</div><div class="line">rank = 0 Results: 1.000000 2.000000 3.000000 4.000000</div><div class="line">[zjshao@master 4-1-2]$</div></pre></td></tr></table></figure></p>
<p>在上面的例子中<code>send_count</code>=4，也就是说进程1将<code>sb</code>中的前4个float发送给进程0，5~8发送给自己，以此类推。。。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MPI </tag>
            
            <tag> Parallel Computing </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[点到点通信总结]]></title>
      <url>http://pytlab.github.io/2016/08/18/%E7%82%B9%E5%88%B0%E7%82%B9%E9%80%9A%E4%BF%A1%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h3 id="通信模式总结"><a href="#通信模式总结" class="headerlink" title="通信模式总结"></a>通信模式总结</h3><p>理解各种通信过程的行为，关键是弄清楚各个模式<strong>对缓冲</strong>使用的方式。各个模式使用缓冲的特点总结：</p>
<ol>
<li>标准<code>MPI_Send</code>实际利用了MPI环境提供的默认缓冲区。</li>
<li>缓冲通信<code>MPI_Bsend</code>相当于将MPI环境提供的buffer放在用户空间进行管理，相当于用户手动开辟空间作为通信的缓冲区。</li>
<li>就绪通信<code>MPI_Rsend</code>不需要缓冲区，但是发送动作默认接受早已就绪，发送不能提前等待，否则报错。</li>
<li>同步通信<code>MPI_Ssend</code>与就绪通信类似，同样不需要缓冲区，但是发送动作是可以等待的，接受没有就绪就继续等待，不会报错。</li>
</ol>
<p>异步（非阻塞）通信的工作原理类似，只不过可以将其理解为MPI又单独启动了一个线程在后台进行真正的通信操作，通过<code>MPI_Waitxxx</code>和<code>MPI_Testxxx</code>等来进行检测是否通信的线程完成通信。</p>
<a id="more"></a>
<h3 id="关于预防死锁"><a href="#关于预防死锁" class="headerlink" title="关于预防死锁"></a>关于预防死锁</h3><p>造成死锁的原因有很多，最典型的就是缓冲区争夺导致的死锁，标准通信中使用MPI环境提供的默认缓冲区，当发送/接受的数据量大于缓冲区大小时，就需要每个进程等待对方进程启动接受动作然后直接将数据发送（不通过缓冲区），但是这个时候如果两个进程都在等待对方接受，就会造成死锁。</p>
<p>下面是一段标准通信的过程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mpi.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">//#define BUFSIZE 65530</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 5530</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> myid, nproc, other;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> sb[BUFSIZE];</div><div class="line">    <span class="keyword">int</span> rb[BUFSIZE];</div><div class="line">    MPI_Status status;</div><div class="line"></div><div class="line">    MPI_Init(&amp;argc, &amp;argv);</div><div class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;myid);</div><div class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;nproc);</div><div class="line"></div><div class="line">    <span class="comment">// Fill send buffer.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BUFSIZE; ++i)</div><div class="line">    &#123;</div><div class="line">        sb[i] = myid + i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    other = (myid == <span class="number">0</span>)?<span class="number">1</span>:<span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"process: %d of %d trying sending...\n"</span>, myid, nproc);</div><div class="line">    MPI_Send(sb, BUFSIZE, MPI_INT, other, <span class="number">1</span>, MPI_COMM_WORLD);</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"process: %d of %d trying receiving...\n"</span>, myid, nproc);</div><div class="line">    MPI_Recv(rb, BUFSIZE, MPI_INT, other, <span class="number">1</span>, MPI_COMM_WORLD, &amp;status);</div><div class="line"></div><div class="line">    MPI_Finalize();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当我发送的数据较小时，的执行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[zjshao@master 2-4]$ mpicc -std=c99 deadlock.c -o deadlock.x</div><div class="line">[zjshao@master 2-4]$ mpiexec -n 2 -host node01 deadlock.x</div><div class="line">process: 1 of 2 trying sending...</div><div class="line">process: 0 of 2 trying sending...</div><div class="line">process: 1 of 2 trying receiving...</div><div class="line">process: 0 of 2 trying receiving...</div></pre></td></tr></table></figure></p>
<p>但是当我们增大发送数据的大小时，则会出现死锁，两个进程互相等待对方的接收，但是却一直卡在发送过程，造成死锁。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[zjshao@master 2-4]$ mpiexec -n 2 -host node01 deadlock.x</div><div class="line">process: 0 of 2 trying sending...</div><div class="line">process: 1 of 2 trying sending...</div><div class="line">[mpiexec@master.cluster] Sending Ctrl-C to processes as requested</div><div class="line">[mpiexec@master.cluster] Press Ctrl-C again to force abort</div></pre></td></tr></table></figure></p>
<h3 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h3><ol>
<li>确保一次发送的数据量小于环境所能提供的缓冲区的容量</li>
<li>利用MPI环境消息发送接手的顺序性约束，调整语句的执行顺序，例如让进程0先发送再接收，进程1先接收，再发送。</li>
<li>使用缓冲发送，这样发送就会立即返回，不会造成死锁。</li>
<li>使用非阻塞通信，也会立即返回。</li>
<li>利用组合发送接收，对组合的发送接收操作，可以理解MPI环境对通信的匹配能够按需进行，即阻塞到Send时则对方的Recv就会前来匹配，反之亦然。</li>
</ol>
<h3 id="阻塞与非阻塞、同步与异步"><a href="#阻塞与非阻塞、同步与异步" class="headerlink" title="阻塞与非阻塞、同步与异步"></a>阻塞与非阻塞、同步与异步</h3><h4 id="阻塞操作"><a href="#阻塞操作" class="headerlink" title="阻塞操作"></a>阻塞操作</h4><ul>
<li>阻塞的发送操作，其返回就意味着发送缓冲区可以被再次使用，而不会影响接收端的接收结果，但这并不意味着接收端已经完成了接收（因为数据可能仍保存在系统缓冲区内）</li>
<li>阻塞的发送操作可以同步方式工作，此时发送和接收进程之间需要实施一个握手协议来确保发送动作的安全。</li>
<li>阻塞的发送操作也可以异步方式进行，即缓冲通信，需要系统的缓冲区来进行消息缓存。</li>
<li>阻塞的接收操作仅当消息接收完成才返回。</li>
</ul>
<h4 id="非阻塞操作"><a href="#非阻塞操作" class="headerlink" title="非阻塞操作"></a>非阻塞操作</h4><ul>
<li>非阻塞仅对MPI环境提出一个要求==在可能的时候启动通信。用户并没有办法预测这个启动具体发生在什么时候。</li>
<li>在通过某种手段确定MPI环境确实执行了通信之前，修改发送缓冲区中的数据都是不安全的，即可能导致接收方接收到修改过的数据。</li>
<li>非阻塞通信的主要目的之一是把计算和通信重叠起来，从而改进并行效率。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MPI </tag>
            
            <tag> Parallel Computing </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在VASPy中使用延迟初始化]]></title>
      <url>http://pytlab.github.io/2016/08/09/%E5%9C%A8VASPy%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>由于之前版本的VASPy是基于课题组修改过的VASP版本所写的，其中OUTCAR中的一些受力信息是标准VASP代码中不会输出的，但是当时为了省事我就直接拿课题组VASP输出的OUTCAR中的信息写了VASPy中的<code>OutCar</code>类。。。</p>
<p>为了能让VASPy具有更好的通用性，今天特地重构了<code>OutCar</code>这个类使其能够操作标准VASP的OUTCAR文件。</p>
<p>具体重构后的OutCar类代码的链接：<a href="https://github.com/PytLab/VASPy/blob/master/vaspy/iter.py" target="_blank" rel="external"><span class="fa fa-github"></span> VASPy/iter.py at master · PytLab/VASPy</a></p>
<p>由于OUTCAR是VASP所有输出的文件，自然会比较大，因此要操作这个文件就要特别的处理。</p>
<a id="more"></a>
<h3 id="使用生成器获取迭代数据"><a href="#使用生成器获取迭代数据" class="headerlink" title="使用生成器获取迭代数据"></a>使用生成器获取迭代数据</h3><p>直接读取OUTCAR整个文件必然会占用很多内存，即使不读取整个文件，要把每步迭代的信息都保存的数组中也同样会占用很多的内存。</p>
<p>一个解决的好办法就是使用迭代器来减小内存的开销。而且针对不同数据获取不同的迭代器，比如现在针对OUTCAR中的原子受力数据，我就写了一个<code>force_iterator</code>函数来获取受力信息的迭代器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@property</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">force_iterator</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Return a generator yield ionic_step, coordinates, forces on atoms.</div><div class="line"></div><div class="line">    NOTE: ionic step starts from 1 **NOT 0**.</div><div class="line">    """</div><div class="line">    <span class="keyword">with</span> open(self.filename, <span class="string">"r"</span>) <span class="keyword">as</span> f:</div><div class="line">        ion_step = <span class="number">0</span></div><div class="line"></div><div class="line">        <span class="comment"># Force data collection flags.</span></div><div class="line">        collect_begin = <span class="keyword">False</span></div><div class="line">        collecting = <span class="keyword">False</span></div><div class="line"></div><div class="line">        <span class="comment"># Collect force data for each ionic step and yield.</span></div><div class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> collect_begin:</div><div class="line">                <span class="keyword">if</span> self.force_regex.match(line):</div><div class="line">                    collect_begin = <span class="keyword">True</span></div><div class="line">                    ion_step += <span class="number">1</span></div><div class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> collecting:</div><div class="line">                <span class="keyword">if</span> <span class="string">"-"</span>*<span class="number">6</span> <span class="keyword">in</span> line:</div><div class="line">                    collecting = <span class="keyword">True</span></div><div class="line">                    coordinates = []</div><div class="line">                    forces = []</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">if</span> <span class="string">"-"</span>*<span class="number">6</span> <span class="keyword">in</span> line:</div><div class="line">                    collecting = <span class="keyword">False</span></div><div class="line">                    collect_begin = <span class="keyword">False</span></div><div class="line">                    <span class="keyword">yield</span> ion_step, coordinates, forces</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    x, y, z, fx, fy, fz = line2list(line)</div><div class="line">                    coordinates.append([x, y, z])</div><div class="line">                    forces.append([fx, fy, fz])</div></pre></td></tr></table></figure>
<h3 id="使用延迟初始化-lazy-property"><a href="#使用延迟初始化-lazy-property" class="headerlink" title="使用延迟初始化(lazy property)"></a>使用延迟初始化(lazy property)</h3><p>为了给<code>OutCar</code>实例初始化属性，必须要考虑OUTCAR的大体积，如果在构造实例的时候把所有的属性全部初始化同样会占用大量的内存，为了在内存和CPU进行平衡，我决定使用延迟初始化来处理<code>OutCar</code>类的属性初始化。</p>
<p>使用延迟初始化一般有两种方法：</p>
<ol>
<li><p><strong>使用描述符</strong></p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">lazy</span><span class="params">(object)</span>:</span> </div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span> </div><div class="line">    self.func = func </div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, cls)</span>:</span> </div><div class="line">    val = self.func(instance) </div><div class="line">    setattr(instance, self.func.__name__, val) </div><div class="line">    <span class="keyword">return</span> val </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span><span class="params">(object)</span>:</span> </div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, radius)</span>:</span> </div><div class="line">    self.radius = radius </div><div class="line">  </div><div class="line"><span class="meta">  @lazy</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">area</span><span class="params">(self)</span>:</span> </div><div class="line">    <span class="keyword">print</span> <span class="string">'evalute'</span></div><div class="line">    <span class="keyword">return</span> <span class="number">3.14</span> * self.radius ** <span class="number">2</span></div><div class="line">  </div><div class="line">c = Circle(<span class="number">4</span>) </div><div class="line"><span class="keyword">print</span> c.radius </div><div class="line"><span class="keyword">print</span> c.area </div><div class="line"><span class="keyword">print</span> c.area </div><div class="line"><span class="keyword">print</span> c.area</div></pre></td></tr></table></figure>
</li>
<li><p><strong>使用装饰器，并在装饰器中使用默认的描述符</strong></p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazy_property</span><span class="params">(func)</span>:</span></div><div class="line">    attr_name = <span class="string">"_lazy_"</span> + func.__name__</div><div class="line"> </div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_lazy_property</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, attr_name):</div><div class="line">            setattr(self, attr_name, func(self))</div><div class="line">        <span class="keyword">return</span> getattr(self, attr_name)</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> _lazy_property</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span><span class="params">(object)</span>:</span> </div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, radius)</span>:</span> </div><div class="line">    self.radius = radius </div><div class="line">  </div><div class="line"><span class="meta">  @lazy_property</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">area</span><span class="params">(self)</span>:</span> </div><div class="line">    <span class="keyword">print</span> <span class="string">'evalute'</span></div><div class="line">    <span class="keyword">return</span> <span class="number">3.14</span> * self.radius ** <span class="number">2</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>这里我直接定义了新的描述符来实现延迟初始化，方法很简单，就是定义了一个非描述符(即只有<code>__get__()</code>方法的描述符)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyProperty</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Descriptor for lazy property.</div><div class="line">    """</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></div><div class="line">        self.func = func</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></div><div class="line">        val = self.func(instance)</div><div class="line">        setattr(instance, self.func.__name__, val)</div><div class="line">        <span class="keyword">return</span> val</div></pre></td></tr></table></figure>
<p>这样就实现了<code>OutCar</code>类的延迟初始化。</p>
]]></content>
      
        <categories>
            
            <category> 代码作品 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> VASPy </tag>
            
            <tag> lazy property </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MPI学习--可重复的非阻塞标准通信]]></title>
      <url>http://pytlab.github.io/2016/08/04/MPI%E5%AD%A6%E4%B9%A0-%E5%8F%AF%E9%87%8D%E5%A4%8D%E7%9A%84%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A0%87%E5%87%86%E9%80%9A%E4%BF%A1/</url>
      <content type="html"><![CDATA[<p>今天开始学习可重复(persistent)的非阻塞通信。</p>
<p>实际计算环境中，常在一个内部循环中重复使用相同的数据结构来传递不同的数据，这时候将数据结构与发送/接受动作绑定可以提高程序的效率。</p>
<p>可重复通信大致是</p>
<ol>
<li>先使用<code>MPI_Send_init()</code>和<code>MPI_Recv_init()</code>接口注册发送和接受动作，实际并不执行</li>
<li>在进程的其他位置通过重复通信控制函数，如<code>MPI_Start()</code>，来控制真正执行的时机</li>
<li>使用<code>MPI_Request_free()</code>来释放与重复非阻塞通信相关的通信对象并注销注册的重复非阻塞通信。<code>MPI_Request_free()</code>可在注册之后的任何地点调用，但仅当没有处在消息传递状态时，才可实际释放通信对象。</li>
</ol>
<h3 id="可重复的非阻塞标准通信"><a href="#可重复的非阻塞标准通信" class="headerlink" title="可重复的非阻塞标准通信"></a>可重复的非阻塞标准通信</h3><p>本篇主要总结可重复的非阻塞标准通信。</p>
<a id="more"></a>
<hr>
<p>第一个例子，主要是<strong>可重复非阻塞发送</strong>与<strong>不可重复的非阻塞接受</strong>匹配。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mpi.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 5</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></div><div class="line">&#123;</div><div class="line">    MPI_Request req;</div><div class="line">    MPI_Status stat;</div><div class="line">    <span class="keyword">int</span> buf[BUFSIZE];</div><div class="line">    <span class="keyword">char</span> pstr[BUFSIZE*(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) + <span class="number">8</span>) + <span class="number">50</span>];</div><div class="line">    <span class="keyword">int</span> tag = <span class="number">123</span>;</div><div class="line">    <span class="keyword">int</span> dest = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> rank, nproc, i, j;</div><div class="line">    </div><div class="line">    MPI_Init(&amp;argc, &amp;argv);</div><div class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);</div><div class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;nproc);</div><div class="line">    </div><div class="line">    <span class="comment">// Fill data to be sent.</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BUFSIZE; ++i)</div><div class="line">    &#123;</div><div class="line">        buf[i] = BUFSIZE*rank + i;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// Create a persistent send request.</span></div><div class="line">    MPI_Send_init(buf, BUFSIZE, MPI_INT, dest, tag, MPI_COMM_WORLD, &amp;req);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (rank == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> rbuf[BUFSIZE*nproc];</div><div class="line">        MPI_Request * rr = (MPI_Request *)<span class="built_in">malloc</span>(nproc*<span class="keyword">sizeof</span>(MPI_Request));</div><div class="line">    </div><div class="line">        Receive data from other processes.</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nproc; ++i)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc: %d before Irecv...\n"</span>, rank);</div><div class="line">            MPI_Irecv(rbuf + i*BUFSIZE, BUFSIZE, MPI_INT, i, tag, MPI_COMM_WORLD, rr + i);</div><div class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc: %d after Irecv...\n"</span>, rank);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// Send data.</span></div><div class="line">        MPI_Start(&amp;req);</div><div class="line">        </div><div class="line">        <span class="comment">// Wait send done.</span></div><div class="line">        MPI_Wait(&amp;req, &amp;stat);</div><div class="line">        </div><div class="line">        <span class="comment">// Wait receive done.</span></div><div class="line">        MPI_Waitall(nproc, rr, MPI_STATUS_IGNORE);</div><div class="line">        </div><div class="line">        <span class="comment">// Info output.</span></div><div class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nproc; ++i)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">sprintf</span>(pstr, <span class="string">"proc: %d received messages from %d\n"</span>, rank, i);</div><div class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BUFSIZE<span class="number">-1</span>; ++j)</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">sprintf</span>(pstr, <span class="string">"%s rbuf[%d]=%d,"</span>, pstr, i*BUFSIZE+j, rbuf[i*BUFSIZE+j]);</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">sprintf</span>(pstr, <span class="string">"%s rbuf[%d]=%d\n"</span>, pstr, i*BUFSIZE+j, rbuf[i*BUFSIZE+j]);</div><div class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s"</span>, pstr);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">free</span>(rr);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// If not master process.</span></div><div class="line">        MPI_Start(&amp;req);</div><div class="line">        MPI_Wait(&amp;req, &amp;stat);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    MPI_Request_free(&amp;req);</div><div class="line">    </div><div class="line">    MPI_Finalize();</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码的大致过程是每个进程（包括主进程）都会向主进程（进程号为0）的进程发送数据，主进程通过不可重复的非阻塞接受<code>MPI_Irecv()</code>进行接受信息。<br>其中发送数据的进程只负责发送<code>BUFSIZE</code>的数组中的数据，主进程使用循环来将接收到的数据放到同一个大数组<code>rbuf</code>中，在等待非阻塞接受完成时，使用了<code>MPI_Waitall()</code>来代替通过循环方式的通信完成。<br>执行的结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[zjshao@master 2-2-3-1]$ mpiexec -n 4 -host node01 send_init_irecv.x</div><div class="line">proc: 0 before Irecv...</div><div class="line">proc: 0 after Irecv...</div><div class="line">proc: 0 before Irecv...</div><div class="line">proc: 0 after Irecv...</div><div class="line">proc: 0 before Irecv...</div><div class="line">proc: 0 after Irecv...</div><div class="line">proc: 0 before Irecv...</div><div class="line">proc: 0 after Irecv...</div><div class="line">proc: 0 received messages from 0</div><div class="line"> rbuf[0]=0, rbuf[1]=1, rbuf[2]=2, rbuf[3]=3, rbuf[4]=4</div><div class="line">proc: 0 received messages from 1</div><div class="line"> rbuf[5]=5, rbuf[6]=6, rbuf[7]=7, rbuf[8]=8, rbuf[9]=9</div><div class="line">proc: 0 received messages from 2</div><div class="line"> rbuf[10]=10, rbuf[11]=11, rbuf[12]=12, rbuf[13]=13, rbuf[14]=14</div><div class="line">proc: 0 received messages from 3</div><div class="line"> rbuf[15]=15, rbuf[16]=16, rbuf[17]=17, rbuf[18]=18, rbuf[19]=19</div><div class="line">[zjshao@master 2-2-3-1]$</div></pre></td></tr></table></figure></p>
<hr>
<p>可重复的阻塞接收<code>MPI_Recv_init()</code>与不可重复的非阻塞发送<code>MPI_Isend()</code>相匹配<br>所谓重复和不重复与是否阻塞没有关系，而是看<strong>是否重复利用同一个数据结构</strong>来发送和接收不同的数据。</p>
<p>代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></div><div class="line">&#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (rank == <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		MPI_Request rreq;</div><div class="line">	    <span class="keyword">int</span> rbuf[BUFSIZE];</div><div class="line"></div><div class="line">		<span class="comment">// Create a persistent receive request.</span></div><div class="line">		MPI_Recv_init(rbuf, BUFSIZE, MPI_INT,</div><div class="line">				      MPI_ANY_SOURCE, tag,</div><div class="line">					  MPI_COMM_WORLD, &amp;rreq);</div><div class="line"></div><div class="line">		<span class="comment">// Send data to master process.</span></div><div class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc: %d before Isend...\n"</span>, rank);</div><div class="line">		MPI_Isend(buf, BUFSIZE, MPI_INT, <span class="number">0</span>, tag, MPI_COMM_WORLD, &amp;sreq);</div><div class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc: %d after Isend...\n"</span>, rank);</div><div class="line"></div><div class="line">		<span class="comment">// Start data receiving.</span></div><div class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nproc; ++i)</div><div class="line">		&#123;</div><div class="line">		    MPI_Start(&amp;rreq);</div><div class="line">			MPI_Wait(&amp;rreq, &amp;stat);</div><div class="line"></div><div class="line">			<span class="built_in">sprintf</span>(pstr, <span class="string">"proc: %d received messages from: %d\n"</span>,</div><div class="line">					rank, stat.MPI_SOURCE);</div><div class="line">			<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BUFSIZE<span class="number">-1</span>; ++j)</div><div class="line">			&#123;</div><div class="line">			    <span class="built_in">sprintf</span>(pstr, <span class="string">"%s rbuf[%d]=%d,"</span>, pstr, j, rbuf[j]);</div><div class="line">			&#125;</div><div class="line">			<span class="built_in">sprintf</span>(pstr, <span class="string">"%s rbuf[%d]=%d\n"</span>, pstr, j, rbuf[j]);</div><div class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s"</span>, pstr);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		MPI_Request_free(&amp;rreq);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		<span class="comment">// Send data to master process.</span></div><div class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc: %d before Isend...\n"</span>, rank);</div><div class="line">		MPI_Isend(buf, BUFSIZE, MPI_INT, <span class="number">0</span>, tag, MPI_COMM_WORLD, &amp;sreq);</div><div class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc: %d after Isend...\n"</span>, rank);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	MPI_Wait(&amp;sreq, &amp;stat);</div><div class="line"></div><div class="line">	MPI_Finalize();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[zjshao@master 2-2-3-1]$ mpiexec -n 4 -host node01 recv_init_isend.x</div><div class="line">proc: 1 before Isend...</div><div class="line">proc: 2 before Isend...</div><div class="line">proc: 2 after Isend...</div><div class="line">proc: 3 before Isend...</div><div class="line">proc: 3 after Isend...</div><div class="line">proc: 0 before Isend...</div><div class="line">proc: 1 after Isend...</div><div class="line">proc: 0 after Isend...</div><div class="line">proc: 0 received messages from: 0</div><div class="line"> rbuf[0]=0, rbuf[1]=1, rbuf[2]=2, rbuf[3]=3, rbuf[4]=4</div><div class="line">proc: 0 received messages from: 2</div><div class="line"> rbuf[0]=10, rbuf[1]=11, rbuf[2]=12, rbuf[3]=13, rbuf[4]=14</div><div class="line">proc: 0 received messages from: 3</div><div class="line"> rbuf[0]=15, rbuf[1]=16, rbuf[2]=17, rbuf[3]=18, rbuf[4]=19</div><div class="line">proc: 0 received messages from: 1</div><div class="line"> rbuf[0]=5, rbuf[1]=6, rbuf[2]=7, rbuf[3]=8, rbuf[4]=9</div><div class="line">[zjshao@master 2-2-3-1]$</div></pre></td></tr></table></figure></p>
<p>可见，使用可重复的非阻塞接收，接收的顺序并不确定，哪个进程的信息先到达先接收哪个进程的信息。<strong>后接收的信息会覆盖先接收的数据</strong>。<br>实际上可重复的非阻塞发送可以与任何接收动作相匹配，可重复的非阻塞可与任何发送动作相匹配。</p>
<hr>
<p>下面的代码是将<strong>可重复的阻塞接收</strong>动作<code>MPI_Recv()</code>与<strong>可重复的非阻塞发送</strong>动作<code>MPI_Send_init()</code>相匹配。<br>主进程不再向自己发送数据，而是其他的进程负责向主进程发送数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mpi.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 5</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RECEIVER 0</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></div><div class="line">&#123;</div><div class="line">	MPI_Request sreq;</div><div class="line">	MPI_Status stat;</div><div class="line">	<span class="keyword">int</span> buf[BUFSIZE];</div><div class="line">	<span class="keyword">char</span> pstr[BUFSIZE*(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) + <span class="number">8</span>) + <span class="number">50</span>];</div><div class="line">	<span class="keyword">int</span> tag = <span class="number">123</span>;</div><div class="line">	<span class="keyword">int</span> dest = <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> rank, nproc, i, j;</div><div class="line"></div><div class="line">	MPI_Init(&amp;argc, &amp;argv);</div><div class="line">	MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);</div><div class="line">	MPI_Comm_size(MPI_COMM_WORLD, &amp;nproc);</div><div class="line"></div><div class="line">	<span class="comment">// Fill data to be sent.</span></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BUFSIZE; ++i)</div><div class="line">	&#123;</div><div class="line">	    buf[i] = BUFSIZE*rank + i;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (rank != RECEIVER)</div><div class="line">	&#123;</div><div class="line">	    MPI_Send_init(buf, BUFSIZE, MPI_INT, RECEIVER, tag, MPI_COMM_WORLD, &amp;sreq);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (rank == RECEIVER)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> rbuf[BUFSIZE];</div><div class="line"></div><div class="line">	    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nproc<span class="number">-1</span>; ++i)</div><div class="line">		&#123;</div><div class="line">		    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc: %d before MPI_Recv()...\n"</span>, rank);   </div><div class="line">			MPI_Recv(rbuf, BUFSIZE, MPI_INT, MPI_ANY_SOURCE, tag, MPI_COMM_WORLD, &amp;stat);</div><div class="line">		    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc: %d after MPI_Recv()...\n"</span>, rank);   </div><div class="line"></div><div class="line">			<span class="built_in">sprintf</span>(pstr, <span class="string">"proc: %d received message from proc %d...\n"</span>, rank, stat.MPI_SOURCE);</div><div class="line">			<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BUFSIZE<span class="number">-1</span>; ++j)</div><div class="line">			&#123;</div><div class="line">			    <span class="built_in">sprintf</span>(pstr, <span class="string">"%s rbuf[%d]=%d,"</span>, pstr, j, rbuf[j]);</div><div class="line">			&#125;</div><div class="line">			<span class="built_in">sprintf</span>(pstr, <span class="string">"%s rbuf[%d]=%d\n"</span>, pstr, j, rbuf[j]);</div><div class="line"></div><div class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s"</span>, pstr);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">	    MPI_Start(&amp;sreq);</div><div class="line"></div><div class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc: %d send started...\n"</span>, rank);</div><div class="line">		MPI_Wait(&amp;sreq, &amp;stat);</div><div class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc: %d send finished...\n"</span>, rank);</div><div class="line"></div><div class="line">		MPI_Request_free(&amp;sreq);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	MPI_Finalize();</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">[zjshao@master 2-2-3-1]$ mpiexec -n 4 -host node01 send_init_recv.x</div><div class="line">proc: 0 before MPI_Recv()...</div><div class="line">proc: 1 send started...</div><div class="line">proc: 1 send finished...</div><div class="line">proc: 3 send started...</div><div class="line">proc: 3 send finished...</div><div class="line">proc: 0 after MPI_Recv()...</div><div class="line">proc: 0 received message from proc 2...</div><div class="line"> rbuf[0]=10, rbuf[1]=11, rbuf[2]=12, rbuf[3]=13, rbuf[4]=14</div><div class="line">proc: 0 before MPI_Recv()...</div><div class="line">proc: 0 after MPI_Recv()...</div><div class="line">proc: 0 received message from proc 3...</div><div class="line"> rbuf[0]=15, rbuf[1]=16, rbuf[2]=17, rbuf[3]=18, rbuf[4]=19</div><div class="line">proc: 0 before MPI_Recv()...</div><div class="line">proc: 0 after MPI_Recv()...</div><div class="line">proc: 2 send started...</div><div class="line">proc: 2 send finished...</div><div class="line">proc: 0 received message from proc 1...</div><div class="line"> rbuf[0]=5, rbuf[1]=6, rbuf[2]=7, rbuf[3]=8, rbuf[4]=9</div><div class="line">[zjshao@master 2-2-3-1]$</div></pre></td></tr></table></figure></p>
<p>可见可以正常运行，但是如果我把<code>BUFSIZE</code>增大会有死锁的危险，例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 5000000</span></div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>再次编译运行:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[zjshao@master 2-2-3-1]$ mpiexec -n 4 -host node01 test.x</div><div class="line">proc: 1 send started...</div><div class="line">proc: 2 send started...</div><div class="line">proc: 0 before MPI_Recv()...</div><div class="line">proc: 3 send started...</div><div class="line">proc: 1 send finished...</div><div class="line">proc: 0 after MPI_Recv()...</div><div class="line">[mpiexec@master.cluster] Sending Ctrl-C to processes as requested</div><div class="line">[mpiexec@master.cluster] Press Ctrl-C again to force abort</div><div class="line">[zjshao@master 2-2-3-1]$</div></pre></td></tr></table></figure></p>
<p>为什么会出现上面死锁的情况?<br>原因是我们使用了阻塞的接收操作,而且进程0以此药从其他进程接收,因此需借助MPI环境提供的缓冲机制进行数据接收，而MPI提供的默认缓冲区大小是有限制的，当超过这个之后，发送端就要与接收动作同步，也就是说顺序执行，接收动作需按顺序从进程1，2…接收数据，但是如果当进程2的数据先于进程1的数据到达缓冲区，接收数据就无法完成接收，造成死锁。</p>
<hr>
<p>可重复的非阻塞发送<code>MPI_Send_init()</code>和不可重复的非阻塞发送<code>MPI_Recv_init()</code>相匹配。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mpi.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 5</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RECEIVER 0</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></div><div class="line">&#123;</div><div class="line">	MPI_Request sreq;</div><div class="line">	MPI_Status sstat;</div><div class="line">	<span class="keyword">int</span> buf[BUFSIZE];</div><div class="line">	<span class="keyword">char</span> pstr[BUFSIZE*(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) + <span class="number">8</span>) + <span class="number">50</span>];</div><div class="line">	<span class="keyword">int</span> tag = <span class="number">123</span>;</div><div class="line">	<span class="keyword">int</span> dest = <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> rank, nproc, i, j;</div><div class="line"></div><div class="line">	MPI_Init(&amp;argc, &amp;argv);</div><div class="line">	MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);</div><div class="line">	MPI_Comm_size(MPI_COMM_WORLD, &amp;nproc);</div><div class="line"></div><div class="line">	<span class="comment">// Fill data to be sent.</span></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BUFSIZE; ++i)</div><div class="line">	&#123;</div><div class="line">	    buf[i] = BUFSIZE*rank + i;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (rank == RECEIVER)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> rbuf[nproc<span class="number">-1</span>][BUFSIZE];</div><div class="line">		MPI_Request * rreq = (MPI_Request *)<span class="built_in">malloc</span>((nproc<span class="number">-1</span>)*<span class="keyword">sizeof</span>(MPI_Request));</div><div class="line">		MPI_Status * rstat = (MPI_Status *)<span class="built_in">malloc</span>((nproc<span class="number">-1</span>)*<span class="keyword">sizeof</span>(MPI_Status));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// For receiver processor.</span></div><div class="line">	<span class="keyword">int</span> rbuf[nproc<span class="number">-1</span>][BUFSIZE];</div><div class="line">	MPI_Request * rreq = (MPI_Request *)<span class="built_in">malloc</span>((nproc<span class="number">-1</span>)*<span class="keyword">sizeof</span>(MPI_Request));</div><div class="line">	MPI_Status * rstat = (MPI_Status *)<span class="built_in">malloc</span>((nproc<span class="number">-1</span>)*<span class="keyword">sizeof</span>(MPI_Status));</div><div class="line"></div><div class="line">	<span class="comment">// Create persistent send and receive request.</span></div><div class="line">	<span class="keyword">if</span> (rank != RECEIVER)</div><div class="line">	&#123;</div><div class="line">	    MPI_Send_init(buf, BUFSIZE, MPI_INT, RECEIVER, tag, MPI_COMM_WORLD, &amp;sreq);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nproc<span class="number">-1</span>; ++i)</div><div class="line">		&#123;</div><div class="line">		    MPI_Recv_init(rbuf[i], BUFSIZE, MPI_INT, i+<span class="number">1</span>, tag, MPI_COMM_WORLD, rreq+i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (rank != RECEIVER)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc: %d before start...\n"</span>, rank);</div><div class="line">	    MPI_Start(&amp;sreq);</div><div class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc: %d after start...\n"</span>, rank);</div><div class="line"></div><div class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc: %d before wait...\n"</span>, rank);</div><div class="line">		MPI_Wait(&amp;sreq, &amp;sstat);</div><div class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc: %d after wait...\n"</span>, rank);</div><div class="line"></div><div class="line">		MPI_Request_free(&amp;sreq);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		<span class="comment">// Start all receive request.</span></div><div class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc: %d before start all receive...\n"</span>, rank);</div><div class="line">		MPI_Startall(nproc<span class="number">-1</span>, rreq);</div><div class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc: %d after start all receive...\n"</span>, rank);</div><div class="line"></div><div class="line">		<span class="comment">// Wait all.</span></div><div class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc: %d before wait all...\n"</span>, rank);</div><div class="line">		MPI_Waitall(nproc<span class="number">-1</span>, rreq, rstat);</div><div class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc: %d after wait all...\n"</span>, rank);</div><div class="line"></div><div class="line">		<span class="comment">// Info output.</span></div><div class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nproc<span class="number">-1</span>; ++i)</div><div class="line">		&#123;</div><div class="line">		    <span class="built_in">sprintf</span>(pstr, <span class="string">"proc: %d received %d'th message from process %d\n"</span>,</div><div class="line">					rank, i, rstat[i].MPI_SOURCE);</div><div class="line">			<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BUFSIZE<span class="number">-1</span>; ++j)</div><div class="line">			&#123;</div><div class="line">			    <span class="built_in">sprintf</span>(pstr, <span class="string">"%s rbuf[%d][%d]=%d,"</span>, pstr, i, j, rbuf[i][j]);</div><div class="line">			&#125;</div><div class="line">			<span class="built_in">sprintf</span>(pstr, <span class="string">"%s rbuf[%d][%d]=%d\n"</span>, pstr, i, j, rbuf[i][j]);</div><div class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s"</span>, pstr);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// Free request objects.</span></div><div class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nproc<span class="number">-1</span>; ++i)</div><div class="line">		&#123;</div><div class="line">		    MPI_Request_free(rreq + i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="built_in">free</span>(rreq);</div><div class="line">	<span class="built_in">free</span>(rstat);</div><div class="line"></div><div class="line">	MPI_Finalize();</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">[zjshao@master 2-2-3-1]$ mpiexec -n 4 -host node01 send_init_recv_init.x</div><div class="line">proc: 0 before start all receive...</div><div class="line">proc: 0 after start all receive...</div><div class="line">proc: 0 before <span class="built_in">wait</span> all...</div><div class="line">proc: 1 before start...</div><div class="line">proc: 1 after start...</div><div class="line">proc: 1 before wait...</div><div class="line">proc: 1 after wait...</div><div class="line">proc: 2 before start...</div><div class="line">proc: 2 after start...</div><div class="line">proc: 2 before wait...</div><div class="line">proc: 2 after wait...</div><div class="line">proc: 3 before start...</div><div class="line">proc: 3 after start...</div><div class="line">proc: 3 before wait...</div><div class="line">proc: 3 after wait...</div><div class="line">proc: 0 after <span class="built_in">wait</span> all...</div><div class="line">proc: 0 received 0<span class="string">'th message from process 1</span></div><div class="line"> rbuf[0][0]=5, rbuf[0][1]=6, rbuf[0][2]=7, rbuf[0][3]=8, rbuf[0][4]=9</div><div class="line">proc: 0 received 1'th message from process 2</div><div class="line"> rbuf[1][0]=10, rbuf[1][1]=11, rbuf[1][2]=12, rbuf[1][3]=13, rbuf[1][4]=14</div><div class="line">proc: 0 received 2<span class="string">'th message from process 3</span></div><div class="line"> rbuf[2][0]=15, rbuf[2][1]=16, rbuf[2][2]=17, rbuf[2][3]=18, rbuf[2][4]=19</div><div class="line">[zjshao@master 2-2-3-1]$</div></pre></td></tr></table></figure></p>
<p>如果还是增加传输数据的大小，仍有死锁的危险，原因仍是阻塞传输使用MPI环境默认缓冲区导致。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MPI </tag>
            
            <tag> Parallel Computing </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MPI学习-非阻塞通信之非重复的就绪通信和同步通信]]></title>
      <url>http://pytlab.github.io/2016/08/02/MPI%E5%AD%A6%E4%B9%A0-%E9%9D%9E%E9%98%BB%E5%A1%9E%E9%80%9A%E4%BF%A1%E4%B9%8B%E9%9D%9E%E9%87%8D%E5%A4%8D%E7%9A%84%E5%B0%B1%E7%BB%AA%E9%80%9A%E4%BF%A1%E5%92%8C%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1/</url>
      <content type="html"><![CDATA[<p>这里也没啥，就是通过两个例子来学习一下非阻塞通信中的就绪通信和同步通信。</p>
<h3 id="非重复的就绪通信"><a href="#非重复的就绪通信" class="headerlink" title="非重复的就绪通信"></a>非重复的就绪通信</h3><p>这里的就绪通信同阻塞通信中的<a href="http://ipytlab.com/2016/07/08/MPI%E5%AD%A6%E4%B9%A0-%E9%98%BB%E5%A1%9E%E9%80%9A%E4%BF%A1%E4%B9%8B%E5%B0%B1%E7%BB%AA%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">就绪通信</a>一样，都是告诉MPI接收方已经准备就绪，如果检测到并没有准备就绪则MPI就会报错。其他地方就是非阻塞通信与阻塞通信之间的区别了。</p>
<p>下面我就写了个例子来看看<code>MPI_Isend()</code>与<code>MPI_Irecv()</code>之间和<code>MPI_Isend()</code>和<code>MPI_Recv()</code>之间的通信。<br>下面的例子是不同进程之间从左边的进程接收数据并将当前进程的数据发送到右边的进程，因此代码中不需要对进程号进行判断处理。<br><a id="more"></a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mpi.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 5</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> myid, nproc, left, right, i, j;</div><div class="line">    <span class="keyword">int</span> rbuf[BUFSIZE], sbuf[BUFSIZE];</div><div class="line">    <span class="keyword">char</span> pstr[BUFSIZE*(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) + <span class="number">8</span>) + <span class="number">100</span>];</div><div class="line">    MPI_Request rreq, sreq;</div><div class="line">    MPI_Status status;</div><div class="line"></div><div class="line">    MPI_Init(&amp;argc, &amp;argv);</div><div class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;nproc);</div><div class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;myid);</div><div class="line"></div><div class="line">    <span class="comment">// Get source and target process number.</span></div><div class="line">    right = (myid + <span class="number">1</span>)%nproc;</div><div class="line">    left = myid - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (left &lt; <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        left = nproc - <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Data to be sent.</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BUFSIZE; ++i)</div><div class="line">    &#123;</div><div class="line">        sbuf[i] = myid*BUFSIZE + i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Receive data from left process.</span></div><div class="line">    MPI_Irecv(rbuf, BUFSIZE, MPI_INT, left, <span class="number">123</span>, MPI_COMM_WORLD, &amp;rreq);</div><div class="line"></div><div class="line">    MPI_Barrier(MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    <span class="comment">// Send data to right process.</span></div><div class="line">    MPI_Irsend(sbuf, BUFSIZE, MPI_INT, right, <span class="number">123</span>, MPI_COMM_WORLD, &amp;sreq);</div><div class="line"></div><div class="line">    MPI_Wait(&amp;rreq, &amp;status);</div><div class="line">    MPI_Wait(&amp;sreq, &amp;status);</div><div class="line"></div><div class="line">    <span class="comment">// Info output.</span></div><div class="line">    <span class="built_in">sprintf</span>(pstr, <span class="string">"proc: %d"</span>, myid);</div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BUFSIZE<span class="number">-1</span>; ++j)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">sprintf</span>(pstr, <span class="string">"%s, rbuf[%d]=%d"</span>, pstr, j, rbuf[j]);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">sprintf</span>(pstr, <span class="string">"%s, rbuf[%d]=%d\n"</span>, pstr, j, rbuf[j]);</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s"</span>, pstr);</div><div class="line"></div><div class="line">    MPI_Finalize();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译执行的输出信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[zjshao@master 2-2]$ mpiexec -n 4 -host node01 irsendirecv.x </div><div class="line">proc: 1, rbuf[0]=0, rbuf[1]=1, rbuf[2]=2, rbuf[3]=3, rbuf[4]=4</div><div class="line">proc: 2, rbuf[0]=5, rbuf[1]=6, rbuf[2]=7, rbuf[3]=8, rbuf[4]=9</div><div class="line">proc: 3, rbuf[0]=10, rbuf[1]=11, rbuf[2]=12, rbuf[3]=13, rbuf[4]=14</div><div class="line">proc: 0, rbuf[0]=15, rbuf[1]=16, rbuf[2]=17, rbuf[3]=18, rbuf[4]=19</div><div class="line">[zjshao@master 2-2]$</div></pre></td></tr></table></figure></p>
<p>需要注意的是，即使是异步方式的消息通信，还是要求接收端在发送端启动之前启动，所以代码中在所有进程进行接收动作以后设置了一个全局同步动作，确保所有进行接收动作就绪后再启动发送动作。</p>
<p>上述代码将非阻塞通信的接收动作<code>MPI_Irecv</code>换成阻塞通信的<code>MPI_Recv()</code>，但是要注意的是这个时候会出现死锁问题，以为这时的接收动作已经不是非阻塞的，他不会立即返回，因此如果将发送动作放在接收动作后面就会使得接收一直无法返回造成死锁，效果如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[zjshao@master <span class="number">2</span><span class="number">-2</span>]$ mpiexec -n <span class="number">4</span> -host node01 irsendrecv.x </div><div class="line">proc:<span class="number">1</span> trying MPI_Recv from proc:<span class="number">0.</span>..</div><div class="line">proc:<span class="number">2</span> trying MPI_Recv from proc:<span class="number">1.</span>..</div><div class="line">proc:<span class="number">3</span> trying MPI_Recv from proc:<span class="number">2.</span>..</div><div class="line">proc:<span class="number">0</span> trying MPI_Recv from proc:<span class="number">3.</span>..</div><div class="line">[mpiexec@master.cluster] Sending Ctrl-C to processes as requested</div><div class="line">[mpiexec@master.cluster] Press Ctrl-C again to force <span class="built_in">abort</span></div><div class="line">[zjshao@master <span class="number">2</span><span class="number">-2</span>]$</div></pre></td></tr></table></figure></p>
<h3 id="非重复的同步通信"><a href="#非重复的同步通信" class="headerlink" title="非重复的同步通信"></a>非重复的同步通信</h3><p>同步通信的特点就是如果接收未完成，发送端就会<strong>等</strong>。下面是例子代码，基本上与上面的例子相同：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mpi.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 5</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> myid, nproc, left, right, i, j;</div><div class="line">    <span class="keyword">int</span> rbuf[BUFSIZE], sbuf[BUFSIZE];</div><div class="line">    <span class="keyword">char</span> pstr[BUFSIZE*(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) + <span class="number">8</span>) + <span class="number">100</span>];</div><div class="line">    MPI_Request rreq, sreq;</div><div class="line">    MPI_Status status;</div><div class="line"></div><div class="line">    MPI_Init(&amp;argc, &amp;argv);</div><div class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;nproc);</div><div class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;myid);</div><div class="line"></div><div class="line">    <span class="comment">// Get source and target process number.</span></div><div class="line">    right = (myid + <span class="number">1</span>)%nproc;</div><div class="line">    left = myid - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (left &lt; <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        left = nproc - <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Data to be sent.</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BUFSIZE; ++i)</div><div class="line">    &#123;</div><div class="line">        sbuf[i] = myid*BUFSIZE + i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Receive data from left process.</span></div><div class="line">    MPI_Irecv(rbuf, BUFSIZE, MPI_INT, left, <span class="number">123</span>, MPI_COMM_WORLD, &amp;rreq);</div><div class="line"></div><div class="line">    <span class="comment">// Send data to right process.</span></div><div class="line">    MPI_Issend(sbuf, BUFSIZE, MPI_INT, right, <span class="number">123</span>, MPI_COMM_WORLD, &amp;sreq);</div><div class="line"></div><div class="line">    MPI_Wait(&amp;rreq, &amp;status);</div><div class="line">    MPI_Wait(&amp;sreq, &amp;status);</div><div class="line"></div><div class="line">    <span class="comment">// Info output.</span></div><div class="line">    <span class="built_in">sprintf</span>(pstr, <span class="string">"proc: %d"</span>, myid);</div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BUFSIZE<span class="number">-1</span>; ++j)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">sprintf</span>(pstr, <span class="string">"%s, rbuf[%d]=%d"</span>, pstr, j, rbuf[j]);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">sprintf</span>(pstr, <span class="string">"%s, rbuf[%d]=%d\n"</span>, pstr, j, rbuf[j]);</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s"</span>, pstr);</div><div class="line"></div><div class="line">    MPI_Finalize();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[zjshao@master 2-2]$ mpiexec -n 4 -host node01  issendirecv.x</div><div class="line">proc: 1, rbuf[0]=0, rbuf[1]=1, rbuf[2]=2, rbuf[3]=3, rbuf[4]=4</div><div class="line">proc: 2, rbuf[0]=5, rbuf[1]=6, rbuf[2]=7, rbuf[3]=8, rbuf[4]=9</div><div class="line">proc: 0, rbuf[0]=15, rbuf[1]=16, rbuf[2]=17, rbuf[3]=18, rbuf[4]=19</div><div class="line">proc: 3, rbuf[0]=10, rbuf[1]=11, rbuf[2]=12, rbuf[3]=13, rbuf[4]=14</div><div class="line">[zjshao@master 2-2]$</div></pre></td></tr></table></figure></p>
<p>上面的代码接收操作放在发送操作之前，我们将顺序倒过来仍然可以正确执行，因为非阻塞通信会立即返回，让MPI异步等待，这样就不会造成死锁了。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MPI </tag>
            
            <tag> Parallel Computing </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[记一次自己坑了自己的Python编译过程]]></title>
      <url>http://pytlab.github.io/2016/07/16/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%87%AA%E5%B7%B1%E5%9D%91%E4%BA%86%E8%87%AA%E5%B7%B1%E7%9A%84Python%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>这两天把VASPy代码兼容了Python3，于是打算在IBM上用python3跑，结果发现IBM上没有python3，于是我就打算编译一下，本以为就几分钟的事，结果发生了奇怪的错误。。。最终找到原因，竟是自己坑了自己。</p>
<p>就第一步编译<code>python.c</code>就直接报错了，我也是崩溃的</p>
<p>　　　パ..パ<br>　　（　°Д°）・・・<br>＿＿（＿っ /￣￣￣￣￣/＿<br>　　　　＼/＿＿＿＿＿/ </p>
<a id="more"></a>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line">[zjshao@master Python-3.5.2]$ make</div><div class="line">gcc -pthread -c -Wno-unused-result -Wsign-compare -Wunreachable-code -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes    -Werror=declaration-after-statement   -I. -IInclude -I./Include    -DPy_BUILD_CORE -o Programs/python.o ./Programs/python.c</div><div class="line">In file included from Include/Python.h:65:0,</div><div class="line">                 from ./Programs/python.c:3:</div><div class="line">Include/pytime.h:24:4: error: <span class="comment">#error "_PyTime_t need signed 64-bit integer type"</span></div><div class="line"> <span class="comment">#  error "_PyTime_t need signed 64-bit integer type"</span></div><div class="line">    ^~~~~</div><div class="line">In file included from Include/Python.h:50:0,</div><div class="line">                 from ./Programs/python.c:3:</div><div class="line">Include/pytime.h:70:12: error: unknown <span class="built_in">type</span> name ‘_PyTime_t’</div><div class="line"> PyAPI_FUNC(_PyTime_t) _PyTime_FromSeconds(int seconds);</div><div class="line">            ^</div><div class="line">Include/pyport.h:768:34: note: <span class="keyword">in</span> definition of macro ‘PyAPI_FUNC’</div><div class="line"> <span class="comment">#       define PyAPI_FUNC(RTYPE) RTYPE</span></div><div class="line">                                  ^~~~~</div><div class="line">Include/pytime.h:78:12: error: unknown <span class="built_in">type</span> name ‘_PyTime_t’</div><div class="line"> PyAPI_FUNC(_PyTime_t) _PyTime_FromNanoseconds(PY_LONG_LONG ns);</div><div class="line">            ^</div><div class="line">Include/pyport.h:768:34: note: <span class="keyword">in</span> definition of macro ‘PyAPI_FUNC’</div><div class="line"> <span class="comment">#       define PyAPI_FUNC(RTYPE) RTYPE</span></div><div class="line">                                  ^~~~~</div><div class="line">In file included from Include/Python.h:65:0,</div><div class="line">                 from ./Programs/python.c:3:</div><div class="line">Include/pytime.h:82:43: error: unknown <span class="built_in">type</span> name ‘_PyTime_t’</div><div class="line"> PyAPI_FUNC(int) _PyTime_FromSecondsObject(_PyTime_t *t,</div><div class="line">                                           ^~~~~~~~~</div><div class="line">Include/pytime.h:88:48: error: unknown <span class="built_in">type</span> name ‘_PyTime_t’</div><div class="line"> PyAPI_FUNC(int) _PyTime_FromMillisecondsObject(_PyTime_t *t,</div><div class="line">                                                ^~~~~~~~~</div><div class="line">Include/pytime.h:93:44: error: unknown <span class="built_in">type</span> name ‘_PyTime_t’</div><div class="line"> PyAPI_FUNC(double) _PyTime_AsSecondsDouble(_PyTime_t t);</div><div class="line">                                            ^~~~~~~~~</div><div class="line">In file included from Include/Python.h:50:0,</div><div class="line">                 from ./Programs/python.c:3:</div><div class="line">Include/pytime.h:96:12: error: unknown <span class="built_in">type</span> name ‘_PyTime_t’</div><div class="line"> PyAPI_FUNC(_PyTime_t) _PyTime_AsMilliseconds(_PyTime_t t,</div><div class="line">            ^</div><div class="line">Include/pyport.h:768:34: note: <span class="keyword">in</span> definition of macro ‘PyAPI_FUNC’</div><div class="line"> <span class="comment">#       define PyAPI_FUNC(RTYPE) RTYPE</span></div><div class="line">                                  ^~~~~</div><div class="line">In file included from Include/Python.h:65:0,</div><div class="line">                 from ./Programs/python.c:3:</div><div class="line">Include/pytime.h:96:46: error: unknown <span class="built_in">type</span> name ‘_PyTime_t’</div><div class="line"> PyAPI_FUNC(_PyTime_t) _PyTime_AsMilliseconds(_PyTime_t t,</div><div class="line">                                              ^~~~~~~~~</div><div class="line">In file included from Include/Python.h:50:0,</div><div class="line">                 from ./Programs/python.c:3:</div><div class="line">Include/pytime.h:100:12: error: unknown <span class="built_in">type</span> name ‘_PyTime_t’</div><div class="line"> PyAPI_FUNC(_PyTime_t) _PyTime_AsMicroseconds(_PyTime_t t,</div><div class="line">            ^</div><div class="line">Include/pyport.h:768:34: note: <span class="keyword">in</span> definition of macro ‘PyAPI_FUNC’</div><div class="line"> <span class="comment">#       define PyAPI_FUNC(RTYPE) RTYPE</span></div><div class="line">                                  ^~~~~</div><div class="line">In file included from Include/Python.h:65:0,</div><div class="line">                 from ./Programs/python.c:3:</div><div class="line">Include/pytime.h:100:46: error: unknown <span class="built_in">type</span> name ‘_PyTime_t’</div><div class="line"> PyAPI_FUNC(_PyTime_t) _PyTime_AsMicroseconds(_PyTime_t t,</div><div class="line">                                              ^~~~~~~~~</div><div class="line">Include/pytime.h:105:52: error: unknown <span class="built_in">type</span> name ‘_PyTime_t’</div><div class="line"> PyAPI_FUNC(PyObject *) _PyTime_AsNanosecondsObject(_PyTime_t t);</div><div class="line">                                                    ^~~~~~~~~</div><div class="line">Include/pytime.h:111:35: error: unknown <span class="built_in">type</span> name ‘_PyTime_t’</div><div class="line"> PyAPI_FUNC(int) _PyTime_AsTimeval(_PyTime_t t,</div><div class="line">                                   ^~~~~~~~~</div><div class="line">Include/pytime.h:116:43: error: unknown <span class="built_in">type</span> name ‘_PyTime_t’</div><div class="line"> PyAPI_FUNC(int) _PyTime_AsTimeval_noraise(_PyTime_t t,</div><div class="line">                                           ^~~~~~~~~</div><div class="line">In file included from Include/Python.h:50:0,</div><div class="line">                 from ./Programs/python.c:3:</div><div class="line">Include/pytime.h:131:12: error: unknown <span class="built_in">type</span> name ‘_PyTime_t’</div><div class="line"> PyAPI_FUNC(_PyTime_t) _PyTime_GetSystemClock(void);</div><div class="line">            ^</div><div class="line">Include/pyport.h:768:34: note: <span class="keyword">in</span> definition of macro ‘PyAPI_FUNC’</div><div class="line"> <span class="comment">#       define PyAPI_FUNC(RTYPE) RTYPE</span></div><div class="line">                                  ^~~~~</div><div class="line">Include/pytime.h:140:12: error: unknown <span class="built_in">type</span> name ‘_PyTime_t’</div><div class="line"> PyAPI_FUNC(_PyTime_t) _PyTime_GetMonotonicClock(void);</div><div class="line">            ^</div><div class="line">Include/pyport.h:768:34: note: <span class="keyword">in</span> definition of macro ‘PyAPI_FUNC’</div><div class="line"> <span class="comment">#       define PyAPI_FUNC(RTYPE) RTYPE</span></div><div class="line">                                  ^~~~~</div><div class="line">In file included from Include/Python.h:65:0,</div><div class="line">                 from ./Programs/python.c:3:</div><div class="line">Include/pytime.h:156:5: error: unknown <span class="built_in">type</span> name ‘_PyTime_t’</div><div class="line">     _PyTime_t *t,</div><div class="line">     ^~~~~~~~~</div><div class="line">Include/pytime.h:168:5: error: unknown <span class="built_in">type</span> name ‘_PyTime_t’</div><div class="line">     _PyTime_t *t,</div><div class="line">     ^~~~~~~~~</div><div class="line">In file included from Include/Python.h:77:0,</div><div class="line">                 from ./Programs/python.c:3:</div><div class="line">Include/unicodeobject.h:65:0: warning: <span class="string">"Py_USING_UNICODE"</span> redefined</div><div class="line"> <span class="comment">#define Py_USING_UNICODE</span></div><div class="line"> </div><div class="line">In file included from Include/Python.h:8:0,</div><div class="line">                 from ./Programs/python.c:3:</div><div class="line">/usr/<span class="built_in">local</span>/include/python2.7/pyconfig.h:962:0: note: this is the location of the previous definition</div><div class="line"> <span class="comment">#define Py_USING_UNICODE 1</span></div><div class="line"> </div><div class="line">In file included from Include/Python.h:77:0,</div><div class="line">                 from ./Programs/python.c:3:</div><div class="line">Include/unicodeobject.h:71:0: warning: <span class="string">"Py_UNICODE_SIZE"</span> redefined</div><div class="line"> <span class="comment">#define Py_UNICODE_SIZE SIZEOF_WCHAR_T</span></div><div class="line"> </div><div class="line">In file included from Include/Python.h:8:0,</div><div class="line">                 from ./Programs/python.c:3:</div><div class="line">/usr/<span class="built_in">local</span>/include/python2.7/pyconfig.h:959:0: note: this is the location of the previous definition</div><div class="line"> <span class="comment">#define Py_UNICODE_SIZE 2</span></div><div class="line"> </div><div class="line">In file included from Include/Python.h:77:0,</div><div class="line">                 from ./Programs/python.c:3:</div><div class="line">Include/unicodeobject.h:92:0: warning: <span class="string">"PY_UNICODE_TYPE"</span> redefined</div><div class="line"> <span class="comment">#define PY_UNICODE_TYPE wchar_t</span></div><div class="line"> </div><div class="line">In file included from Include/Python.h:8:0,</div><div class="line">                 from ./Programs/python.c:3:</div><div class="line">/usr/<span class="built_in">local</span>/include/python2.7/pyconfig.h:950:0: note: this is the location of the previous definition</div><div class="line"> <span class="comment">#define PY_UNICODE_TYPE unsigned short</span></div><div class="line"> </div><div class="line">make: *** [Programs/python.o] Error 1</div><div class="line">[zjshao@master Python-3.5.2]$</div></pre></td></tr></table></figure>
<p>这个问题在google上没搜到，我当时竟然愚蠢的认为难道最新的Python3.5.2用了什么C的新特性IBM上的gcc不支持。。。</p>
<p>于是我就蛋疼的去下载了最新版本的gcc6.1.0，<br>经过漫长的编译过程之后用了最新的编译器编译python</p>
<p>还是同样的错误。。（醉了。。。</p>
<p>于是，</p>
<p>我决定看一下到底是哪里的错误，干脆自己解决丰衣足食。</p>
<p>最初的问题就在于<code>_PyTime_t</code>这个宏定义没有完成，于是我就找到了相应宏定义的地方(pytime.h)：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PY_INT64_T</span></div><div class="line"><span class="comment">/* _PyTime_t: Python timestamp with subsecond precision. It can be used to</span></div><div class="line">   store a duration, and so indirectly a date (related to another date, like</div><div class="line">   UNIX epoch). */</div><div class="line"><span class="keyword">typedef</span> PY_INT64_T _PyTime_t;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _PyTime_MIN PY_LLONG_MIN</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _PyTime_MAX PY_LLONG_MAX</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#  <span class="meta-keyword">error</span> <span class="meta-string">"_PyTime_t need signed 64-bit integer type"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<p>可见，预处理器报错的原因在于没有定义宏<code>PY_INT64_T</code>。</p>
<p>那再去找<code>PY_INT64_T</code>定义的地方(pyport.h):<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Macros for a 64-bit unsigned integer type; used for type 'twodigits' in the</span></div><div class="line"> * integer implementation, when 30-bit digits are enabled.</div><div class="line"> */</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> int64_t</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_INT64_T 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_INT64_T</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PY_INT64_T</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PY_INT64_T int64_t</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<p>也就是说预处理器没有找到<code>int64_t</code>的定义，我就纳闷了，<code>int64_t</code>的定义不是在C的标准库<code>stdint.h</code>里面就定义好了的么，那么也就是说</p>
<p><strong>根本没有将标准库里的<code>stdint.h</code>include进来！</strong></p>
<p>再继续找。。。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Some versions of HP-UX &amp; Solaris need inttypes.h for int32_t,</span></div><div class="line">   INT32_MAX, etc. */</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_INTTYPES_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_STDINT_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>没包含只有一种可能了就是上面的<code>HAVE_STDINT_H</code>没有定义，再继续。。。</p>
<p>然后我就找到了<code>pyconfig.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Define to 1 if you have the &lt;stdint.h&gt; header file. */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_STDINT_H 1</span></div></pre></td></tr></table></figure>
<p>看来没有设置这个宏，难道我压根就没有包含这个<code>pyconfig.h</code>?</p>
<p>不能够啊，编译参数里面都写得很清楚了<code>-I.</code>。。。</p>
<p>这个时候我想到了一个东西： <code>C_INCLUDE_PATH</code>!</p>
<p>我之前为了编译自己写得C++扩展模块，将这个路径改成了Python2.7的头文件路径了。。。输出一下，果然：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[zjshao@master Python-3.5.0]$ <span class="built_in">echo</span> <span class="variable">$C_INCLUDE_PATH</span> </div><div class="line">/usr/<span class="built_in">local</span>/include/python2.7/:</div><div class="line">[zjshao@master Python-3.5.0]$</div></pre></td></tr></table></figure>
<p>那我就试试把当前python源代码的路径添加进去再编译试试。。。</p>
<p>结果。。。</p>
<p>就成了。。</p>
<p>成了。。。了。。。</p>
<p>果然还是太年轻，自己坑了自己。。。</p>
<p>不过这是不是也说明了环境变量<code>C_INCLUDE_PATH</code>的搜索顺序在编译参数<code>-I</code>的前面？<br>应该是吧。</p>
]]></content>
      
        <categories>
            
            <category> 我的日常 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VASPy已兼容python3.x]]></title>
      <url>http://pytlab.github.io/2016/07/16/VASPy%E5%B7%B2%E5%85%BC%E5%AE%B9python3-x/</url>
      <content type="html"><![CDATA[<p>趁着代码量还不多，把VASPy进行了修改使其同时兼容Python 2.7.x 和 Python 3.x</p>
<p>今后新增功能都将以Python3语法优先并向下兼容Python2.7.x</p>
<p>项目GitHub链接：<a href="https://github.com/PytLab/VASPy" target="_blank" rel="external"><span class="fa fa-github"></span> PytLab/VASPy: Manipulating VASP files with Python</a></p>
<a id="more"></a>
<p><img src="/assets/images/blog_img/2016-07-16-VASPy已兼容python3-x.md/VASPy.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 代码作品 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> VASPy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MPI学习--非重复的非阻塞通信之非重复的缓冲通信]]></title>
      <url>http://pytlab.github.io/2016/07/09/MPI%E5%AD%A6%E4%B9%A0-%E9%9D%9E%E9%87%8D%E5%A4%8D%E7%9A%84%E9%9D%9E%E9%98%BB%E5%A1%9E%E9%80%9A%E4%BF%A1%E4%B9%8B%E9%9D%9E%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BC%93%E5%86%B2%E9%80%9A%E4%BF%A1/</url>
      <content type="html"><![CDATA[<h3 id="对比MPI-Bsend-MPI-Isend-MPI-Ibsend"><a href="#对比MPI-Bsend-MPI-Isend-MPI-Ibsend" class="headerlink" title="对比MPI_Bsend(), MPI_Isend(), MPI_Ibsend()"></a>对比<code>MPI_Bsend()</code>, <code>MPI_Isend()</code>, <code>MPI_Ibsend()</code></h3><p>三者均不发生阻塞，执行后都会立即返回，且后台有MPI环境实施消息传输。</p>
<ul>
<li><p><code>MPI_Bsend()</code>之所以会立即返回，是因为用户已经定义了缓冲区，调用后会将数据复制到缓冲区中，所以不用等接收端接收便可以返回，但是在执行<code>MPI_Buffer_detach()</code>时才最终确保消息清扫干净，完成传输，也就是说消息传输完毕之前，<code>MPI_Buffer_detach()</code>不会返回。</p>
</li>
<li><p><code>MPI_Isend()</code>本身就是非阻塞通信，所以会立即返回，交给MPI环境后台来实施消息传递。但是标准非阻塞通信需要调用<code>MPI_Wait()</code>等机制来等待传输完成。</p>
</li>
<li><p><code>MPI_Ibsend()</code>更像是前两者的结合体，但是要注意的是发送完成并<strong>不代表</strong>消息传递完成。</p>
</li>
</ul>
<a id="more"></a>
<p>下面通过一个例子来看一下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mpi.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DATALEN 6553600</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></div><div class="line">&#123;</div><div class="line">    MPI_Status sstatus, rstatus;</div><div class="line">    MPI_Request sreq, rreq;</div><div class="line">    <span class="keyword">int</span> a[DATALEN], b[DATALEN];</div><div class="line">    <span class="keyword">char</span> * buf;</div><div class="line">    <span class="keyword">int</span> i, j, rank, size, errs = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> sflag, rflag, other;</div><div class="line">    <span class="keyword">int</span> s1, bufsize;</div><div class="line"></div><div class="line">    MPI_Init(&amp;argc, &amp;argv);</div><div class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);</div><div class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;size);</div><div class="line"></div><div class="line">    MPI_Pack_size(DATALEN, MPI_INT, MPI_COMM_WORLD, &amp;s1);</div><div class="line">    bufsize = MPI_BSEND_OVERHEAD + s1;</div><div class="line">    buf = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(bufsize);</div><div class="line"></div><div class="line">    MPI_Buffer_attach(buf, bufsize);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (size != <span class="number">2</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"number of processes must be 2"</span>);</div><div class="line">        MPI_Finalize();</div><div class="line">        fflush(<span class="built_in">stderr</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (rank == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        other = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        other = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sflag = <span class="number">0</span>;</div><div class="line">    rflag = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DATALEN; ++i)</div><div class="line">    &#123;</div><div class="line">        a[i] = (rank + DATALEN*i) + i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (rank == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc %d: before ibsend...%f\n"</span>, rank, MPI_Wtime());</div><div class="line">        MPI_Ibsend(a, DATALEN, MPI_INT, other, <span class="number">111</span>, MPI_COMM_WORLD, &amp;sreq);</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc %d: after ibsend...%f\n"</span>, rank, MPI_Wtime());</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (!sflag)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc %d: before Ibsend test, sflag = %d...%f\n"</span>, rank, sflag, MPI_Wtime());</div><div class="line">            MPI_Test(&amp;sreq, &amp;sflag, &amp;sstatus);</div><div class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc %d: after Ibsend test, sflag = %d...%f\n"</span>, rank, sflag, MPI_Wtime());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (rank == <span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">9999999</span>; ++i)</div><div class="line">        &#123;</div><div class="line">            MPI_Wtime();</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc %d: before Irecv...%f\n"</span>, rank, MPI_Wtime());</div><div class="line">        MPI_Irecv(b, DATALEN, MPI_INT, other, <span class="number">111</span>, MPI_COMM_WORLD, &amp;rreq);</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc %d: after Irecv...%f\n"</span>, rank, MPI_Wtime());</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (!rflag)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc %d: before Irecv test, rflag = %d...%f\n"</span>, rank, rflag, MPI_Wtime());</div><div class="line">            MPI_Test(&amp;rreq, &amp;rflag, &amp;rstatus);</div><div class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc %d: after Irecv test, rflag = %d...%f\n"</span>, rank, rflag, MPI_Wtime());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc: %d, received ...\n"</span>, rank);</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"b[%d]=%d\n"</span>, i, b[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc: %d before Buffer_detach...%f\n"</span>, rank, MPI_Wtime());</div><div class="line">    MPI_Buffer_detach(&amp;buf, &amp;bufsize);</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc: %d after Buffer_detach...%f\n"</span>, rank, MPI_Wtime());</div><div class="line">    </div><div class="line">    <span class="built_in">free</span>(buf);</div><div class="line">    </div><div class="line">    MPI_Finalize();</div><div class="line">        </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">[zjshao@master 2-2]$ mpicc ibsendrecv.c -o ibsendrecv.x</div><div class="line">[zjshao@master 2-2]$ mpiexec -n 2 -host node01 ibsendrecv.x</div><div class="line">proc 0: before ibsend...1468070428.066756</div><div class="line">proc 0: after ibsend...1468070428.113055</div><div class="line">proc 0: before Ibsend <span class="built_in">test</span>, sflag = 0...1468070428.113082</div><div class="line">proc 0: after Ibsend <span class="built_in">test</span>, sflag = 1...1468070428.113117</div><div class="line">proc: 0 before Buffer_detach...1468070428.113122</div><div class="line">proc 1: before Irecv...1468070428.559447</div><div class="line">proc 1: after Irecv...1468070428.559488</div><div class="line">proc 1: before Irecv <span class="built_in">test</span>, rflag = 0...1468070428.559491</div><div class="line">proc 1: after Irecv <span class="built_in">test</span>, rflag = 0...1468070428.559572</div><div class="line">proc 1: before Irecv <span class="built_in">test</span>, rflag = 0...1468070428.559575</div><div class="line">proc 1: after Irecv <span class="built_in">test</span>, rflag = 0...1468070428.559581</div><div class="line">proc 1: before Irecv <span class="built_in">test</span>, rflag = 0...1468070428.559583</div><div class="line">proc 1: after Irecv <span class="built_in">test</span>, rflag = 0...1468070428.559588</div><div class="line">proc 1: before Irecv <span class="built_in">test</span>, rflag = 0...1468070428.559590</div><div class="line">proc 1: after Irecv <span class="built_in">test</span>, rflag = 0...1468070428.559596</div><div class="line">proc 1: before Irecv <span class="built_in">test</span>, rflag = 0...1468070428.559598</div><div class="line">proc 1: after Irecv <span class="built_in">test</span>, rflag = 0...1468070428.559604</div><div class="line">proc 1: before Irecv <span class="built_in">test</span>, rflag = 0...1468070428.559606</div><div class="line">proc 1: after Irecv <span class="built_in">test</span>, rflag = 0...1468070428.559612</div><div class="line">proc 1: before Irecv <span class="built_in">test</span>, rflag = 0...1468070428.559614</div><div class="line">proc 1: after Irecv <span class="built_in">test</span>, rflag = 0...1468070428.559619</div><div class="line">proc 1: before Irecv <span class="built_in">test</span>, rflag = 0...1468070428.559622</div><div class="line">proc 1: after Irecv <span class="built_in">test</span>, rflag = 0...1468070428.559627</div><div class="line">proc 1: before Irecv <span class="built_in">test</span>, rflag = 0...1468070428.559629</div><div class="line">proc 1: after Irecv <span class="built_in">test</span>, rflag = 0...1468070428.559635</div><div class="line">proc 1: before Irecv <span class="built_in">test</span>, rflag = 0...1468070428.559637</div><div class="line">proc 1: after Irecv <span class="built_in">test</span>, rflag = 0...1468070428.559642</div><div class="line">proc 1: before Irecv <span class="built_in">test</span>, rflag = 0...1468070428.559645</div><div class="line">proc 1: after Irecv <span class="built_in">test</span>, rflag = 0...1468070428.559650</div><div class="line">proc 1: before Irecv <span class="built_in">test</span>, rflag = 0...1468070428.559652</div><div class="line">proc 1: after Irecv <span class="built_in">test</span>, rflag = 0...1468070428.559658</div><div class="line">proc 1: before Irecv <span class="built_in">test</span>, rflag = 0...1468070428.559660</div><div class="line">proc 1: after Irecv <span class="built_in">test</span>, rflag = 0...1468070428.559665</div><div class="line">proc 1: before Irecv <span class="built_in">test</span>, rflag = 0...1468070428.559668</div><div class="line">proc 1: after Irecv <span class="built_in">test</span>, rflag = 1...1468070428.600704</div><div class="line">proc: 1, received ...</div><div class="line">b[0]=0</div><div class="line">b[1]=6553601</div><div class="line">proc: 1 before Buffer_detach...1468070428.600724</div><div class="line">proc: 0 after Buffer_detach...1468070428.600687</div><div class="line">proc: 1 after Buffer_detach...1468070428.600730</div><div class="line">[zjshao@master 2-2]$</div></pre></td></tr></table></figure></p>
<ol>
<li>从执行的结果可以看出进程0调用<code>MPI_Ibsend()</code>之后立即返回，而且返回之后进行<code>MPI_Test()</code>的竟然是<code>True</code>。这表明缓冲发送已完成，但这并不是消息传递的完成，因为这其实是把数据复制到了缓冲区中。</li>
<li>之后进程0立即调用<code>MPI_Buffer_detach()</code>却没有返回，所以到等待消息传递完成才行。</li>
<li>之后进程1开始进行接收消息，调用<code>MPI_Irecv()</code>还是会立即返回，但我们的数据量比较大，消息并不能解析完，这个时候进行检测显示接收没有完成，于是就有了下面这一大串的输出。其实如果我们把这一部分测试的代码替换成其他的代码，就可以体现出非阻塞的优势了。</li>
<li>数据传输完之后，便可以进行缓冲区的detach了。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MPI </tag>
            
            <tag> Parallel Computing </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MPI学习--初识非阻塞通信]]></title>
      <url>http://pytlab.github.io/2016/07/09/MPI%E5%AD%A6%E4%B9%A0-%E5%88%9D%E8%AF%86%E9%9D%9E%E9%98%BB%E5%A1%9E%E9%80%9A%E4%BF%A1/</url>
      <content type="html"><![CDATA[<h3 id="非阻塞通信与阻塞通信的区别"><a href="#非阻塞通信与阻塞通信的区别" class="headerlink" title="非阻塞通信与阻塞通信的区别"></a>非阻塞通信与阻塞通信的区别</h3><p>对于非阻塞通信的理解还是要理解他和阻塞通信的区别。这个区别书上扯了一大堆好像也没有用简单通俗的语言总结这两者之间的区别让人看着后面的例子一开始有点头晕。那其实区别很简单：</p>
<h4 id="阻塞通信"><a href="#阻塞通信" class="headerlink" title="阻塞通信"></a>阻塞通信</h4><p>阻塞通信就是使用前面几篇博客里面的那些发送和接收函数，例如<code>MPI_Send()</code>和<code>MPI_Recv()</code>，这些函数有一个特点就是<strong>这些函数在通信完成之前是不会返回的，也就是阻塞</strong>。</p>
<p>那什么时候是通信完成呢？</p>
<ul>
<li>对于<strong>发送端</strong>，所谓完成就是指发送缓冲区可以被安全的在使用，也就意味着之前发送缓冲区的数据已经被成功的转移走了，可能被MPI保存在其他地方，或者放到了接收端的缓冲区中。</li>
<li>对于<strong>接收端</strong>，所谓的完成就是指数据已经成功的复制到了接受缓冲区中，接收进程可以放心使用缓冲区。</li>
</ul>
<a id="more"></a>
<h4 id="非阻塞通信"><a href="#非阻塞通信" class="headerlink" title="非阻塞通信"></a>非阻塞通信</h4><p>相比之下，非阻塞通信就是使用<code>MPI_Isend()</code>和<code>MPI_Irecv()</code>等函数完成通信的过程。这些函数没有阻塞，会<strong>立即返回</strong>，尽管通信还没有完成，也可以返回。但是必须在后面调用<code>MPI_Wait()</code>来查看通信是否完成。<br>这样我们就可以在告诉让MPI进行消息传送或者接受之后去做其他的事情，这样计算和通信并发进行，会提升效率。</p>
<p><img src="/assets/images/blog_img/2016-07-09-MPI学习-初识非阻塞通信/MPI_Non_Blocking_Communication.png" alt=""></p>
<h3 id="非阻塞通信业遵循一定的执行顺序"><a href="#非阻塞通信业遵循一定的执行顺序" class="headerlink" title="非阻塞通信业遵循一定的执行顺序"></a>非阻塞通信业遵循一定的执行顺序</h3><p>在这里我写了个例子来看看非阻塞通信的执行顺序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mpi.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> sba[<span class="number">1</span>] = &#123;<span class="number">-1</span>&#125;, sbb[<span class="number">1</span>] = &#123;<span class="number">1</span>&#125;;</div><div class="line">    <span class="keyword">int</span> rba[<span class="number">1</span>], rbb[<span class="number">1</span>];</div><div class="line">    <span class="keyword">int</span> rank, nproc;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> flag1, flag2;</div><div class="line">    MPI_Comm comm = MPI_COMM_WORLD;</div><div class="line">    MPI_Request r1, r2;</div><div class="line">    MPI_Status status1, status2;</div><div class="line"></div><div class="line">    MPI_Init(&amp;argc, &amp;argv);</div><div class="line">    MPI_Comm_rank(comm, &amp;rank);</div><div class="line">    MPI_Comm_size(comm, &amp;nproc);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (rank == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc %d: sba = [%d]\n"</span>, rank, sba[<span class="number">0</span>]);</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc %d: sbb = [%d]\n"</span>, rank, sbb[<span class="number">0</span>]);</div><div class="line">        fflush(<span class="built_in">stderr</span>);</div><div class="line"></div><div class="line">        MPI_Isend(sba, <span class="number">1</span>, MPI_INT, <span class="number">1</span>, <span class="number">0</span>, comm, &amp;r1);</div><div class="line">        MPI_Isend(sbb, <span class="number">1</span>, MPI_INT, <span class="number">1</span>, <span class="number">0</span>, comm, &amp;r2);</div><div class="line"></div><div class="line">        MPI_Wait(&amp;r1, &amp;status1);</div><div class="line">        MPI_Wait(&amp;r2, &amp;status2);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rank == <span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        MPI_Irecv(rba, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, MPI_ANY_TAG, comm, &amp;r1);</div><div class="line">        MPI_Irecv(rbb, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, <span class="number">0</span>, comm, &amp;r2);</div><div class="line"></div><div class="line">        MPI_Wait(&amp;r1, &amp;status1);</div><div class="line">        MPI_Wait(&amp;r2, &amp;status2);</div><div class="line"></div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc %d: rba = [%d]\n"</span>, rank, rba[<span class="number">0</span>]);</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc %d: rbb = [%d]\n"</span>, rank, rbb[<span class="number">0</span>]);</div><div class="line">        fflush(<span class="built_in">stderr</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    MPI_Finalize();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译执行可以看到：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[zjshao@master 2-2]$ mpicc nonblocking_order.c -o nonblocking_order.x</div><div class="line">[zjshao@master 2-2]$ mpiexec -n 2 -host node01 nonblocking_order.x</div><div class="line">proc 0: sba = [-1]</div><div class="line">proc 0: sbb = [1]</div><div class="line">proc 1: rba = [-1]</div><div class="line">proc 1: rbb = [1]</div></pre></td></tr></table></figure></p>
<p>进程0的第一个发送会与进程1的第一个接收配对，第二个也是这样。即使我交换了接受端的接受顺序，也是第一个配对第一个，第二个配对第二个这样。</p>
<h3 id="通信结束测试"><a href="#通信结束测试" class="headerlink" title="通信结束测试"></a>通信结束测试</h3><h4 id="通信对象"><a href="#通信对象" class="headerlink" title="通信对象"></a>通信对象</h4><p>非阻塞通信使用了等待函数，该函数使用了非阻塞通信对象来管理通信动作完成与否的信息。<br>例如上面的<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> flag1, flag2;</div><div class="line">MPI_Request r1, r2;</div></pre></td></tr></table></figure></p>
<p>这些都是通信对象，主要用于识别通信操作，并在启动和结束通信的动作之间建立关联。</p>
<h4 id="通信测试函数"><a href="#通信测试函数" class="headerlink" title="通信测试函数"></a>通信测试函数</h4><ul>
<li><p><code>MPI_Wait()</code></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Wait</span><span class="params">(MPI_Request *request, MPI_Status *status)</span></span></div></pre></td></tr></table></figure>
<p>  此函数是<strong>非本地操作</strong>，他的返回意味着相应通信对象所代表的通信过程已经完成了。</p>
</li>
<li><p><code>MPI_Test()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Test</span><span class="params">(MPI_Request *request, <span class="keyword">int</span> *flag, MPI_Status *status)</span></span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>此函数是一个本地函数，它仅仅进行测试，不保证通信过程完成。<br>下面我在上面的代码基础上进行测试。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (rank == <span class="number">1</span>)</div><div class="line">&#123;</div><div class="line">    MPI_Irecv(rba, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, MPI_ANY_TAG, comm, &amp;r1);</div><div class="line">    MPI_Irecv(rbb, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, <span class="number">0</span>, comm, &amp;r2);</div><div class="line"></div><div class="line">    MPI_Test(&amp;r1, &amp;flag1, &amp;status1);</div><div class="line">    MPI_Test(&amp;r2, &amp;flag2, &amp;status2);</div><div class="line"></div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc %d: rba = [%d], t = %f, flag1 = %d\n"</span>, rank, rba[<span class="number">0</span>], MPI_Wtime(), flag1);</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc %d: rbb = [%d], t = %f, flag2 = %d\n"</span>, rank, rbb[<span class="number">0</span>], MPI_Wtime(), flag2);</div><div class="line"></div><div class="line">    MPI_Wait(&amp;r1, &amp;status1);</div><div class="line">    MPI_Wait(&amp;r2, &amp;status2);</div><div class="line"></div><div class="line">    MPI_Test(&amp;r1, &amp;flag1, &amp;status1);</div><div class="line">    MPI_Test(&amp;r2, &amp;flag2, &amp;status2);</div><div class="line"></div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc %d: rba = [%d], t = %f, flag1 = %d\n"</span>, rank, rba[<span class="number">0</span>], MPI_Wtime(), flag1);</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"proc %d: rbb = [%d], t = %f, flag2 = %d\n"</span>, rank, rbb[<span class="number">0</span>], MPI_Wtime(), flag2);</div><div class="line"></div><div class="line">    fflush(<span class="built_in">stderr</span>);</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>编译执行可以看到：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[zjshao@master 2-2]$ mpicc nonblocking_order.c -o nonblocking_order.x</div><div class="line">[zjshao@master 2-2]$ mpiexec -n 2 -host node01 nonblocking_order.x</div><div class="line">proc 0: sba = [-1]</div><div class="line">proc 0: sbb = [1]</div><div class="line">proc 1: rba = [1], t = 1468052801.197011, flag1 = 0</div><div class="line">proc 1: rbb = [4197776], t = 1468052801.197031, flag2 = 0</div><div class="line">proc 1: rba = [-1], t = 1468052801.197051, flag1 = 1</div><div class="line">proc 1: rbb = [1], t = 1468052801.197057, flag2 = 1</div><div class="line">[zjshao@master 2-2]$</div></pre></td></tr></table></figure></p>
<p>第一次调用<code>MPI_Test()</code>的时候通信并没有完成，数据也是随机的值，<code>flag</code>仍未<code>false</code>。<br>在调用<code>MPI_Wait()</code>之后表示通信完成，再用<code>MPI_Test()</code>进行测试，这时候<code>flag</code>就设置成了<code>true</code>。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MPI </tag>
            
            <tag> Parallel Computing </tag>
            
            <tag> 非阻塞通信 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MPI学习--阻塞通信之就绪通信模式和同步通信模式]]></title>
      <url>http://pytlab.github.io/2016/07/08/MPI%E5%AD%A6%E4%B9%A0-%E9%98%BB%E5%A1%9E%E9%80%9A%E4%BF%A1%E4%B9%8B%E5%B0%B1%E7%BB%AA%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="就绪通信模式"><a href="#就绪通信模式" class="headerlink" title="就绪通信模式"></a>就绪通信模式</h2><p>就绪模式的发送方式与同步和标准发送完全一致，不一样的是就绪通信模式是：</p>
<p>仅当对方的接收操作启动并且准备就绪时，才可发生数据，并不是MPI会自动判断是否就绪（他没那么智能？）而是<strong>告诉MPI对方以准备就绪接收你发的消息，如果你骗了MPI，MPI会不爽，然后报错</strong>。</p>
<p>基于你告诉MPI的这个信息，就可以避免一些列的缓冲操作以及收发双方的握手操作，是的MPI环境可对通信做更细致的优化以提高通信效率。</p>
<p>需要注意的是：<br><div class="alert alert-warning"><i class="fa fa-bell"></i>  就绪通信并不意味着发送方的发送动作是否结束取决于接收端的状态，对发送方而言，这仅仅意味着发送缓冲区在发送函数返回之后即可被安全的用于其它操作，因为你告诉MPI，接收方早已就绪了，所以MPI也就信任了你。</div></p>
<a id="more"></a>
<p>还是通过代码来说明的清楚。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mpi.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> rank, size, i;</div><div class="line">    <span class="keyword">int</span> buffer[<span class="number">10</span>];</div><div class="line">    MPI_Status status;</div><div class="line">    MPI_Init(&amp;argc, &amp;argv);</div><div class="line">    MPI_Comm comm = MPI_COMM_WORLD;</div><div class="line">    MPI_Comm_rank(comm, &amp;rank);</div><div class="line">    MPI_Comm_size(comm, &amp;size);</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"size = %d\n"</span>, size);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (size &lt; <span class="number">2</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Please run with two processes.\n"</span>);</div><div class="line">        fflush(<span class="built_in">stderr</span>);</div><div class="line">        MPI_Finalize();</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(rank == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</div><div class="line">        &#123;</div><div class="line">            buffer[i] = <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        MPI_Recv(buffer, <span class="number">10</span>, MPI_INT, <span class="number">1</span>, <span class="number">123</span>, comm, &amp;status);</div><div class="line"></div><div class="line">        <span class="comment">// Check.</span></div><div class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (buffer[i] != i)</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</div><div class="line">                        <span class="string">"Error: buffer[%d]=%d but is expected to be %d\n"</span>,</div><div class="line">                        i, buffer[i], i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"buffer[%d]=%d but is expected to be %d\n"</span>, i, buffer[i], i);</div><div class="line">        &#125;</div><div class="line">        fflush(<span class="built_in">stderr</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rank == <span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</div><div class="line">        &#123;</div><div class="line">            buffer[i] = i;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        MPI_Rsend(buffer, <span class="number">10</span>, MPI_INT, <span class="number">0</span>, <span class="number">123</span>, comm);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    MPI_Finalize();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译后能够在两个进程中正确运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[zjshao@master ch02]$ mpicc rsendrecv.c -o rsendrecv.x</div><div class="line">[zjshao@master ch02]$ mpiexec -n 2 -host node01 rsendrecv.x</div><div class="line">size = 2</div><div class="line">size = 2</div><div class="line">buffer[0]=0 but is expected to be 0</div><div class="line">buffer[1]=1 but is expected to be 1</div><div class="line">buffer[2]=2 but is expected to be 2</div><div class="line">buffer[3]=3 but is expected to be 3</div><div class="line">buffer[4]=4 but is expected to be 4</div><div class="line">buffer[5]=5 but is expected to be 5</div><div class="line">buffer[6]=6 but is expected to be 6</div><div class="line">buffer[7]=7 but is expected to be 7</div><div class="line">buffer[8]=8 but is expected to be 8</div><div class="line">buffer[9]=9 but is expected to be 9</div><div class="line">[zjshao@master ch02]$</div></pre></td></tr></table></figure></p>
<h3 id="假如我们欺骗了MPI"><a href="#假如我们欺骗了MPI" class="headerlink" title="假如我们欺骗了MPI"></a>假如我们欺骗了MPI</h3><p>我们现在通过阻塞函数在接收端为做好准备时候进行就绪消息传递：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</div><div class="line">    &#123;</div><div class="line">        buffer[i] = <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    MPI_Barrier(comm);</div><div class="line">    MPI_Recv(buffer, <span class="number">10</span>, MPI_INT, <span class="number">1</span>, <span class="number">123</span>, comm, &amp;status);</div><div class="line"></div><div class="line">    <span class="comment">// Check.</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (buffer[i] != i)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</div><div class="line">                    <span class="string">"Error: buffer[%d]=%d but is expected to be %d\n"</span>,</div><div class="line">                    i, buffer[i], i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"buffer[%d]=%d but is expected to be %d\n"</span>, i, buffer[i], i);</div><div class="line">    &#125;</div><div class="line">    fflush(<span class="built_in">stderr</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (rank == <span class="number">1</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</div><div class="line">    &#123;</div><div class="line">        buffer[i] = i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    MPI_Rsend(buffer, <span class="number">10</span>, MPI_INT, <span class="number">0</span>, <span class="number">123</span>, comm);</div><div class="line">    MPI_Barrier(comm);</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>输出是啥样的呢：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[zjshao@master ch02]$ mpicc rsendrecv.c -o rsendrecv.x</div><div class="line">[zjshao@master ch02]$ mpiexec -n 2 -host node01 rsendrecv.x</div><div class="line">size = 2</div><div class="line">size = 2</div><div class="line"></div><div class="line">===================================================================================</div><div class="line">=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES</div><div class="line">=   PID 10073 RUNNING AT node01</div><div class="line">=   EXIT CODE: 11</div><div class="line">=   CLEANING UP REMAINING PROCESSES</div><div class="line">=   YOU CAN IGNORE THE BELOW CLEANUP MESSAGES</div><div class="line">===================================================================================</div><div class="line">YOUR APPLICATION TERMINATED WITH THE EXIT STRING: Segmentation fault (signal 11)</div><div class="line">This typically refers to a problem with your application.</div><div class="line">Please see the FAQ page <span class="keyword">for</span> debugging suggestions</div><div class="line">[zjshao@master ch02]$</div></pre></td></tr></table></figure></p>
<hr>
<p>MPI输出这些是啥意思呢？我大概翻译下：<br>MPI:”你骗我！老子不干了。”</p>
<h2 id="同步通信模式"><a href="#同步通信模式" class="headerlink" title="同步通信模式"></a>同步通信模式</h2><p>与就绪通信模式不同，同步的发送动作什么时候做都行，即使接收方没有准备好也没有关系。如果接收方没有准备好咋办呢？等。即发送端需等待接收端的接受动作发起并开始接受数据之后才能够返回。</p>
<p>发送动作的结束意味着：</p>
<ul>
<li>发送缓冲区已经可以用于其它用途</li>
<li>接收端已经接受了（部分）数据了</li>
</ul>
<h3 id="同步通信协议"><a href="#同步通信协议" class="headerlink" title="同步通信协议"></a>同步通信协议</h3><p>发送端首先向接收端发起一个请求发送消息的申请，接收端的MPI环境会将这个请求保存下来，然后带相应的接受动作启动之后为其返回一个信息发送许可，发送端据此信息再执行实际的消息发送。</p>
<p>这里由于阻塞同步通信比较简单，而且代码基本上跟标准模式相同，就不写例子了。</p>
<div class="alert alert-info"><i class="fa fa-info"></i>  MPI程序安全的必要条件是：该程序不需要借助缓冲机制进行通信。</div>
<p>对这样的程序把所有的发送操作替换为同步通信模式时仍可保持正确。这样的程序可移植性最好，但是性能不一定最优。好的解决办法就是<strong>反阻塞通信</strong>。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MPI </tag>
            
            <tag> Parallel Computing </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MPI学习--阻塞通信之缓冲通信模式]]></title>
      <url>http://pytlab.github.io/2016/07/08/MPI%E5%AD%A6%E4%B9%A0-%E9%98%BB%E5%A1%9E%E9%80%9A%E4%BF%A1%E4%B9%8B%E7%BC%93%E5%86%B2%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>缓冲通信模式主要用于解开阻塞通信的发送和接受之间的耦合。有了缓冲机制，即使在接收端没有启动相应的接收情况下，在<strong>完成消息数据到缓冲区的转移后</strong>发送端的阻塞发送函数也可以返回。</p>
<p>但缓冲方式带来了额外的内存到内存的复制开销，会导致一定的性能损失和资源占用。的确，每个进程都要在堆里分配内存然后注册成为缓冲区。</p>
<p>缓冲区的使用并不能改变发送和接受之间的语义关系，及不能改变程序的正确性。</p>
<p>与标准模式由于以来MPI环境提供的缓冲机制而受到远端进程状态左右不同，缓冲发送完成与否不会受远端匹配进程状态的影响。但当消息大小超过缓冲区容量时，会报错。</p>
<a id="more"></a>
<p>缓冲通信模式如下图所示，<br><img src="/assets/images/blog_img/2016-07-08-MPI学习-阻塞通信之缓冲通信模式/buffer_recv.gif" alt=""></p>
<p>然后就写了个缓冲通信的例子来实际操作下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mpi.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG1LEN 7</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG2LEN 2</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG3LEN 17</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RMSG1LEN 64</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RMSG2LEN 64</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RMSG3LEN 64</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Communicator.</span></div><div class="line">    MPI_Comm comm = MPI_COMM_WORLD;</div><div class="line"></div><div class="line">    <span class="comment">// Process number.</span></div><div class="line">    <span class="keyword">int</span> src = <span class="number">0</span>, dest = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Buffer sizes for 3 msg.</span></div><div class="line">    <span class="keyword">int</span> s1, s2, s3;</div><div class="line"></div><div class="line">    <span class="comment">// Buffers.</span></div><div class="line">    <span class="keyword">char</span> msg1[MSG1LEN], msg3[MSG2LEN], rmsg1[RMSG1LEN], rmsg3[MSG3LEN];</div><div class="line"></div><div class="line">    <span class="comment">// Buffers.</span></div><div class="line">    <span class="keyword">char</span> msg1[MSG1LEN], msg3[MSG2LEN], rmsg1[RMSG1LEN], rmsg3[MSG3LEN];</div><div class="line">    <span class="keyword">double</span> msg2[MSG2LEN], rmsg2[RMSG2LEN];</div><div class="line"></div><div class="line">    <span class="comment">// Buffer address.</span></div><div class="line">    <span class="keyword">char</span> * buf, * bbuf;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> errs = <span class="number">0</span>, rank, bufsize, bsize;</div><div class="line"></div><div class="line">    MPI_Init(&amp;argc, &amp;argv);</div><div class="line">    MPI_Comm_rank(comm, &amp;rank);</div><div class="line"></div><div class="line">    <span class="comment">// Create buffer for all messages.</span></div><div class="line">    MPI_Pack_size(MSG1LEN, MPI_CHAR, comm, &amp;s1);</div><div class="line">    MPI_Pack_size(MSG2LEN, MPI_DOUBLE, comm, &amp;s2);</div><div class="line">    MPI_Pack_size(MSG3LEN, MPI_CHAR, comm, &amp;s3);</div><div class="line"></div><div class="line">    <span class="comment">// Total buffer size.</span></div><div class="line">    bufsize = <span class="number">3</span>*MPI_BSEND_OVERHEAD + s1 + s2 + s3;</div><div class="line">    buf = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(bufsize);</div><div class="line">    MPI_Buffer_attach(buf, bufsize);</div><div class="line"></div><div class="line">    <span class="built_in">strncpy</span>(msg1, <span class="string">"012345"</span>, MSG1LEN);</div><div class="line">    <span class="built_in">strncpy</span>(msg3, <span class="string">"0123401234012341"</span>, MSG3LEN);</div><div class="line">    msg2[<span class="number">0</span>] = <span class="number">1.23</span>;</div><div class="line">    msg2[<span class="number">1</span>] = <span class="number">3.21</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (rank == src)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Before sending msg1 from proc %d, t = %f\n"</span>, rank, MPI_Wtime());</div><div class="line">        MPI_Bsend(msg1, MSG1LEN, MPI_CHAR, dest, <span class="number">1</span>, comm);</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"After sending msg1 from proc %d, t = %f\n"</span>, rank, MPI_Wtime());</div><div class="line"></div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Before sending msg2 from proc %d, t = %f\n"</span>, rank, MPI_Wtime());</div><div class="line">        MPI_Bsend(msg2, MSG2LEN, MPI_DOUBLE, dest, <span class="number">1</span>, comm);</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"After sending msg2 from proc %d, t = %f\n"</span>, rank, MPI_Wtime());</div><div class="line"></div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Before sending msg3 from proc %d, t = %f\n"</span>, rank, MPI_Wtime());</div><div class="line">        MPI_Bsend(msg3, MSG3LEN, MPI_CHAR, dest, <span class="number">1</span>, comm);</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"After sending msg3 from proc %d, t = %f\n"</span>, rank, MPI_Wtime());</div><div class="line"></div><div class="line">        MPI_Buffer_detach(&amp;buf, &amp;bufsize);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rank == dest)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Before receiving  msg1 on proc %d, t = %f\n"</span>, rank, MPI_Wtime());</div><div class="line">        MPI_Recv(rmsg1, MSG1LEN, MPI_CHAR, src, <span class="number">1</span>, comm, MPI_STATUS_IGNORE);</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"After receiving  msg1 on proc %d, t = %f\n"</span>, rank, MPI_Wtime());</div><div class="line"></div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Before receiving  msg2 on proc %d, t = %f\n"</span>, rank, MPI_Wtime());</div><div class="line">        MPI_Recv(rmsg2, MSG2LEN, MPI_DOUBLE, src, <span class="number">1</span>, comm, MPI_STATUS_IGNORE);</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"After receiving  msg2 on proc %d, t = %f\n"</span>, rank, MPI_Wtime());</div><div class="line"></div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Before receiving  msg3 on proc %d, t = %f\n"</span>, rank, MPI_Wtime());</div><div class="line">        MPI_Recv(rmsg3, MSG3LEN, MPI_CHAR, src, <span class="number">1</span>, comm, MPI_STATUS_IGNORE);</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"After receiving  msg3 on proc %d, t = %f\n"</span>, rank, MPI_Wtime());</div><div class="line"></div><div class="line">        MPI_Buffer_detach(&amp;buf, &amp;bufsize);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(msg1, rmsg1) != <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            errs++;</div><div class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"message 1(%s) should be %s\n"</span>, rmsg1, msg1);</div><div class="line">            fflush(<span class="built_in">stderr</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (rmsg2[<span class="number">0</span>] != msg2[<span class="number">0</span>] || rmsg2[<span class="number">1</span>] != msg2[<span class="number">1</span>])</div><div class="line">        &#123;</div><div class="line">            errs++;</div><div class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</div><div class="line">                    <span class="string">"message 2 incorrect, values are (%f, %f) but should be (%f, %f)\n"</span>,</div><div class="line">                    rmsg2[<span class="number">0</span>], rmsg2[<span class="number">1</span>], msg2[<span class="number">0</span>], msg2[<span class="number">1</span>]);</div><div class="line">            fflush(<span class="built_in">stderr</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(msg3, rmsg3) != <span class="number">0</span>) &#123;</div><div class="line">            errs++;</div><div class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"message 2(%s) should be %s\n"</span>, rmsg3, msg3);</div><div class="line">            fflush(<span class="built_in">stderr</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">free</span>(buf); </div><div class="line"></div><div class="line">    MPI_Finalize();</div><div class="line">            </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码有一些针对缓冲通信模式的新内容：</p>
<ul>
<li><p>获取每个消息所需缓冲区大小</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Pack_size</span><span class="params">(<span class="keyword">int</span> incount,</span></span></div><div class="line">                  MPI_Datatype datatype,</div><div class="line">                  MPI_Comm comm,</div><div class="line">                  <span class="keyword">int</span> *size)</div></pre></td></tr></table></figure>
<p>  使用<code>PACK_SIZE</code>来为每个消息计算其使用buffer的大小。此函数用来返回打包一个消息所需要的最大上限，以字节为单位。</p>
</li>
<li><p>定义缓冲方式需要的总的内存开销上界</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bufsize = <span class="number">3</span>*MPI_BSEND_OVERHEAD + s1 + s2 + s3;</div></pre></td></tr></table></figure>
<blockquote>
<p>The MPI_BSEND_OVERHEAD gives the maximum amount of space that may be used in the buffer for use by the BSEND routines in using the buffer. This value is in mpi.h (for C) and mpif.h (for Fortran).<br>  这样用户就可以自定义用于缓冲通信的缓冲区的大小。</p>
</blockquote>
</li>
<li><p>装配用于通信的缓冲区</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Buffer_attach</span><span class="params">(<span class="keyword">void</span> *buffer, <span class="keyword">int</span> size)</span></span></div></pre></td></tr></table></figure>
<p>  此函数就将用户自己开辟的内存空间注册为一个用于缓冲通信的缓冲区。</p>
</li>
<li><p>移除一个当前存在的用于缓冲通信的缓冲区</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Buffer_detach</span><span class="params">(<span class="keyword">void</span> *buffer_addr, <span class="keyword">int</span> *size)</span></span></div></pre></td></tr></table></figure>
<p>  这里需要注意的是第一个参数<code>void *buffer_addr</code>是个<strong>指针的指针</strong>，这与<code>MPI_Buffer_attach</code>中的参数并不相同<br>  但是这里的移除并不是释放该进程申请的内存，因此在最后还要将内存释放掉。</p>
</li>
</ul>
<p>将这个例子进行编译执行的结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[zjshao@master ch02]$ mpiexec -host node01 -n 2 bsendrecv.x</div><div class="line">Before receiving  msg1 on proc 1, t = 1467968222.659515</div><div class="line">Before sending msg1 from proc 0, t = 1467968222.659531</div><div class="line">After sending msg1 from proc 0, t = 1467968222.659563</div><div class="line">After receiving  msg1 on proc 1, t = 1467968222.659565</div><div class="line">Before receiving  msg2 on proc 1, t = 1467968222.659572</div><div class="line">Before sending msg2 from proc 0, t = 1467968222.659571</div><div class="line">After sending msg2 from proc 0, t = 1467968222.659592</div><div class="line">Before sending msg3 from proc 0, t = 1467968222.659599</div><div class="line">After receiving  msg2 on proc 1, t = 1467968222.659595</div><div class="line">Before receiving  msg3 on proc 1, t = 1467968222.659600</div><div class="line">After sending msg3 from proc 0, t = 1467968222.659616</div><div class="line">After receiving  msg3 on proc 1, t = 1467968222.659619</div><div class="line">[zjshao@master ch02]$</div></pre></td></tr></table></figure></p>
<p>为了能体现缓冲通信模式的特点，加几个阻塞函数在两个进程中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (rank == src)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Before sending msg1 from proc %d, t = %f\n"</span>, rank, MPI_Wtime());</div><div class="line">    MPI_Bsend(msg1, MSG1LEN, MPI_CHAR, dest, <span class="number">1</span>, comm);</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"After sending msg1 from proc %d, t = %f\n"</span>, rank, MPI_Wtime());</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    MPI_Barrier(comm);</div><div class="line"></div><div class="line">    MPI_Buffer_detach(&amp;buf, &amp;bufsize);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (rank == dest)</div><div class="line">&#123;</div><div class="line">    MPI_Barrier(comm);</div><div class="line"></div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Before receiving  msg1 on proc %d, t = %f\n"</span>, rank, MPI_Wtime());</div><div class="line">    MPI_Recv(rmsg1, MSG1LEN, MPI_CHAR, src, <span class="number">1</span>, comm, MPI_STATUS_IGNORE);</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"After receiving  msg1 on proc %d, t = %f\n"</span>, rank, MPI_Wtime());</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    MPI_Buffer_detach(&amp;buf, &amp;bufsize);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>重新编译执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[zjshao@master ch02]$ mpicc bsendrecv.c -o bsendrecv.x</div><div class="line">[zjshao@master ch02]$ mpiexec -host node01 -n 2 bsendrecv.x</div><div class="line">Before sending msg1 from proc 0, t = 1467968941.629696</div><div class="line">After sending msg1 from proc 0, t = 1467968941.629726</div><div class="line">Before sending msg2 from proc 0, t = 1467968941.629733</div><div class="line">After sending msg2 from proc 0, t = 1467968941.629745</div><div class="line">Before sending msg3 from proc 0, t = 1467968941.629750</div><div class="line">After sending msg3 from proc 0, t = 1467968941.629769</div><div class="line">Before receiving  msg1 on proc 1, t = 1467968941.629784</div><div class="line">After receiving  msg1 on proc 1, t = 1467968941.629812</div><div class="line">Before receiving  msg2 on proc 1, t = 1467968941.629818</div><div class="line">After receiving  msg2 on proc 1, t = 1467968941.629823</div><div class="line">Before receiving  msg3 on proc 1, t = 1467968941.629827</div><div class="line">After receiving  msg3 on proc 1, t = 1467968941.629830</div><div class="line">[zjshao@master ch02]$</div></pre></td></tr></table></figure></p>
<p>可见，发送动作可以在执行后立即返回，MPI环境在底层完成了消息的传递，也就是发送动作将数据送达到接收端，进入接受缓冲区，然后返回就好了，接收端会在接受缓冲区中将数据解析完成接受操作。</p>
<p>现在我们把阻塞函数放到发送进程的detach之后：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (rank == src)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Before sending msg1 from proc %d, t = %f\n"</span>, rank, MPI_Wtime());</div><div class="line">    MPI_Bsend(msg1, MSG1LEN, MPI_CHAR, dest, <span class="number">1</span>, comm);</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"After sending msg1 from proc %d, t = %f\n"</span>, rank, MPI_Wtime());</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    MPI_Buffer_detach(&amp;buf, &amp;bufsize);</div><div class="line">    MPI_Barrier(comm);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (rank == dest)</div><div class="line">&#123;</div><div class="line">    MPI_Barrier(comm);</div><div class="line"></div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Before receiving  msg1 on proc %d, t = %f\n"</span>, rank, MPI_Wtime());</div><div class="line">    MPI_Recv(rmsg1, MSG1LEN, MPI_CHAR, src, <span class="number">1</span>, comm, MPI_STATUS_IGNORE);</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"After receiving  msg1 on proc %d, t = %f\n"</span>, rank, MPI_Wtime());</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    MPI_Buffer_detach(&amp;buf, &amp;bufsize);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行结果遇上面相同，也就是说在释放发送端的缓冲区的时候消息一经发送完成，到了接收端的缓冲区中，因此这时候释放发送端缓冲区并不会有什么影响。</p>
<p>当然，如果在发送信息之前进行接受操作，而且在发送前设置阻塞函数，则就会发生死锁：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (rank == src)</div><div class="line">&#123;</div><div class="line">    MPI_Barrier(comm);</div><div class="line"></div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Before sending msg1 from proc %d, t = %f\n"</span>, rank, MPI_Wtime());</div><div class="line">    MPI_Bsend(msg1, MSG1LEN, MPI_CHAR, dest, <span class="number">1</span>, comm);</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"After sending msg1 from proc %d, t = %f\n"</span>, rank, MPI_Wtime());</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    MPI_Buffer_detach(&amp;buf, &amp;bufsize);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (rank == dest)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Before receiving  msg1 on proc %d, t = %f\n"</span>, rank, MPI_Wtime());</div><div class="line">    MPI_Recv(rmsg1, MSG1LEN, MPI_CHAR, src, <span class="number">1</span>, comm, MPI_STATUS_IGNORE);</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"After receiving  msg1 on proc %d, t = %f\n"</span>, rank, MPI_Wtime());</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    MPI_Barrier(comm);</div><div class="line"></div><div class="line">    MPI_Buffer_detach(&amp;buf, &amp;bufsize);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[zjshao@master ch02]$ mpicc bsendrecv.c -o bsendrecv.x</div><div class="line">[zjshao@master ch02]$ mpiexec -host node01 -n 2 bsendrecv.x</div><div class="line">Before receiving  msg1 on proc 1, t = 1467965050.882681</div><div class="line">[mpiexec@master.cluster] Sending Ctrl-C to processes as requested</div><div class="line">[mpiexec@master.cluster] Press Ctrl-C again to force abort</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MPI </tag>
            
            <tag> Parallel Computing </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MPI学习--阻塞通信之标准通信模式]]></title>
      <url>http://pytlab.github.io/2016/07/07/MPI%E5%AD%A6%E4%B9%A0-%E9%98%BB%E5%A1%9E%E9%80%9A%E4%BF%A1%E4%B9%8B%E6%A0%87%E5%87%86%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="阻塞通信"><a href="#阻塞通信" class="headerlink" title="阻塞通信"></a>阻塞通信</h3><p>阻塞通信是指消息发送发的<code>send</code>调用需要接收方的<code>recv</code>调用的配合才可完成。即在发送的消息信封和数据被安全的“保存”起来之前，<code>send</code>函数的调用不会返回。<br>所谓的安全保存，就是指<code>send</code>调用可再次被执行而不会对上一次发送的数据带来任何破坏。<br>不同模式下所要求的“配合”程度也不同，尤其有的MPI环境下还要结合运行时环境本身提供的缓存机制综合考虑实际效果。<br><a id="more"></a></p>
<h3 id="标准通信模式"><a href="#标准通信模式" class="headerlink" title="标准通信模式"></a>标准通信模式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mpi.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 10</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> myid, nprocs, other;</div><div class="line"></div><div class="line">    <span class="comment">// Data sent and received.</span></div><div class="line">    <span class="keyword">int</span> sb[BUF_SIZE], rb[BUF_SIZE];</div><div class="line"></div><div class="line">    MPI_Status status;</div><div class="line"></div><div class="line">    <span class="comment">// Initialize MPI env.</span></div><div class="line">    MPI_Init(&amp;argc, &amp;argv);</div><div class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;myid);    <span class="comment">// Get process id.</span></div><div class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;nprocs);  <span class="comment">// Get total process number.</span></div><div class="line"></div><div class="line">    <span class="comment">// Fill the data array for different process.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BUF_SIZE; ++i)</div><div class="line">    &#123;</div><div class="line">        sb[i] = myid + i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Set another process number.</span></div><div class="line">    <span class="keyword">if</span> (myid == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        other = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (myid == <span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        other = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Send and receive data in proc 0.</span></div><div class="line">    <span class="keyword">if</span> (myid == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"process %d of %d sending data...\n"</span>, myid, nprocs);</div><div class="line">        MPI_Send(sb, BUF_SIZE, MPI_INT, other, <span class="number">1</span>, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"process %d of %d receiving data...\n"</span>, myid, nprocs);</div><div class="line">        MPI_Recv(rb, BUF_SIZE, MPI_INT, other, <span class="number">1</span>, MPI_COMM_WORLD, &amp;status);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Send and receive data in proc 1.</span></div><div class="line">    <span class="keyword">if</span> (myid == <span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"process %d of %d sending data...\n"</span>, myid, nprocs);</div><div class="line">        MPI_Send(sb, BUF_SIZE, MPI_INT, other, <span class="number">1</span>, MPI_COMM_WORLD);</div><div class="line">        </div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"process %d of %d receiving data...\n"</span>, myid, nprocs);</div><div class="line">        MPI_Recv(rb, BUF_SIZE, MPI_INT, other, <span class="number">1</span>, MPI_COMM_WORLD, &amp;status);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Print something.</span></div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Hello world, process %d of %d \n"</span>, myid, nprocs);</div><div class="line"></div><div class="line">    <span class="comment">// Finalize MPI env.</span></div><div class="line">    MPI_Finalize();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用<code>mpicc</code>脚本编译，执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[zjshao@master ch02]$ mpicc -std=c99 std_send_recv.c -o std_send_recv.x</div><div class="line">[zjshao@master ch02]$ mpiexec -n 2 std_send_recv.x</div><div class="line">process 1 of 2 sending data...</div><div class="line">process 1 of 2 receiving data...</div><div class="line">process 0 of 2 sending data...</div><div class="line">process 0 of 2 receiving data...</div><div class="line">Hello world, process 1 of 2 </div><div class="line">Hello world, process 0 of 2</div></pre></td></tr></table></figure></p>
<p>从输出的可以看出，进程1的发送和接受操作要早于进程0，因此进程0发送数据时，进程1可立即进行接收，立即实施传输操作。而进程1在调用recv的时候才开始进行消息传输，之前的进程1的数据存在MPI的缓冲区中。</p>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>我觉得到这里可以总结下缓冲区了。<br>MPI环境定义了3中缓冲区：<strong>应用缓冲区、系统缓冲区、用户向系统注册的缓冲区（通信缓冲区）</strong>。</p>
<h4 id="应用缓冲区"><a href="#应用缓冲区" class="headerlink" title="应用缓冲区"></a>应用缓冲区</h4><p>就是在程序中开辟的内存空间的地址，也就上面代码中的<code>sb</code>和<code>rb</code>分别代表发送数据和接收数据的缓冲区地址，本质上呢就是一个数组的首地址。</p>
<h4 id="系统缓冲区"><a href="#系统缓冲区" class="headerlink" title="系统缓冲区"></a>系统缓冲区</h4><p>是MPI环境为通信所准备的存储空间。类似于一个数据中转站，应用缓冲区的数据在系统缓冲区中复制入和出，即发送数据的时候从系统缓冲区将数据复制到系统缓冲区，接收数据的时候从系统缓冲区复制到应用缓冲区。</p>
<h4 id="用户向系统注册的缓冲区"><a href="#用户向系统注册的缓冲区" class="headerlink" title="用户向系统注册的缓冲区"></a>用户向系统注册的缓冲区</h4><p>是指用户使用某些API（如<code>MPI_Bsend</code>）时，在程序中显式申请的存储空间，然后注册到MPI环境中共通讯所用。</p>
<h3 id="接收和发送信息的几种情况测试"><a href="#接收和发送信息的几种情况测试" class="headerlink" title="接收和发送信息的几种情况测试"></a>接收和发送信息的几种情况测试</h3><h4 id="只有接收没有发送"><a href="#只有接收没有发送" class="headerlink" title="只有接收没有发送"></a>只有接收没有发送</h4><p>将上面的程序进程0的发送消息的部分注释掉：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Send and receive data in proc 0.</span></div><div class="line"><span class="keyword">if</span> (myid == <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//fprintf(stderr, "process %d of %d sending data...\n", myid, nprocs);</span></div><div class="line">    <span class="comment">//MPI_Send(sb, BUF_SIZE, MPI_INT, other, 1, MPI_COMM_WORLD);</span></div><div class="line"></div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"process %d of %d receiving data...\n"</span>, myid, nprocs);</div><div class="line">    MPI_Recv(rb, BUF_SIZE, MPI_INT, other, <span class="number">1</span>, MPI_COMM_WORLD, &amp;status);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Send and receive data in proc 1.</span></div><div class="line"><span class="keyword">if</span> (myid == <span class="number">1</span>)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"process %d of %d sending data...\n"</span>, myid, nprocs);</div><div class="line">    MPI_Send(sb, BUF_SIZE, MPI_INT, other, <span class="number">1</span>, MPI_COMM_WORLD);</div><div class="line">    </div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"process %d of %d receiving data...\n"</span>, myid, nprocs);</div><div class="line">    MPI_Recv(rb, BUF_SIZE, MPI_INT, other, <span class="number">1</span>, MPI_COMM_WORLD, &amp;status);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>则输出的结果是：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[zjshao@master ch02]$ mpiexec -n <span class="number">2</span> std_send_recv_2.x</div><div class="line"><span class="title">process</span> <span class="number">1</span> <span class="keyword">of</span> <span class="number">2</span> sending <span class="class"><span class="keyword">data</span>...</span></div><div class="line"><span class="title">process</span> <span class="number">0</span> <span class="keyword">of</span> <span class="number">2</span> receiving <span class="class"><span class="keyword">data</span>...</span></div><div class="line"><span class="title">process</span> <span class="number">1</span> <span class="keyword">of</span> <span class="number">2</span> receiving <span class="class"><span class="keyword">data</span>...</span></div><div class="line"><span class="type">Hello</span> world, process <span class="number">0</span> <span class="keyword">of</span> <span class="number">2</span> </div><div class="line">[mpiexec@master.cluster] <span class="type">Sending</span> <span class="type">Ctrl</span>-<span class="type">C</span> to processes <span class="keyword">as</span> requested</div><div class="line">[mpiexec@master.cluster] <span class="type">Press</span> <span class="type">Ctrl</span>-<span class="type">C</span> again to force abort</div><div class="line">[zjshao@master ch02]$</div></pre></td></tr></table></figure></p>
<p>程序卡在了进程1接收来自进程0消息的地方无法返回，而进程0这个时候已经将程序执行完毕，输出了HelloWorld。最终只能向进程发送<code>CTRL C</code>来终止MPI进程。</p>
<h4 id="只有发动没有接收"><a href="#只有发动没有接收" class="headerlink" title="只有发动没有接收"></a>只有发动没有接收</h4><p>将上面的程序进程1的接收消息的部分注释掉：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Send and receive data in proc 0.</span></div><div class="line"><span class="keyword">if</span> (myid == <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"process %d of %d sending data...\n"</span>, myid, nprocs);</div><div class="line">    MPI_Send(sb, BUF_SIZE, MPI_INT, other, <span class="number">1</span>, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"process %d of %d receiving data...\n"</span>, myid, nprocs);</div><div class="line">    MPI_Recv(rb, BUF_SIZE, MPI_INT, other, <span class="number">1</span>, MPI_COMM_WORLD, &amp;status);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Send and receive data in proc 1.</span></div><div class="line"><span class="keyword">if</span> (myid == <span class="number">1</span>)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"process %d of %d sending data...\n"</span>, myid, nprocs);</div><div class="line">    MPI_Send(sb, BUF_SIZE, MPI_INT, other, <span class="number">1</span>, MPI_COMM_WORLD);</div><div class="line">    </div><div class="line">    <span class="comment">//fprintf(stderr, "process %d of %d receiving data...\n", myid, nprocs);</span></div><div class="line">    <span class="comment">//MPI_Recv(rb, BUF_SIZE, MPI_INT, other, 1, MPI_COMM_WORLD, &amp;status);</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>则输出的结果是：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[zjshao@master ch02]$ mpiexec -n <span class="number">2</span> std_send_recv_2.x</div><div class="line"><span class="title">process</span> <span class="number">1</span> <span class="keyword">of</span> <span class="number">2</span> sending <span class="class"><span class="keyword">data</span>...</span></div><div class="line"><span class="title">process</span> <span class="number">0</span> <span class="keyword">of</span> <span class="number">2</span> sending <span class="class"><span class="keyword">data</span>...</span></div><div class="line"><span class="type">Hello</span> world, process <span class="number">1</span> <span class="keyword">of</span> <span class="number">2</span> </div><div class="line"><span class="title">process</span> <span class="number">0</span> <span class="keyword">of</span> <span class="number">2</span> receiving <span class="class"><span class="keyword">data</span>...</span></div><div class="line"><span class="type">Hello</span> world, process <span class="number">0</span> <span class="keyword">of</span> <span class="number">2</span> </div><div class="line">[zjshao@master ch02]$</div></pre></td></tr></table></figure></p>
<p>这个时候两个进程都自行结束了，这个应该就想到于发送动作遭遇接收动作，这个时候消息大小小于MPI的缓冲区大小，会将数据传输到MPI缓冲区中进行缓存，然后函数立即返回，这样进程就不会开在发送数据部分无法将程序的拥有权交给主程序。</p>
<p><strong>但如果我将应用缓冲区大小增大，使其大于系统缓冲区大小，会出现什么情况呢？</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100000</span></div></pre></td></tr></table></figure></p>
<p>修改好编译执行:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[zjshao@master ch02]$ mpicc -std=c99 std_send_recv.c -o std_send_recv_2.x</div><div class="line">[zjshao@master ch02]$ mpiexec -host node01 -n 2 std_send_recv_2.x</div><div class="line">process 1 of 2 sending data...</div><div class="line">process 0 of 2 sending data...</div><div class="line">[mpiexec@master.cluster] Sending Ctrl-C to processes as requested</div><div class="line">[mpiexec@master.cluster] Press Ctrl-C again to force abort</div><div class="line">[zjshao@master ch02]$</div></pre></td></tr></table></figure></p>
<div class="alert alert-warning"><i class="fa fa-bell"></i>  果然，如果发送的数据大于系统缓冲区大小，则进程要等待接收方进程接收动作启动后才开始数据传输。但是在这里，进程1先发送了数据，数据不能进入系统缓冲区，要等待进程0的接收动作，这时候进程0也发送了数据，同理，要等待进程1的接收动作，但是进程0要等进程1，进程1又要等进程0，这个时候就卡死了，也就是发生了死锁。</div>
<p>以上就是我对阻塞通信中的标准通信模式的总结了。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MPI </tag>
            
            <tag> Parallel Computing </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MPI学习--消息传递通信]]></title>
      <url>http://pytlab.github.io/2016/07/06/MPI%E5%AD%A6%E4%B9%A0--%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E9%80%9A%E4%BF%A1/</url>
      <content type="html"><![CDATA[<h3 id="MPI的工作模式"><a href="#MPI的工作模式" class="headerlink" title="MPI的工作模式"></a>MPI的工作模式</h3><p>目前我对MPI的工作模式的理解就是他其实呢是把一份程序传送到不同的进程中，通过MPI的接口我们可以获取当前进程中的一些信息，例如进程号，进程总数等，这样我们就可以在程序中显式的对进程信息进行判断，然后做不同的处理，这样同一份程序在不同的进程中做的事情是不一样的，尽管代码（变量，函数等）都是一样的，可见这种并行的粒度是很大的。</p>
<p>下面引用下书里的一段话：</p>
<blockquote>
<p>MPI程序工作模式<br>在不同工作模式下可以适合SPMD或者MPMD等体系结构。以串行方式编写，运行时分别执行不同的块。</p>
</blockquote>
<p>这里的不同的块其实就是通过MPI提供的接口获取的进程信息进而写出的条件判断语句。</p>
<a id="more"></a>
<blockquote>
<p>所有程序元素，只要没进行显式区分，不论是代码，函数，全局变量还是局部变量，都默认的有全部进程所共有，所有进程里看到的虽然是相同的名字，但在“物理”上却彼此无关。同一个变量，在不同的进程空间看来，是物理上互不联系的，属于各个进程的私有变量。当然，从语义角度看，在逻辑上他们则应属于描述同一事物的不同部分，或同为构成事物模型的某种属性/特征等。</p>
</blockquote>
<p>上面这段虽然说的很高大上，但是本质还是我最开始理解的那些啦。<br><div class="alert alert-info"><i class="fa fa-info"></i>  MPI程序编写的难点就在于显式的条件判断来制定不同进程上执行的不同的代码块。</div></p>
<h3 id="MPI消息传递"><a href="#MPI消息传递" class="headerlink" title="MPI消息传递"></a>MPI消息传递</h3><p>这里我就总结下MPI的消息部分。<br>在通信过程中，MPI消息被封装在“信封”中，然后经过MPI环境自己的缓冲区在交由网络传输层打包发送。<br>基本的MPI消息传递封装大致代码总结可以如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mpi.h"</span></span></div><div class="line"></div><div class="line"><span class="comment">// 初始化MPI环境</span></div><div class="line">MPI_Init(&amp;argc, &amp;argv);</div><div class="line"></div><div class="line"><span class="comment">// 获取当前进程的进程号</span></div><div class="line">MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);</div><div class="line"></div><div class="line"><span class="comment">// 获取当前所有进程个数</span></div><div class="line">MPI_Comm_size(MPI_COMM_WORLD, &amp;size);</div><div class="line"></div><div class="line">MPI_Send(buf, size, datatype, target, tag, MPI_COMM_WORLD);</div><div class="line">MPI_Recv(buf, size, datatype, source, tag, MPI_COMM_WORLD, &amp;status);</div><div class="line"></div><div class="line">MPI_Finalize();</div></pre></td></tr></table></figure></p>
<p>通过发送和接收消息的接口参数就可以看出，这些消息可以跟信件的收发一一联系起来。<br><code>buf</code>, <code>size</code>, <code>datatype</code>：这些是被信封包起来的数据部分。<br><code>target</code>：是收件人的信息，即邮编和地址，收件人姓名等。<br><code>source</code>：是寄件人的信息，邮编、地址、姓名等。<br><code>tag</code>：邮戳，这样就可以区分信件的顺序。<br><code>MPI_COMM_WORLD</code>：邮局名称，收发信件通过的邮局。</p>
<p>上面代码中有个<code>status</code>，他是一个MPI定义的结构，用来保存执行结果（状态）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> MPI_Status &#123;</div><div class="line">    <span class="keyword">int</span> <span class="built_in">cout</span>;        <span class="comment">// 记录发送/接收的字节数</span></div><div class="line">    <span class="keyword">int</span> cancelled;</div><div class="line">    <span class="keyword">int</span> MPI_SOURCE;  <span class="comment">// 记录接收消息的源进程</span></div><div class="line">    <span class="keyword">int</span> MPI_TAG;     <span class="comment">// 记录消息的标志值</span></div><div class="line">    <span class="keyword">int</span> MPI_ERROR;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>当我们使用<code>MPI_ANY_SOURCE</code>和<code>MPI_ANY_TAG</code>的时候可以通过这个结构来判断接收到的数据来源。</p>
<h3 id="点到点通信"><a href="#点到点通信" class="headerlink" title="点到点通信"></a>点到点通信</h3><p>点到点通信要求必须有<code>send</code>和<code>recv</code>配对。消息通信的数据传递流程如下：</p>
<ol>
<li>发送端发起数据发送调用<code>MPI_??Send</code></li>
<li>MPI环境从发送缓冲区提取要发送的数据，据此组装发送消息。</li>
<li>将组装的消息发动个目标进程。</li>
<li>接收端收取可匹配的消息，并将其解析到自己的接收缓冲区中。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MPI </tag>
            
            <tag> Parallel Computing </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MPI学习--并行系统和并行模式]]></title>
      <url>http://pytlab.github.io/2016/07/06/MPI%E5%AD%A6%E4%B9%A0-%E5%B9%B6%E8%A1%8C%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%B9%B6%E8%A1%8C%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>当然现在的目的还是为了学习MPI，不过事实上MPI并不能完全的算作是理想意义上的并行编程模型，它只是提供了一种<strong>粗粒度</strong>的并行机制，而在进程的粒度上看，MPI程序仍是并行的。</p>
<h2 id="并行系统"><a href="#并行系统" class="headerlink" title="并行系统"></a>并行系统</h2><h3 id="Flynn分类法-–-按指令-数据模式的分类"><a href="#Flynn分类法-–-按指令-数据模式的分类" class="headerlink" title="Flynn分类法 – 按指令/数据模式的分类"></a>Flynn分类法 – 按指令/数据模式的分类</h3><p>从处理器指令级别的并行来考察的话，Flynn依据指令和数据流的不同给出计算机的分类，例如SIMD和MIMD。<br>关于什么是单指令多数据流和多指令多数据流，我在<a href="https://www.quora.com/Parallel-Computing-What-is-the-difference-between-SIMD-and-MIMD" target="_blank" rel="external">quora</a>上面搜到了个不错的解释：</p>
<p></p><p></p>
<blockquote>
<p>SIMD and MIMD are types of parallel architectures identified in Flynn’s taxonomy, which basically says that computers have single (S) or multiple (M) streams of instructions (I) and data (D), leading to four types of computers: SISD, SIMD, MISD, and MIMD. Let’s skip SISD and MISD, since the question doesn’t ask about them, and neither is spectacularly interesting.<br><a id="more"></a></p>
<p>Single Instruction Multiple Data (SIMD) means that all parallel units share the same instruction, but they carry it out on different data elements. The idea is that you can, say, add the arrays [1,2,3,4] and [5,6,7,8] element-wise to obtain the array [6,8,10,12] in one big whoop: for this, there have to be four arithmetic units at work, but they can all share the same instruction (here, “add”), and work by all performing the same actions in tight, lock-step synchronicity. This usually means putting multiple data-manipulation thingies inside the same processing core as one instruction decoder, for the sake of the tight timekeeping.</p>
<p>Here’s a picture of a SIMD kind of sports teamwork, for illustration:</p>
<p><img src="/assets/images/blog_img/2016-07-06-MPI学习-并行系统和并行模式/SIMD.png" alt=""></p>
<p>Multiple Instruction Multiple Data (MIMD) means that parallel units have separate instructions, so each of them can do something different at any given time; one may be adding, another multiplying, yet another evaluating a branch condition, and so on. This is the sort of parallelism you get with threads, which basically let programs dispatch an entire function call to run on a different processor. This means involving multiple fully-featured, independent processing cores, whether they are on the same chip (multi-core), different ones (multi-processor), or a mixture of the two.</p>
<p>Here’s a picture of a MIMD kind of sports teamwork, for illustration:</p>
<p><img src="/assets/images/blog_img/2016-07-06-MPI学习-并行系统和并行模式/MIMD.png" alt=""></p>
</blockquote>
<p>接着上面，随着体系结构的发展，MIMD体系有进一步划分为：</p>
<ol>
<li>多计算机多地址空间消息传递计算系统<ul>
<li>分布式多计算机系统</li>
<li>集中式多计算机系统</li>
</ul>
</li>
<li>多计算机单地址空间共享存储计算系统<ul>
<li>分布存储的共享存储系统</li>
<li>集中存储的共享存储系统</li>
</ul>
</li>
</ol>
<h3 id="对称多处理器系统-SMP"><a href="#对称多处理器系统-SMP" class="headerlink" title="对称多处理器系统(SMP)"></a>对称多处理器系统(SMP)</h3><p><img src="/assets/images/blog_img/2016-07-06-MPI学习-并行系统和并行模式/SMP.png" alt=""><br>典型的,只一个系统(节点)内多个处理器共享内存的形式, 各处理器具等的战友总线和内存访问机会。广义上，多核处理器就是出于这一范畴。在一个节点内部可多线程或者多进程的执行并行作业。多线程的话就是通过隐式通信，多进程则应使用某种特殊机制。</p>
<h3 id="集群计算机系统"><a href="#集群计算机系统" class="headerlink" title="集群计算机系统"></a>集群计算机系统</h3><p>从分类上看，可以将集群计算机归属于分布式存储的MPMD/MIMD机型。采用自制的SIMD计算机或者SMP计算机为节点，通过高速网络互联组织。</p>
<h3 id="向量机"><a href="#向量机" class="headerlink" title="向量机"></a>向量机</h3><p>现代体系结构设计已经把向量操作指令集集成到了处理器硬件逻辑中，有些SIMD指令也支持向量操作。在向量机节点或以向量机为节点组成的集群系统中也能支持MPI规范。</p>
<h2 id="并行编程模式"><a href="#并行编程模式" class="headerlink" title="并行编程模式"></a>并行编程模式</h2><h3 id="隐式并行"><a href="#隐式并行" class="headerlink" title="隐式并行"></a>隐式并行</h3><p>借助编译器和运行时环境的支持发掘程序并行性，对穿行程序进行并行化，关键是分心程序的数据相关和控制相关，如果存在相关性则需要采用转换技术（重构/优化）将其删除。话说上次的MIC培训其实就是在将这些优化策略。</p>
<h3 id="数据并行"><a href="#数据并行" class="headerlink" title="数据并行"></a>数据并行</h3><p>数据并行依靠所处理数据集合无关性，借助数据规划分来驱动程序之间的并行执行。该类型的并行主要强调局部计算和数据划分，执行流程之间的同步需要在编译阶段加以显式规划。</p>
<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>消息传递模型可通过如下几个概念加以定义：</p>
<ul>
<li>一组仅有本地内存空间的进程；</li>
<li>进程之间通过发送和接受消息进行通信；</li>
<li>进程之间需要使用协同操作完成数据传递，如发送操作必须要求有与之配对的接受操作。</li>
</ul>
<p>消息传递模型的主要缺点：要求在编程过程中参与显示的数据划分和进程间同步，因此会需要在解决数据依赖和预防死锁等问题上花费很大精力。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Parallel Computing </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MPI学习--MPICH并行环境搭建与配置]]></title>
      <url>http://pytlab.github.io/2016/07/05/MPI%E5%AD%A6%E4%B9%A0%E4%B9%8BMPICH2%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<p>这篇主要记录使用自己用户在实验室的IBM刀片集群上搭建MPI并行环境以及简单的测试，具体什么是MPI这里就不多讲了，主要记录自己的MPI环境的搭建过程。</p>
<h3 id="下载MPICH"><a href="#下载MPICH" class="headerlink" title="下载MPICH"></a>下载MPICH</h3><p>现在<a href="http://www.mpich.org/downloads/" target="_blank" rel="external">MPICH官网</a>上已经有MPICH3.2，但是安装了以后发现3.2的进程管理器并没有mpd而是<a href="https://wiki.mpich.org/mpich/index.php/Using_the_Hydra_Process_Manager" target="_blank" rel="external">Hydra Process Manager</a>为了用上最新的我也就直接上最新版了肯定不会有错。</p>
<p>下下来的压缩包为: <code>mpich-3.2.tar.gz</code><br><a id="more"></a></p>
<h3 id="编译和安装"><a href="#编译和安装" class="headerlink" title="编译和安装"></a>编译和安装</h3><h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tar zxvf mpich-3.2.tar.gz</div><div class="line">cd mpich-3.2</div></pre></td></tr></table></figure>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>MPICH提供了很多的配置选项，可以通过如下命令查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure -h</div></pre></td></tr></table></figure></p>
<p>使用默认的进程管理器以及支持调式，参数设置为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./configure CC=gcc CXX=g++ --prefix=/data/home/zjshao/hpc/mpich-install --enable-debuginfo --enable-fast=all 2&gt;&amp;1 | tee c.txt</div><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure></p>
<p>然后就要经过漫长的编译过程 - -！。</p>
<p>设置环境变量：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PATH=<span class="regexp">/data/</span>home<span class="regexp">/zjshao/</span>hpc/mpich-<span class="string">install:</span>$PATH</div></pre></td></tr></table></figure></p>
<h3 id="配置和验证"><a href="#配置和验证" class="headerlink" title="配置和验证"></a>配置和验证</h3><p>MPI进程的创建、启动和管理需要借助进程管理器来完成，直观的讲PM就是MPI环境与操作系统的接口。<br>正常MPI会在多个主机上启动进程管理器进程，形成MPI运行时的环境，这样目标主机就需要配置集群环境支持节点间无密码登录，这里的原理主要是通过密钥进行身份验证的方式，由于实验室的集群上已经对这里进行了配置，我就不再进行配置了。</p>
<p>在安装目录下面的<code>/example</code>中有一个数值求pi的程序<code>cpi</code>可以帮助我们来运行验证MPI环境是否正确的安装和运行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[zjshao@master examples]$ which mpiexec</div><div class="line">~/hpc/mpich-install/bin/mpiexec</div></pre></td></tr></table></figure></p>
<p>测试在主节点进行并行<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[zjshao@master examples]$ mpiexec -n <span class="number">4</span> ./cpi</div><div class="line">Process <span class="number">0</span> <span class="keyword">of</span> <span class="number">4</span> <span class="keyword">is</span> <span class="keyword">on</span> master.cluster</div><div class="line">Process <span class="number">1</span> <span class="keyword">of</span> <span class="number">4</span> <span class="keyword">is</span> <span class="keyword">on</span> master.cluster</div><div class="line">Process <span class="number">2</span> <span class="keyword">of</span> <span class="number">4</span> <span class="keyword">is</span> <span class="keyword">on</span> master.cluster</div><div class="line">Process <span class="number">3</span> <span class="keyword">of</span> <span class="number">4</span> <span class="keyword">is</span> <span class="keyword">on</span> master.cluster</div><div class="line"><span class="literal">pi</span> <span class="keyword">is</span> approximately <span class="number">3.1415926544231239</span>, Error <span class="keyword">is</span> <span class="number">0.0000000008333307</span></div><div class="line">wall clock <span class="built_in">time</span> = <span class="number">0.000315</span></div></pre></td></tr></table></figure></p>
<p>在计算节点node01上运行6个进程<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[zjshao@master examples]$ mpiexec -host node01 -n <span class="number">4</span> ./cpi</div><div class="line">Process <span class="number">0</span> <span class="keyword">of</span> <span class="number">4</span> <span class="keyword">is</span> <span class="keyword">on</span> node01</div><div class="line">Process <span class="number">2</span> <span class="keyword">of</span> <span class="number">4</span> <span class="keyword">is</span> <span class="keyword">on</span> node01</div><div class="line">Process <span class="number">3</span> <span class="keyword">of</span> <span class="number">4</span> <span class="keyword">is</span> <span class="keyword">on</span> node01</div><div class="line">Process <span class="number">1</span> <span class="keyword">of</span> <span class="number">4</span> <span class="keyword">is</span> <span class="keyword">on</span> node01</div><div class="line"><span class="literal">pi</span> <span class="keyword">is</span> approximately <span class="number">3.1415926544231239</span>, Error <span class="keyword">is</span> <span class="number">0.0000000008333307</span></div><div class="line">wall clock <span class="built_in">time</span> = <span class="number">0.000119</span></div></pre></td></tr></table></figure></p>
<p>接下来通过文件制定环境中节点和进程信息<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[zjshao@master examples]$ cat &gt; hosts &lt;&lt;!</div><div class="line">&gt; node01:<span class="number">2</span></div><div class="line">&gt; node02:<span class="number">4</span></div><div class="line">&gt; node03:<span class="number">6</span></div><div class="line">&gt; !</div><div class="line">[zjshao@master examples]$ mpiexec -machinefile hosts -n <span class="number">8</span> cpi</div><div class="line">Process <span class="number">1</span> <span class="keyword">of</span> <span class="number">8</span> <span class="keyword">is</span> <span class="keyword">on</span> node01</div><div class="line">Process <span class="number">6</span> <span class="keyword">of</span> <span class="number">8</span> <span class="keyword">is</span> <span class="keyword">on</span> node03</div><div class="line">Process <span class="number">0</span> <span class="keyword">of</span> <span class="number">8</span> <span class="keyword">is</span> <span class="keyword">on</span> node01</div><div class="line">Process <span class="number">7</span> <span class="keyword">of</span> <span class="number">8</span> <span class="keyword">is</span> <span class="keyword">on</span> node03</div><div class="line">Process <span class="number">5</span> <span class="keyword">of</span> <span class="number">8</span> <span class="keyword">is</span> <span class="keyword">on</span> node02</div><div class="line">Process <span class="number">2</span> <span class="keyword">of</span> <span class="number">8</span> <span class="keyword">is</span> <span class="keyword">on</span> node02</div><div class="line">Process <span class="number">4</span> <span class="keyword">of</span> <span class="number">8</span> <span class="keyword">is</span> <span class="keyword">on</span> node02</div><div class="line">Process <span class="number">3</span> <span class="keyword">of</span> <span class="number">8</span> <span class="keyword">is</span> <span class="keyword">on</span> node02</div><div class="line"><span class="literal">pi</span> <span class="keyword">is</span> approximately <span class="number">3.1415926544231247</span>, Error <span class="keyword">is</span> <span class="number">0.0000000008333316</span></div><div class="line">wall clock <span class="built_in">time</span> = <span class="number">0.003747</span></div></pre></td></tr></table></figure></p>
<h4 id="查看mpi编译器信息"><a href="#查看mpi编译器信息" class="headerlink" title="查看mpi编译器信息"></a>查看mpi编译器信息</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[zjshao<span class="meta">@master</span> examples]$ mpichversion </div><div class="line">MPICH <span class="string">Version:</span>    	<span class="number">3.2</span></div><div class="line">MPICH Release <span class="string">date:</span>	Wed Nov <span class="number">11</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">48</span> CST <span class="number">2015</span></div><div class="line">MPICH <span class="string">Device:</span>    	<span class="string">ch3:</span>nemesis</div><div class="line">MPICH <span class="string">configure:</span> 	CC=gcc CXX=g++ --prefix=<span class="regexp">/data/</span>home<span class="regexp">/zjshao/</span>hpc/mpich-install --enable-debuginfo --enable-fast=all</div><div class="line">MPICH <span class="string">CC:</span> 	gcc    -DNDEBUG -DNVALGRIND -O2</div><div class="line">MPICH <span class="string">CXX:</span> 	g++   -DNDEBUG -DNVALGRIND -O2</div><div class="line">MPICH <span class="string">F77:</span> 	ifort   -O2</div><div class="line">MPICH <span class="string">FC:</span> 	ifort   -O2</div></pre></td></tr></table></figure>
<p>其实看一下所谓的<code>mpicc</code>和<code>mpicxx</code>等，其实是一个shell的脚本，他会根据在编译前配置时候的信息自动生成，包括编译器，编译参数，头文件地址和库文件路径等。<br>例如mpicxx中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="comment"># Directory locations: Fixed for any MPI implementation</span></div><div class="line">prefix=/data/home/zjshao/hpc/mpich-install</div><div class="line">exec_prefix=/data/home/zjshao/hpc/mpich-install</div><div class="line">sysconfdir=/data/home/zjshao/hpc/mpich-install/etc</div><div class="line">includedir=/data/home/zjshao/hpc/mpich-install/include</div><div class="line">libdir=/data/home/zjshao/hpc/mpich-install/lib</div><div class="line"></div><div class="line"><span class="comment"># Default settings for compiler, flags, and libraries</span></div><div class="line">CXX=<span class="string">"g++"</span></div><div class="line">MPICH_VERSION=<span class="string">"3.2"</span></div><div class="line"></div><div class="line">enable_wrapper_rpath=<span class="string">"yes"</span></div><div class="line"></div><div class="line"><span class="comment"># How to pass a linker flag through the compiler.</span></div><div class="line">wl=<span class="string">"-Wl,"</span></div><div class="line"></div><div class="line"><span class="comment"># Static library suffix (normally "a").</span></div><div class="line">libext=<span class="string">"a"</span></div><div class="line"></div><div class="line"><span class="comment"># Shared library suffix (normally "so").</span></div><div class="line">shlibext=<span class="string">"so"</span></div><div class="line"></div><div class="line"><span class="comment"># Format of library name prefix.</span></div><div class="line">libname_spec=<span class="string">"lib\$name"</span></div><div class="line">...</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>同理mpif90, mpicc都是。</p>
<hr>
<p>好了，目前MPI的环境基本上已经可以正确的运行啦。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MPI </tag>
            
            <tag> Parallel Computing </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[发现KMCLib中一个隐藏bug]]></title>
      <url>http://pytlab.github.io/2016/07/05/%E5%8F%91%E7%8E%B0KMCLib%E4%B8%AD%E4%B8%80%E4%B8%AA%E9%9A%90%E8%97%8Fbug/</url>
      <content type="html"><![CDATA[<p>由于为了看自己的KMCLibX是不是能跑出正确的结果，我将每一个蒙特卡洛步的configuration进行了散点图，来观察每一步事件的选取和configuration发生的变化，把事件全部定义好以后，跑了500步做了下图就发现，吸附在top位的O有落单的现象，明明我没有在事件中定义过有破坏平躺吸附在表面的氧原子的事件啊，这就奇怪了。于是我就将做图的范围缩窄，逐渐定位到了是哪一步开始出现单个top位上的氧原子。<br>如下图，是发生在第27步的时候，直接会有一个氧分子直接变成吸附在bridge site上的CO：<br><a id="more"></a><br><img src="/assets/images/blog_img/2016-07-05-发现KMCLib中一个隐藏bug/configuration26.png" alt=""><br><img src="/assets/images/blog_img/2016-07-05-发现KMCLib中一个隐藏bug/configuration27.png" alt=""></p>
<p>这看着就知道是一个CO吸附，但是强制发生了，也就是说明在执行第27步的时候，第225个点是在process28中的（别问我为什么知道是第几个事件第几个位点上，亲自写代码自然会知道）。所以这就是一个bug，在进行事件发生后的局部收到影响位点上没能够正确的重新进行匹配(re-matching)。</p>
<p>找来找去，原来发现原始的KMCLib中在singleStep()中执行每一步选中的事件之后会保存所谓的AffectedIndices说明这些点在上次迭代的时候发生了改变，那么这些点的某一范围内的点都应该对所有事件重新进行匹配来更新事件中的相应数据。那么关键就在于这个<strong>范围</strong>了，原始代码中是这样的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> LatticeModel::singleStep()</div><div class="line">&#123;</div><div class="line">    <span class="comment">// Select a process.</span></div><div class="line">    Process &amp; process = (*interactions_.pickProcess());</div><div class="line"></div><div class="line">    <span class="comment">// Select a site.</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> site_index = process.pickSite();</div><div class="line"></div><div class="line">    <span class="comment">// Perform the operation.</span></div><div class="line">    configuration_.performProcess(process, site_index);</div><div class="line"></div><div class="line">    <span class="comment">// Propagate the time.</span></div><div class="line">    simulation_timer_.propagateTime(interactions_.totalRate());</div><div class="line"></div><div class="line">    <span class="comment">// Run the re-matching of the affected sites and their neighbours.</span></div><div class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; indices = \</div><div class="line">        lattice_map_.supersetNeighbourIndices(process.affectedIndices(), process.range());</div><div class="line"></div><div class="line">    matcher_.calculateMatching(interactions_,</div><div class="line">                               configuration_,</div><div class="line">                               sitesmap_,</div><div class="line">                               lattice_map_,</div><div class="line">                               indices);</div><div class="line"></div><div class="line">    <span class="comment">// Update the interactions' probability table.</span></div><div class="line">    interactions_.updateProbabilityTable();</div><div class="line"></div><div class="line">    <span class="comment">// Update the interactions' process available sites.</span></div><div class="line">    interactions_.updateProcessAvailableSites();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到在第行上，进行更新的范围是当前选中并发生的事件，问题就在这里了，每个事件在定义的时候即使在后面的interaction类中进行了通配符的补全，但是范围是个数值并没有改变，所以这里如果正好选择的是一个小range的事件，而他周围有正好有个大range的事件包含了这个点，那么小range的更新就无法触及大range的事件，则大range的事件仍然认为某些实际不能发生的事件还是可以发生的，也就是上面图中的现象。<br><br><br>所以正确的修改应该是在每次求超集的时候都按照所有事件的最大范围来求，即<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Run the re-matching of the affected sites and their neighbours.</span></div><div class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; indices = \</div><div class="line">    lattice_map_.supersetNeighbourIndices(process.affectedIndices(),</div><div class="line">                                          interactions_.maxRange());</div></pre></td></tr></table></figure></p>
<p>这的确是个隐藏bug，因为KMC跑起来是很难知道到底对不对的，只有通过作图一步一步观察才知道。</p>
<p>针对这个bug我想KMCLib提交了一个PR，如今已经被合并，链接：<a href="https://github.com/leetmaa/KMCLib/pull/8" target="_blank" rel="external"><span class="fa fa-github"></span> Fix bug in re-matching of affected indices. by PytLab · Pull Request #8 · leetmaa/KMCLib</a></p>
]]></content>
      
        <categories>
            
            <category> 学术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> catalysis </tag>
            
            <tag> kMC </tag>
            
            <tag> Monte Carlo </tag>
            
            <tag> KMCLib </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[决定给KMCLibX添加分子取向识别]]></title>
      <url>http://pytlab.github.io/2016/07/02/%E5%86%B3%E5%AE%9A%E7%BB%99KMCLibX%E6%B7%BB%E5%8A%A0%E5%88%86%E5%AD%90%E5%8F%96%E5%90%91%E8%AF%86%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>之前以为做CO Oxidation不需要进行分子取向的匹配，但是以为实际开始运行程序之后观察点阵图发现，图中出现了异常的局部configuration，导致出现某个区域的反应物像中毒一样固定在表面无法参与反应，仔细想了想，是因为没有添加分子取向的匹配导致发生脱附的时候破坏了分子在表面的完整性。<br>于是本来要给程序添加MPI的计划泡汤了，要将KMCLibX从头到尾大改以支持分子取向的匹配，希望一周能搞定。</p>
<p>PS. 暂时把KMCLibX在GitHub上变成了私有仓库，等文章搞定前后会再次开放源代码。</p>
]]></content>
      
        <categories>
            
            <category> 学术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> catalysis </tag>
            
            <tag> chemistry </tag>
            
            <tag> Cpp </tag>
            
            <tag> kMC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++ 11 中的右值引用和移动语义小结]]></title>
      <url>http://pytlab.github.io/2016/06/26/C-11-%E4%B8%AD%E7%9A%84%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="左值-amp-右值"><a href="#左值-amp-右值" class="headerlink" title="左值 &amp; 右值"></a>左值 &amp; 右值</h2><p>首先还是这个老问题，什么是左值，什么是右值？<br>最原始的区分就是左值是可以出现在赋值符的左边和右边，然而右值只能出现在赋值符的右边。但是在C++中使用前面的方式来区别左值和右值就不合适了，那么在C++中要怎么区别呢？我的理解是：</p>
<ol>
<li>左值是一个表示数据的表达式（如变量名或者解除引用的指针），<strong>程序可以获取它的地址</strong>。</li>
<li>右值是可以出现在表达式的右边的，<strong>但不能对其应用取址运算符的值</strong>。</li>
</ol>
<p>在 <a href="http://stackoverflow.com/questions/3106110/what-are-move-semantics" target="_blank" rel="external">StackOverflow上面看到一个回答</a> 里面使用了个例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">std::string a(x);                                    // Line 1</div><div class="line">std::string b(x + y);                                // Line 2</div><div class="line">std::string c(some_function_returning_a_string());   // Line 3</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>上面的这些都是进行字符串的复制。但是只有第一个是真正需要深复制的，因为我们在复制之后还是<strong>需要使用变量<code>x</code>的</strong>（我们会使用<code>x</code>进行运算或者进行取址等），所以如果我们在进行复制到<code>a</code>的时候将<code>x</code>的值进行了改变，这显然不是我们想要的！<br>第二行和第三行的函数中的参数则不是左值，这些参数并没有名字，我们也不可能在后面的程序中在对这个值进行进一步的操作（连名字都没了让我怎么找）。<br><div class="alert alert-info"><i class="fa fa-info"></i>  因此右值是一种临时的数据对象，这个临时数据对象没有绑定到任何对象/变量，在<strong>遇到下一个分号的时候已经销毁掉了！</strong></div></p>
<p>C++11中对左值和右值的界定中添加了一个新的类型叫<code>xvalue</code>(eXpiring value, 临终值)<br>具体的关系图如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">        expressions</div><div class="line">          /     \</div><div class="line">         /       \</div><div class="line">        /         \</div><div class="line">    glvalues   rvalues</div><div class="line">      /  \       /  \</div><div class="line">     /    \     /    \</div><div class="line">    /      \   /      \</div><div class="line">lvalues   xvalues   prvalues</div></pre></td></tr></table></figure></p>
<h3 id="lvalue-左值"><a href="#lvalue-左值" class="headerlink" title="lvalue(左值)"></a>lvalue(左值)</h3><p>代指一个函数或者对象，例如：</p>
<ol>
<li><code>E</code>是指针，则<code>*E</code>是lvalue</li>
<li>一个函数的返回值是左值引用，其返回值是lvalue。例如<code>int&amp; foo();</code></li>
</ol>
<h3 id="xvalue-eXpiring-value-临终值"><a href="#xvalue-eXpiring-value-临终值" class="headerlink" title="xvalue(eXpiring value, 临终值)"></a>xvalue(eXpiring value, 临终值)</h3><blockquote>
<p>Xvalues are a new kind of value category for unnamed rvalue references.</p>
</blockquote>
<p>xvalue代指一个对象，但是和左值不同，这个对象即将消亡。具体来说，xvalue是包含了右值引用的表达式。例如，一个返回值是右值引用的函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">prvalue</span><span class="params">()</span></span>;    <span class="comment">// 纯右值</span></div><div class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">lvalue</span><span class="params">()</span></span>;   <span class="comment">// 左值</span></div><div class="line"><span class="function"><span class="keyword">int</span> &amp;&amp; <span class="title">xvalue</span><span class="params">()</span></span>;  <span class="comment">// 临终值</span></div></pre></td></tr></table></figure></p>
<div class="alert alert-info"><i class="fa fa-info"></i>  <br>
我对xvalue的理解，就是它是一个中间值，明明一开始一个<strong>右值</strong>，也就是个临时变量，但是我们将它返回成一个右值引用，右值引用能够使其与特定的地址关联，也就是分配给了一个对象，感觉忽然变成了<strong>左值</strong>一样，但是如果我们没有将其赋值，这个数据还是没有名字，也会随之消失，还是一个<strong>右值</strong>。
<br>
感觉像是纯右值和左值的<strong>叠加态</strong>一样。（不知道自己理解的对不对）</div>
<h3 id="glvalue-generalized-lvalue-泛左值"><a href="#glvalue-generalized-lvalue-泛左值" class="headerlink" title="glvalue(generalized lvalue, 泛左值)"></a>glvalue(generalized lvalue, 泛左值)</h3><p>lvalue 和 xvalue 的统称。</p>
<h3 id="rvalue"><a href="#rvalue" class="headerlink" title="rvalue"></a>rvalue</h3><p>xvalue和prvalue的统称。因为引入了右值引用，rvalue的定义在C++中被扩大化了。</p>
<h3 id="prvalue-pure-rvalue-纯右值"><a href="#prvalue-pure-rvalue-纯右值" class="headerlink" title="prvalue (pure rvalue, 纯右值)"></a>prvalue (pure rvalue, 纯右值)</h3><p>prvalue指代一个临时对象、一个临时对象的子对象或者一个没有分配给任何对象的值。prvalue即老标准中的rvalue。例如：</p>
<ol>
<li>一个函数的返回值是平常类型，其返回值是rvalue。例如int foo();</li>
<li>没有分配给任何对象的值。如5.3，true。</li>
</ol>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>了解了上面，对于右值引用也就很好理解了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</div><div class="line"><span class="keyword">int</span> y = <span class="number">13</span>;</div><div class="line"><span class="keyword">int</span> &amp;&amp; r1 = <span class="number">13</span>;</div><div class="line"><span class="keyword">int</span> &amp;&amp; r2 = x + y;</div><div class="line"><span class="keyword">double</span> &amp;&amp; r3 = <span class="built_in">std</span>::<span class="built_in">sqrt</span>(<span class="number">2.0</span>);</div></pre></td></tr></table></figure></p>
<p>第3、4、5行等号右边都是右值，他们都是存储在临时位置的数据，正常的话赋值给一个变量会将这个临时变量的数据复制到要赋值的变量中然后将临时变量销毁。但是有了右值引用我们就省掉了中间的步骤，<strong>将右值关联到右值引用会导致该右值被存储到了特定的位置，而且可以获取该位置的地址。</strong>，也就是说，虽然我们不能将取址运算符<code>&amp;</code>用于纯右值13，但是我们可以将其用于r1，有了右值引用我们就好像将一个马上要消失的变量强制留了下来，然后可以让我们肆意的蹂躏:P</p>
<h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><h3 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h3><p>移动语义还是主要应用在<strong>构造函数</strong>和<strong>重载赋值运算符</strong>中。<br>在复制构造函数中我们要对有动态内存分配的对象进行深复制，这里我直接用stackoverflow上面的那个<code>string</code>的例子。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">class</span> <span class="built_in">string</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">char</span>* data;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">string</span>(<span class="keyword">const</span> <span class="keyword">char</span>* p)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">size_t</span> size = <span class="built_in">strlen</span>(p) + <span class="number">1</span>;</div><div class="line">        data = <span class="keyword">new</span> <span class="keyword">char</span>[size];</div><div class="line">        <span class="built_in">memcpy</span>(data, p, size);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是string对象的析构函数和复制构造函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">~<span class="built_in">string</span>()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">delete</span>[] data;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">string</span>(<span class="keyword">const</span> <span class="built_in">string</span>&amp; that)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span> size = <span class="built_in">strlen</span>(that.data) + <span class="number">1</span>;</div><div class="line">    data = <span class="keyword">new</span> <span class="keyword">char</span>[size];</div><div class="line">    <span class="built_in">memcpy</span>(data, that.data, size);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果我们使用下面的方式初始化一个string：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">c</span><span class="params">(a + b)</span></span>;  <span class="comment">// a, b都是string对象</span></div></pre></td></tr></table></figure></p>
<p>这个过程中</p>
<ol>
<li>首先<code>a + b</code>会先调用string重载过的<code>+</code>操作运算符函数，生成一个临时string对象temp</li>
<li>然后调用string对象的复制构造函数进行深赋值，将temp的数据复制到c中</li>
<li>最后再将temp进行销毁。</li>
</ol>
<p>有些迟钝的编译器甚至无法直接将生成temp直接复制，而是</p>
<ol>
<li>将temp先复制给一个新的临时返回对象temp2</li>
<li>然后销毁temp</li>
<li>在将temp2深复制到c</li>
<li>在销毁temp2<br>这样就进行了两次复制和两次销毁，如果对象在堆上的数据很多的话，这将造成大量的资源浪费。</li>
</ol>
<p>所以这个时候，因为我们在初始化c之后也并不像才操作<code>a + b</code>的数据，所以如果能够直接将生成的temp的数据转交给c，这样省去了复制和删除的开销，将会省了很多的力。那这就是移动语义要做的事情。<br>这个时候我们就可以利用右值引用，写一个新的<strong>移动构造函数</strong>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span>(<span class="built_in">string</span>&amp;&amp; that)   <span class="comment">// string&amp;&amp; is an rvalue reference to a string</span></div><div class="line">&#123;</div><div class="line">    data = that.data;</div><div class="line">    that.data = <span class="literal">nullptr</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于<code>a + b</code>是一个右值，因此能够与上面的函数进行匹配，c就使用移动构造函数进行初始化：</p>
<ol>
<li>通过右值引用，将<code>a + b</code>的值绑定到<code>that</code>对象上。</li>
<li>将<code>that</code>的数据转移到c中，通过将c指向<code>that</code>的数据。</li>
<li>通过将that的指针设成<code>NULL</code>来将<code>that</code>“销毁”。</li>
</ol>
<p>之所以要将<code>that.data</code>设为<code>nullptr</code>是因为如果<code>that.data</code>和<code>c.data</code>指向同样的数据，在调用析构函数的时候就会带来麻烦，因为程序不能对同一个地址调用<code>delete []</code>两次，但是对空指针执行<code>delete []</code>却没有问题。<br>由于在移动构造函数中我们改变了初始的temp对象的内容，所以参数中的右值引用不能使用<code>const</code>关键字。</p>
<ul>
<li>有些优化比较好的编译器甚至不用调用移动构造函数，而是将生成的临时对象直接转到c的名下。</li>
</ul>
<h3 id="强制移动"><a href="#强制移动" class="headerlink" title="强制移动"></a>强制移动</h3><p>如果我们想对一个左值使用移动构造函数和移动复制函数，我们可以使用强制类型转换运算符<code>static_cast&lt;string &amp;&amp;&gt;</code>，但是C++11提供了一个<code>std::move()</code>，来将一个左值当成一个右值来处理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>复制构造函数会进行深赋值，因为我们不想让原始的变量发生改变，我们想要的是一个副本。</li>
<li>移动构造函数，则移动指针，并将原始对象中的指针设为空，因为我们不不想保留这个原始的数据，以为他只是个临时的值而已。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Cluster Expansion中Projection Matrix的应用]]></title>
      <url>http://pytlab.github.io/2016/05/26/Cluster-Expansion%E4%B8%ADProjection-Matrix%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>这里只是记录下我对Cluster Expansion的理解，不一定正确。</p>
<p>首先对于直接使用DFT计算所有configuration表面上发生反应（如吸附，基元反应等）的能量是不现实的，耗资源耗时间。那么通过统一的公式对能量进行矫正可以将DFT算得能量进行延伸，得到不同configuration表面的相关能量的近似值，便是一种很方便的方法。</p>
<p><strong>Cluster Expansion</strong>便是一种通过展开的方式将相互作用矫正项表达出来的一种方法。这种方法有点类似线性代数中的使用一组基向量展开，也就类似泰勒展开和傅立叶展开。</p>
<a id="more"></a>
<h3 id="Cluster-Expansion的方法"><a href="#Cluster-Expansion的方法" class="headerlink" title="Cluster Expansion的方法"></a>Cluster Expansion的方法</h3><h4 id="表面上每个位点的状态"><a href="#表面上每个位点的状态" class="headerlink" title="表面上每个位点的状态"></a>表面上每个位点的状态</h4><p>在Cluster Expansion中首先要定义两个spin变量来表示表面位点的状态，因为表面的位点只有两个状态（被吸附物占据和未被占据），因此使用变量$\sigma = (+1/-1)$表示。</p>
<h4 id="基"><a href="#基" class="headerlink" title="基"></a>基</h4><p>Cluster Expansion使用一组叫做$figure$的基将相互作用能矫正项进行多项式展开。这些基其实就是一系列的子图，由0到多个位点和线组成。如下图：<br><img src="/assets/images/blog_img/2016-05-26-Cluster-Expansion中Projection-Matrix的应用/basis.png" alt=""><br>可见图中的这些基只展开到了四体相互作用，也就说明这个展开是有截断的，正常所有的子图可以组成一组无数维空间中的基，并且这些基相互正交（orthogonal）且完备（complete），但是由于有些距离比较远的相互作用对于整体的影响会很小，所以可以进行适当的截断。</p>
<h4 id="展开三步走"><a href="#展开三步走" class="headerlink" title="展开三步走"></a>展开三步走</h4><p>需要将相互作用矫正项展开需要三步（打开冰箱门。。。</p>
<ol>
<li><p>针对某个位点某个$figure$进行spin变量的累积运算。<br> $$\pi _{\alpha ,site} =\frac{1}{\nu _{\alpha}} \prod_{i=1}^{\nu _{\alpha}} \sigma _{i}$$<br> 其中，$\nu_{\alpha}$为这个$figure$中的site数。</p>
</li>
<li><p>这对某个configuration中的所有点针对某个$figure$进行累加<br> $$\Pi_{\alpha} = \frac{1}{N_{sites}}\sum_{j=1}^{N_{site}}{\pi_{\alpha, j}}$$<br> 其中，$N_{sites}$是给定的configuration中的site总数。</p>
</li>
<li><p>针对给定的configuration中所有对称性等价的$figure$的有2得到的求和值再次进行累加。<br> $$\bar{\Pi}_{F} = \frac{\nu_{\alpha}}{N_{F}}\sum_{k=1}^{N_{F}}{\Pi_{F_{k}}}$$<br> 那这个值就是在一个configuration中针对一个$figure$的矫正项展开项了。</p>
</li>
</ol>
<p>如果给定一个configuration，则相互作用能矫正项$F(\sigma)$可以表示为：<br>$$F(\sigma) = \sum_{i=1}^{N_{F}}{J_{i}\bar{\Pi}_{F_{i}}} $$</p>
<p>如果有多个configuration，则就会有多个这样子的多项式，$F_{0}(\sigma)$, $F_{1}(\sigma)$, $F_{2}(\sigma)$, …</p>
<h4 id="获取系数-J-i"><a href="#获取系数-J-i" class="headerlink" title="获取系数$J_{i}$"></a>获取系数$J_{i}$</h4><p>展开的目的是为了得到展开的系数，这样知道了系数就可以根据多项式求任何configuration的矫正项的值了。<br>但是如何获取展开的系数呢？这就需要同时对多个configuration进行上面的展开操作，这样我们就会得到一组方程组：<br>$$F_{0}(\sigma) = \sum_{i=1}^{N_{F}}{J_{i}\bar{\Pi}^{0}_{F_{i}}} $$<br>$$F_{1}(\sigma) = \sum_{i=1}^{N_{F}}{J_{i}\bar{\Pi}^{1}_{F_{i}}} $$<br>$$:$$</p>
<p>这样我们就可以使用最小二乘法进行优化，得到拟合后的系数$J_{i}$:<br>目标函数$$F(J_{0}, J_{1}, …) = \sum_{j=0}^{N_{F}}({F_{j}(\sigma) - \sum_{i=1}^{N_{F}}{J_{i}\bar{\Pi}^{j}_{F_{i}}}})^{2}$$</p>
<h3 id="投影矩阵用于拟合"><a href="#投影矩阵用于拟合" class="headerlink" title="投影矩阵用于拟合"></a>投影矩阵用于拟合</h3><p>其实仔细观察就会发现，展开的多项式都是线性的，因为spin变量的值就只有（+1/-1）两种。因此可以将上面的过程中的每个$\bar{\Pi}_{F_{i,j}}$放入到一个矩阵中，然后一些列的方程可以写成一个$Ax=b$的形式。<br><img src="/assets/images/blog_img/2016-05-26-Cluster-Expansion中Projection-Matrix的应用/equation.png" alt=""><br>（图片截自组会的ppt）<br>这样整个过程就可以通过矩阵一次性处理了，要写程序的话也是方便的多，而且使用numpy或者matlab效率也会很高。</p>
]]></content>
      
        <categories>
            
            <category> 学术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> catalysis </tag>
            
            <tag> chemistry </tag>
            
            <tag> LinearAlgebra </tag>
            
            <tag> 学术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Effective Python -- 列表排序中的优先级]]></title>
      <url>http://pytlab.github.io/2016/05/22/Effective-Python-%E5%88%97%E8%A1%A8%E6%8E%92%E5%BA%8F%E4%B8%AD%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/</url>
      <content type="html"><![CDATA[<h3 id="sort方法的参数"><a href="#sort方法的参数" class="headerlink" title="sort方法的参数"></a>sort方法的参数</h3><p>首先还是先看看python列表中<code>sort</code>方法的参数的作用。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">In [9]: a = ['123', 'sd', 'asdfgf']</div><div class="line"></div><div class="line">In [10]: a.sort??</div><div class="line">Docstring: L.sort(key=None, reverse=False) -&gt; None -- stable sort *IN PLACE*</div><div class="line">Type:      builtin_function_or_method</div></pre></td></tr></table></figure></p>
<p>sort在python3中有两个可选参数<code>key</code>, <code>reverse</code>。<code>reverse</code>参数就不多说了，那么<code>key</code>要怎么用？</p>
<p>官方文档中的解释为：</p>
<blockquote>
<p>key specifies a function of one argument that is used to extract a comparison key from each list element: <code>key=str.lower</code>. The default value is None (compare the elements directly).</p>
</blockquote>
<p>也就是说<code>key</code>需要接受一个函数对象，一个可以作为排序依据的对象，这个函数将作用域列表中的所有元素，然后根据这个函数的返回值进行排序。<br><a id="more"></a><br>例如我将列表<code>a</code>根据字符串的长度排序，就要将函数<code>len</code>传给<code>key</code>，python就会根据这个函数的返回值将列表中的元素进行排序。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">a</div><div class="line">Out[<span class="number">13</span>]: [<span class="string">'123'</span>, <span class="string">'asdfgf'</span>, <span class="string">'sd'</span>]</div><div class="line"></div><div class="line">In [<span class="number">14</span>]: a.sort(key=len)</div><div class="line"></div><div class="line">In [<span class="number">15</span>]: a</div><div class="line">Out[<span class="number">15</span>]: [<span class="string">'sd'</span>, <span class="string">'123'</span>, <span class="string">'asdfgf'</span>]</div></pre></td></tr></table></figure></p>
<p>这个函数的感觉就好象先对列表中的元素进行预处理，处理后再排序。</p>
<h3 id="回到书中例子中"><a href="#回到书中例子中" class="headerlink" title="回到书中例子中"></a>回到书中例子中</h3><p>书中的例子大致描述下就是要对一个列表进行排序，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">numbers = [8, 3, 1, 2, 5, 4, 7, 6]</div></pre></td></tr></table></figure></p>
<p>但是如果其中的数字要是出现在另一个集合中就要进行优先排序：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">group = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;  <span class="comment"># 若列表中的元素是其中之一，就要先进行排列</span></div></pre></td></tr></table></figure></p>
<p>因此要排序的话就要把出现在<code>group</code>中的元素优先级提高。这时就需要一个“预处理函数”将每个元素进行处理。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_priority</span><span class="params">(values, group)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></div><div class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> group:</div><div class="line">            <span class="keyword">return</span> (<span class="number">0</span>, x)</div><div class="line">        <span class="keyword">return</span> (<span class="number">1</span>, x)</div><div class="line">    values.sort(key=helper)</div></pre></td></tr></table></figure></p>
<p>这里作者使用了一个辅助函数来处理每个元素，这里他做的比较巧妙，就是判断元素是否在group中，然后在原有的元素前面添加一个数字0或者1，并返回tuple作为比较。<br>在这里举个例子，如果元素是3，它正好在group中，这样helper就会返回<code>(0, 3)</code>，然而如果是1，则会返回<code>(1, 1)</code><br>这样把上面的列表中的元素全部预处理后，可以得到这样个列表：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[(<span class="number">1</span>, <span class="number">8</span>), (<span class="number">0</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">2</span>), (<span class="number">0</span>, <span class="number">5</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">0</span>, <span class="number">7</span>), (<span class="number">1</span>, <span class="number">6</span>)]</div></pre></td></tr></table></figure></p>
<p>接下来python就需要对处理过以后的列表进行排序，这时就要涉及到python比较两个tuple的规则了。他首先比较元组中下标为0的元素，如果相等在比较下一个，以此类推。<br>这时候上面的列表中<strong>第一个数字为0的肯定会排在前面，然后排在前面的几个数组在根据tuple中的第二个数进行排序</strong>。这样就实现了有限排序。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">19</span>]: b = [(<span class="number">1</span>, <span class="number">8</span>), (<span class="number">0</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">2</span>), (<span class="number">0</span>, <span class="number">5</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">0</span>, <span class="number">7</span>), (<span class="number">1</span>, <span class="number">6</span>)]</div><div class="line"></div><div class="line">In [<span class="number">20</span>]: b.sort()</div><div class="line"></div><div class="line">In [<span class="number">21</span>]: b</div><div class="line">Out[<span class="number">21</span>]: [(<span class="number">0</span>, <span class="number">2</span>), (<span class="number">0</span>, <span class="number">3</span>), (<span class="number">0</span>, <span class="number">5</span>), (<span class="number">0</span>, <span class="number">7</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">1</span>, <span class="number">6</span>), (<span class="number">1</span>, <span class="number">8</span>)]</div></pre></td></tr></table></figure></p>
<p>当然最终返回的还是排序过后的int列表而不是上面的tuple列表啦。但是顺序确实相同的。即，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">23</span>]: sort_priority(numbers, group)</div><div class="line"></div><div class="line">In [<span class="number">24</span>]: numbers</div><div class="line">Out[<span class="number">24</span>]: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> Effective Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Effective Python 拾贝]]></title>
      <url>http://pytlab.github.io/2016/05/22/Effective-Python-%E6%8B%BE%E8%B4%9D/</url>
      <content type="html"><![CDATA[<p>自从看了《Effective C++》，我就喜欢上了这种以经验条目的书，简直是随身带的极品书，于是我也买了一本python版的《Effective Python》随时放在书包里，在地铁上，在任何闲下来的时候看，因为每个条目的长度都恰到好处，正好能将零碎的时间进行填充。</p>
<p></p><p><br>因此我想在这里记录下自己在看《Effective Python》中收获的东西。这里我的总结并一定是每个条目中作者想强调的，而是对于我自己在使用python中没有注意到的东西，因此是针对我自己的特制版《Effective Python》总结。</p>
<p></p><p><br><strong>我有预感，这本书能给我在python方面质的飞跃。 - ( ゜- ゜)つロ 乾杯~</strong></p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> Effective Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python 生成器小结]]></title>
      <url>http://pytlab.github.io/2016/04/30/python-%E7%94%9F%E6%88%90%E5%99%A8%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>在python中生成器可以很方便的实现迭代协议。生成器通过生成器函数产生，生成器函数可以通过常规的def语句来定义，但是不用return返回，而是用yield一次返回一个结果，在每个结果之间挂起和继续它们的状态，来自动实现迭代协议。也就是说，yield是一个语法糖，内部实现支持了迭代器协议。</p>
<p>生成器的强大之一就在于他提供了<strong>协同程序的概念</strong>，协同程序是可以运行的独立函数调用，可以暂停或者挂起，并从程序离开的地方继续或者重新开始。同时调用者也可以向程序传入额外的数据或者异常等，传入完毕后仍能在上次暂停的地方继续执行。</p>
<a id="more"></a>
<h3 id="简单的生成器特性"><a href="#简单的生成器特性" class="headerlink" title="简单的生成器特性"></a>简单的生成器特性</h3><p>我先以上一篇的列表的例子实现一个生成器：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ListGenerator</span><span class="params">(data)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</div><div class="line">        <span class="keyword">yield</span> i</div></pre></td></tr></table></figure></p>
<p>之所以我把函数写的像类一样，是因为含有<code>yield</code>的函数并不是一般的函数，它更像一个类，因为它返回一个对象，这个对象就叫生成器。<br>现在我生成一个生成器对象：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">In</span> [<span class="number">1</span>]: from list_iter import *</div><div class="line"></div><div class="line"><span class="keyword">In</span> [<span class="number">2</span>]: a = ListGenerator([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</div><div class="line"></div><div class="line"><span class="keyword">In</span> [<span class="number">3</span>]: a</div><div class="line"><span class="keyword">Out</span>[<span class="number">3</span>]: &lt;generator object ListGenerator <span class="meta">at</span> <span class="number">0x035DA6C0</span>&gt;</div></pre></td></tr></table></figure></p>
<p>这样我们可以像使用迭代器一样去使用生成器对象：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">5</span>]: [<span class="selector-tag">i</span> <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> a]</div><div class="line">Out[<span class="number">5</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="生成器的加强特性"><a href="#生成器的加强特性" class="headerlink" title="生成器的加强特性"></a>生成器的加强特性</h3><p>在python2.5中一些加强特性加入到生成器中，让生成器更加的强大，所以除了<code>__next__()</code>可以获取下一个生成的值，用户可以将值回送个生成器(<code>send()</code>)，在生成器抛出异常，以及要求生成器退出（<code>close()</code>）</p>
<h4 id="send-方法"><a href="#send-方法" class="headerlink" title="send()方法"></a><code>send()</code>方法</h4><p>由于双向的动作涉及到一个叫<code>send()</code>的代码来向生成器发送值，因此现在<code>yield</code>必须是一个表达式，因为函数会在执行<code>yield</code>之后暂停，等他回来的时候必须要有一个对象接手值，因此要写成<code>a = yield b</code>这样。<br>举个简单的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ListGenerator</span><span class="params">(data)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</div><div class="line">        receive = (<span class="keyword">yield</span> i)</div><div class="line">        <span class="keyword">if</span> receive:</div><div class="line">            print(<span class="string">"receive &#123;&#125;."</span>.format(receive))</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            print(<span class="string">"receive nothing."</span>)</div></pre></td></tr></table></figure></p>
<p>执行的结果：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">In</span> [<span class="number">47</span>]: a = <span class="symbol">ListGenerator</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</div><div class="line"></div><div class="line"><span class="symbol">In</span> [<span class="number">48</span>]: a.<span class="symbol">__next__</span>()</div><div class="line"><span class="symbol">Out</span>[<span class="number">48</span>]: <span class="number">1</span></div><div class="line"></div><div class="line"><span class="symbol">In</span> [<span class="number">49</span>]: a.<span class="symbol">__next__</span>()</div><div class="line">receive nothing.</div><div class="line"><span class="symbol">Out</span>[<span class="number">49</span>]: <span class="number">2</span></div><div class="line"></div><div class="line"><span class="symbol">In</span> [<span class="number">50</span>]: a.send(<span class="number">1.3</span>)</div><div class="line">receive <span class="number">1.3</span>.</div><div class="line"><span class="symbol">Out</span>[<span class="number">50</span>]: <span class="number">3</span></div></pre></td></tr></table></figure></p>
<p>简单分析下上面这段程序就很清楚了：</p>
<ol>
<li><p>创建生成器对象<br> 首先使用函数<code>ListGenerator</code>，python看到函数里有<code>yield</code>关键字就知道这个函数不一般要返回一个生成器对象，并赋值给变量<code>a</code>。</p>
</li>
<li><p>第一次调用<code>__next__()</code><br> 然后a就是个迭代器对象，它实现了迭代协议（即实现了<code>__iter__()</code>和<code>__next__()</code>方法，其中<code>__iter__()</code>返回生成器自身），我们调用<code>__next__()</code>函数函数体就开始执行，当执行到</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">receive = (<span class="keyword">yield</span> i)</div></pre></td></tr></table></figure>
<p> python看到了<code>yield</code>就把<code>i</code>返回并暂停函数执行。这也就是为什么第一次调用<code>__next__()</code>时先只输出了1。</p>
</li>
<li><p>第二次调用<code>__next__()</code><br> 当再次调用<code>__next__()</code>函数时候，函数便会在上次停止的地方继续执行，上次执行到了哪里？<code>yield</code>执行之后是一个赋值操作，要把一个值赋给<code>receive</code>，但是这时候我们没有给生成器发送值，因此python默认将这个值赋值为<code>None</code>。然后进行下面的判断操作，由于<code>receive</code>的值为<code>None</code>所以直接打印<code>receive nothing.</code>，然后继续执行，这时<code>i</code>变为2并在再次遇到<code>yield</code>生成器返回2并暂停。</p>
</li>
<li><p>调用<code>send()</code>方法<br> 这是在生成器恢复执行之前，我调用了生成器的<code>send()</code>函数，向生成器传入了一个值1.3，传入之后生成器恢复函数的执行，将我传入的值赋值给<code>receive</code>然后接着向下进行判断这是由于<code>receive</code>的值是1.3了因此输出<code>receive 1.3.</code>。然后接着第三轮迭代输出3.</p>
</li>
</ol>
<h4 id="throw方法"><a href="#throw方法" class="headerlink" title="throw方法"></a><code>throw</code>方法</h4><p><code>throw</code>主要是向生成器发送异常，我将上面的代码进行了修改，是生成器能够捕获异常：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ListGenerator</span><span class="params">(data)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            receive = (<span class="keyword">yield</span> i)</div><div class="line">            <span class="keyword">if</span> receive:</div><div class="line">                print(<span class="string">"receive &#123;&#125;."</span>.format(receive))</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                print(<span class="string">"receive nothing."</span>)</div><div class="line">        <span class="keyword">except</span> ValueError:</div><div class="line">            print(<span class="string">"receive a ValueError."</span>)</div></pre></td></tr></table></figure></p>
<p>在shell中执行：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">In</span> [<span class="number">1</span>]: from list_iter import *</div><div class="line"></div><div class="line"><span class="symbol">In</span> [<span class="number">2</span>]: a = <span class="symbol">ListGenerator</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</div><div class="line"></div><div class="line"><span class="symbol">In</span> [<span class="number">3</span>]: a.<span class="symbol">__next__</span>()</div><div class="line"><span class="symbol">Out</span>[<span class="number">3</span>]: <span class="number">1</span></div><div class="line"></div><div class="line"><span class="symbol">In</span> [<span class="number">4</span>]: a.throw(<span class="symbol">ValueError</span>)</div><div class="line">receive a <span class="symbol">ValueError</span>.</div><div class="line"><span class="symbol">Out</span>[<span class="number">4</span>]: <span class="number">2</span></div></pre></td></tr></table></figure></p>
<p>当第一次调用<code>__next__()</code>的时候，执行到<code>yield</code>返回1并暂停，第二次我传入了一个<code>VauleError</code>异常，生成器继续执行函数，由于接收到一个异常，并被下面的<code>except ValueError</code>捕获，这时便输出了<code>recieve a ValueError.</code>然后接着执行到<code>yield</code>返回2。</p>
<h4 id="close-方法"><a href="#close-方法" class="headerlink" title="close()方法"></a><code>close()</code>方法</h4><p>当一个生成器是一个永远执行的时候（<code>while True</code>的时候），我们就用到了<code>close()</code>来终止它。</p>
<h3 id="通过生成器，可以快速创建一个可迭代对象。"><a href="#通过生成器，可以快速创建一个可迭代对象。" class="headerlink" title="通过生成器，可以快速创建一个可迭代对象。"></a>通过生成器，可以快速创建一个可迭代对象。</h3><p>上一篇中提到过，我们可以通过将可迭代对象中的<code>__iter__()</code>方法返回一个迭代器对象来实现多次重复迭代。有了生成器，我们可以让可迭代对象的<code>__iter__()</code>方法直接返回一个生成器，也就是在<code>__iter__()</code>中使用<code>yield</code>关键字，这样创建迭代对象就很方便。我之前处理VASP文件的库VASPy中就是这样使用来从大文件中获取数据的，代码不贴上来了，直接放个链接吧： <a href="https://github.com/PytLab/VASPy/blob/master/vaspy/atomco.py#L433" target="_blank" rel="external"><span class="fa fa-github"></span> VASPy/atomco.py at master · PytLab/VASPy</a></p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python 迭代器小结]]></title>
      <url>http://pytlab.github.io/2016/04/30/python-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器是在python2.2中被加入的，<strong>它为类序列对象提供了一个类序列的接口</strong>。有了迭代器可以迭代一个不是序列的对象，因为他表现出了序列的行为。当在python中使用for循环迭代一个对象时，调用者几乎分辨不出他迭代的是一个迭代器对象还是一个序列对象，因为python让他（迭代器）像一个序列那样操作。</p>
<p><br></p>
<h3 id="如何迭代"><a href="#如何迭代" class="headerlink" title="如何迭代"></a>如何迭代</h3><p>本质上说迭代器是个对象，但是这个对象有个特殊的方法<code>next()</code>(在python3中使用<code>__next__()</code>代替了next方法)。当使用for循环来遍历整个对象时候，就会自动调用此对象的<code>__next__()</code>方法并获取下一个item。当所有的item全部取出后就会抛出一个<code>StopIteration</code>异常，这并不是错误的发生，而是告诉外部调用者迭代完成了，外部的调用者尝试去捕获这个异常去做进一步的处理。<br>不过迭代器是有限制的，例如</p>
<ul>
<li>不能向后移动</li>
<li>不能回到开始</li>
<li>也无法复制一个迭代器。<br>因此要再次进行迭代只能重新生成一个新的迭代器对象。<a id="more"></a>
</li>
</ul>
<p><br></p>
<h3 id="获取迭代器"><a href="#获取迭代器" class="headerlink" title="获取迭代器"></a>获取迭代器</h3><ol>
<li><p>对于python内置的可迭代（iterable）对象，可以通过内置的<code>iter()</code>函数来获取相应的迭代器对象。</p>
 <figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">In</span> [1]: a = [1,2,3,45]</div><div class="line"></div><div class="line"><span class="keyword">In</span> [2]: <span class="keyword">type</span>(a)</div><div class="line"><span class="keyword">Out</span>[2]: <span class="keyword">list</span></div><div class="line"></div><div class="line"><span class="keyword">In</span> [3]: a = iter(a)</div><div class="line"></div><div class="line"><span class="keyword">In</span> [4]: <span class="keyword">type</span>(a)</div><div class="line"><span class="keyword">Out</span>[4]: list_iterator</div></pre></td></tr></table></figure>
<p> 这样就获取了list相应的迭代器对象。<br> 我们来看一下该迭代器对象的属性：</p>
 <figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">In</span> [<span class="number">5</span>]: dir(a)</div><div class="line"><span class="symbol">Out</span>[<span class="number">5</span>]:</div><div class="line">[<span class="string">'__class__'</span>,</div><div class="line"> <span class="string">'__delattr__'</span>,</div><div class="line"> <span class="string">'__dir__'</span>,</div><div class="line"> <span class="string">'__doc__'</span>,</div><div class="line"> <span class="string">'__eq__'</span>,</div><div class="line"> <span class="string">'__format__'</span>,</div><div class="line"> <span class="string">'__ge__'</span>,</div><div class="line"> <span class="string">'__getattribute__'</span>,</div><div class="line"> <span class="string">'__gt__'</span>,</div><div class="line"> <span class="string">'__hash__'</span>,</div><div class="line"> <span class="string">'__init__'</span>,</div><div class="line"> <span class="string">'__iter__'</span>,</div><div class="line"> <span class="string">'__le__'</span>,</div><div class="line"> <span class="string">'__length_hint__'</span>,</div><div class="line"> <span class="string">'__lt__'</span>,</div><div class="line"> <span class="string">'__ne__'</span>,</div><div class="line"> <span class="string">'__new__'</span>,</div><div class="line"> <span class="string">'__next__'</span>,</div><div class="line"> <span class="string">'__reduce__'</span>,</div><div class="line"> <span class="string">'__reduce_ex__'</span>,</div><div class="line"> <span class="string">'__repr__'</span>,</div><div class="line"> <span class="string">'__setattr__'</span>,</div><div class="line"> <span class="string">'__setstate__'</span>,</div><div class="line"> <span class="string">'__sizeof__'</span>,</div><div class="line"> <span class="string">'__str__'</span>,</div><div class="line"> <span class="string">'__subclasshook__'</span>]</div><div class="line"></div><div class="line"><span class="symbol">In</span> [<span class="number">6</span>]:</div></pre></td></tr></table></figure>
<p> 可见此迭代对象具有两个特殊的成员方法<code>__iter__()</code>和<code>__next__()</code>,这两个方法便是支持迭代器协议所需要实现的方法。其中<code>__iter__()</code>方法返回迭代器对象本身，<code>__next__()</code>方法返回容器的下一个元素，直到结尾抛出<code>StopIteration</code>异常。<br> 我们来测试一下这个<code>list_iterator</code>对象的这两个方法:</p>
<p> <code>__iter__()</code>返回的对象就是迭代器对象本身。</p>
 <figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">In</span> [<span class="number">1</span>]: a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">45</span>]</div><div class="line"></div><div class="line"><span class="keyword">In</span> [<span class="number">2</span>]: a = iter(a)</div><div class="line"></div><div class="line"><span class="keyword">In</span> [<span class="number">3</span>]: a.__iter__()</div><div class="line"><span class="keyword">Out</span>[<span class="number">3</span>]: &lt;list_iterator <span class="keyword">at</span> <span class="number">0</span>x3a33f10&gt;</div><div class="line"></div><div class="line"><span class="keyword">In</span> [<span class="number">4</span>]: a</div><div class="line"><span class="keyword">Out</span>[<span class="number">4</span>]: &lt;list_iterator <span class="keyword">at</span> <span class="number">0</span>x3a33f10&gt;</div><div class="line"></div><div class="line"><span class="keyword">In</span> [<span class="number">5</span>]: a <span class="keyword">is</span> a.__iter__()</div><div class="line"><span class="keyword">Out</span>[<span class="number">5</span>]: <span class="literal">True</span></div><div class="line"></div><div class="line"><span class="keyword">In</span> [<span class="number">6</span>]:</div></pre></td></tr></table></figure>
<p> <code>__next__()</code>方法返回容器中的值直到结尾。</p>
 <figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">In</span> <span class="selector-attr">[6]</span>: <span class="selector-tag">a</span><span class="selector-class">.__next__</span>()</div><div class="line"><span class="selector-tag">Out</span><span class="selector-attr">[6]</span>: 1</div><div class="line"></div><div class="line"><span class="selector-tag">In</span> <span class="selector-attr">[7]</span>: <span class="selector-tag">a</span><span class="selector-class">.__next__</span>()</div><div class="line"><span class="selector-tag">Out</span><span class="selector-attr">[7]</span>: 2</div><div class="line"></div><div class="line"><span class="selector-tag">In</span> <span class="selector-attr">[8]</span>: <span class="selector-tag">a</span><span class="selector-class">.__next__</span>()</div><div class="line"><span class="selector-tag">Out</span><span class="selector-attr">[8]</span>: 3</div><div class="line"></div><div class="line"><span class="selector-tag">In</span> <span class="selector-attr">[9]</span>: <span class="selector-tag">a</span><span class="selector-class">.__next__</span>()</div><div class="line"><span class="selector-tag">Out</span><span class="selector-attr">[9]</span>: 45</div><div class="line"></div><div class="line"><span class="selector-tag">In</span> <span class="selector-attr">[10]</span>: <span class="selector-tag">a</span><span class="selector-class">.__next__</span>()</div><div class="line"><span class="selector-tag">---------------------------------------------------------------------------</span></div><div class="line"><span class="selector-tag">StopIteration</span>                             <span class="selector-tag">Traceback</span> (<span class="selector-tag">most</span> <span class="selector-tag">recent</span> <span class="selector-tag">call</span> <span class="selector-tag">last</span>)</div><div class="line">&lt;<span class="selector-tag">ipython-input-10-73aa2c76d676</span>&gt; <span class="selector-tag">in</span> &lt;<span class="selector-tag">module</span>&gt;()</div><div class="line"><span class="selector-tag">----</span>&gt; 1 <span class="selector-tag">a</span><span class="selector-class">.__next__</span>()</div><div class="line"></div><div class="line"><span class="selector-tag">StopIteration</span>:</div><div class="line"></div><div class="line"><span class="selector-tag">In</span> <span class="selector-attr">[11]</span>:</div></pre></td></tr></table></figure>
</li>
<li><p>创建迭代器对象<br> 除了使用<code>iter()</code>函数将内置的序列对象转换成相应的迭代器，我们可以自己实现迭代器协议创建迭代器对象，要实现迭代器协议也就是要在类中实现<code>__iter__()</code>和<code>__next__()</code>方法。<br> 下面我写一个与<code>list_iterator</code>相同行为的迭代器：</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListIter</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data)</span>:</span></div><div class="line">        self.__data = data</div><div class="line">        self.__count = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.__count &lt; len(self.__data):</div><div class="line">            val = self.__data[self.__count]</div><div class="line">            self.__count += <span class="number">1</span></div><div class="line">            <span class="keyword">return</span> val</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">raise</span> StopIteration</div></pre></td></tr></table></figure>
<p> 我们就可以使用for循环来遍历这个迭代器了：</p>
 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">16</span>]: <span class="selector-tag">a</span> = ListIter([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</div><div class="line"></div><div class="line">In [<span class="number">17</span>]: <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="selector-tag">a</span>:</div><div class="line">   ....:     print(i)</div><div class="line">   ....:</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">4</span></div><div class="line"><span class="number">5</span></div><div class="line"></div><div class="line">In [<span class="number">18</span>]:</div></pre></td></tr></table></figure>
<p> 对于迭代器对象，使用for循环遍历整个数组其实是个语法糖，他的内部实现还是通过调用对象的<code>__next__()</code>方法。<br> 实际上他内部的工作原理应该是这样的：</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">a = ListIter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        i = a.__next__()</div><div class="line">    <span class="keyword">except</span> StopIteration:</div><div class="line">        <span class="keyword">break</span></div><div class="line">    // do something <span class="keyword">in</span> <span class="keyword">for</span> loop</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
</li>
</ol>
<p><br></p>
<h3 id="迭代器支持多次迭代"><a href="#迭代器支持多次迭代" class="headerlink" title="迭代器支持多次迭代"></a>迭代器支持多次迭代</h3><p>正如前面所说的迭代器对象不支持重新迭代，也就是同一个迭代器对象无法多次迭代，如：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">19</span>]: <span class="selector-tag">a</span> = ListIter([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</div><div class="line"></div><div class="line">In [<span class="number">20</span>]: [<span class="selector-tag">i</span> <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> a]</div><div class="line">Out[<span class="number">20</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line"></div><div class="line">In [<span class="number">21</span>]: [<span class="selector-tag">i</span> <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> a]</div><div class="line">Out[<span class="number">21</span>]: []</div><div class="line"></div><div class="line">In [<span class="number">22</span>]:</div></pre></td></tr></table></figure></p>
<p>可见，当我再次迭代迭代器a的时候便只返回了空列表，这是因为for循环直接捕获了<code>StopIteration</code>异常。如果要再次迭代生成列表的话只能重新生成一个新的迭代器对象。<br>为了能够解决这个问题，可以分别定义一个可迭代对象(iterables)和迭代器对象(iterator).</p>
<p>插入小插曲；<br><div class="alert alert-info"><i class="fa fa-info"></i>  对于可迭代对象和迭代器对象，我的理解是：
<br>
<strong>可迭代对象</strong>是实现了<code>__iter__()</code>方法的对象，<code>__iter__()</code>可以返回一个迭代器对象。
<br>
<strong>迭代器对象</strong>是实现了<code>__next__()</code>方法的对象，其中他的<code>__iter__()</code>返回的是迭代器对象本身。</div></p>
<p>我把代码做了修改，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListIterable</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data)</span>:</span></div><div class="line">        self.__data = data</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"call iterable __iter__()."</span>)</div><div class="line">        <span class="keyword">return</span> ListIterator(self.__data)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListIterator</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data)</span>:</span></div><div class="line">        self.__data = data</div><div class="line">        self.__count = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"call iterator __iter__()."</span>)</div><div class="line">        <span class="keyword">return</span> self</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"call iterator __next__()."</span>)</div><div class="line">        <span class="keyword">if</span> self.__count &lt; len(self.__data):</div><div class="line">            val = self.__data[self.__count]</div><div class="line">            self.__count += <span class="number">1</span></div><div class="line">            <span class="keyword">return</span> val</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">raise</span> StopIteration</div></pre></td></tr></table></figure></p>
<p>为了知道python何时调用<code>__iter__()</code>方法，我添加了一个printf函数来做标记。</p>
<p>现在把这两个类导入到当前空间中：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">In</span> [<span class="number">1</span>]: from list_iter import *</div><div class="line"></div><div class="line"><span class="keyword">In</span> [<span class="number">2</span>]: a = ListIterable([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</div><div class="line"></div><div class="line"><span class="keyword">In</span> [<span class="number">3</span>]: b = a.__iter__()</div><div class="line"><span class="keyword">call</span> iterables __iter__().</div><div class="line"></div><div class="line"><span class="keyword">In</span> [<span class="number">4</span>]: a</div><div class="line"><span class="keyword">Out</span>[<span class="number">4</span>]: &lt;list_iter.ListIterable <span class="meta">at</span> <span class="number">0x39446d0</span>&gt;</div><div class="line"></div><div class="line"><span class="keyword">In</span> [<span class="number">5</span>]: b</div><div class="line"><span class="keyword">Out</span>[<span class="number">5</span>]: &lt;list_iter.ListIterator <span class="meta">at</span> <span class="number">0x39447b0</span>&gt;</div><div class="line"></div><div class="line"><span class="keyword">In</span> [<span class="number">6</span>]:</div></pre></td></tr></table></figure></p>
<p>可见a是<code>iterable</code>对象（实现了<code>__iter__()</code>），b是<code>iterator</code>对象（实现了<code>__next__()</code>）。</p>
<p>下面看看这样做是不是就可以重复多次迭代了：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">In</span> [<span class="number">6</span>]: [i <span class="keyword">for</span> i <span class="built_in">in</span> a]</div><div class="line"><span class="built_in">call</span> iterable <span class="variable">__iter__</span>().</div><div class="line"><span class="built_in">call</span> iterator <span class="variable">__next__</span>().</div><div class="line"><span class="built_in">call</span> iterator <span class="variable">__next__</span>().</div><div class="line"><span class="built_in">call</span> iterator <span class="variable">__next__</span>().</div><div class="line"><span class="built_in">call</span> iterator <span class="variable">__next__</span>().</div><div class="line"><span class="built_in">call</span> iterator <span class="variable">__next__</span>().</div><div class="line"><span class="built_in">call</span> iterator <span class="variable">__next__</span>().</div><div class="line">Out[<span class="number">6</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line"></div><div class="line"><span class="built_in">In</span> [<span class="number">7</span>]: [i <span class="keyword">for</span> i <span class="built_in">in</span> a]</div><div class="line"><span class="built_in">call</span> iterable <span class="variable">__iter__</span>().</div><div class="line"><span class="built_in">call</span> iterator <span class="variable">__next__</span>().</div><div class="line"><span class="built_in">call</span> iterator <span class="variable">__next__</span>().</div><div class="line"><span class="built_in">call</span> iterator <span class="variable">__next__</span>().</div><div class="line"><span class="built_in">call</span> iterator <span class="variable">__next__</span>().</div><div class="line"><span class="built_in">call</span> iterator <span class="variable">__next__</span>().</div><div class="line"><span class="built_in">call</span> iterator <span class="variable">__next__</span>().</div><div class="line">Out[<span class="number">7</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line"></div><div class="line"><span class="built_in">In</span> [<span class="number">8</span>]:</div></pre></td></tr></table></figure></p>
<p>重复迭代是可以了，从输出中我们可以看出一些什么来</p>
<ol>
<li>我们在使用迭代工具对<code>iterable</code>对象进行迭代的时候首先调用的是<code>iterable</code>的<code>__iter__()</code>方法，返回一个迭代器对象，也就是<code>ListIterator</code>的实例。</li>
<li>然后再遍历的时候是调用<code>iterator</code>的next方法输出值。<br>这样就可以解释了为什么这样处理能够多次迭代了，因为每次使用迭代工具迭代的时候都会调用<code>__iter__()</code>返回一个新的迭代器对象，这样就相当于创建多个迭代器了，自然可以看起来是重复迭代了！</li>
</ol>
<p><br></p>
<h3 id="可变对象和迭代器"><a href="#可变对象和迭代器" class="headerlink" title="可变对象和迭代器"></a>可变对象和迭代器</h3><p>在迭代可变对象时候，一个序列的迭代器只是<strong>记录当前到达了序列中的第几个元素</strong>，所以如果在迭代过程中改变了序列的元素。更新会理解反应到所迭代的条目上。<br>我写了个测试看了下，的确：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">13</span>]: c = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</div><div class="line"></div><div class="line">In [<span class="number">14</span>]: d = iter(c)</div><div class="line"></div><div class="line">In [<span class="number">15</span>]: for i <span class="keyword">in</span> c:</div><div class="line">   ....:     print(i)</div><div class="line">   ....:     c.remove(i)</div><div class="line">   ....:</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure></p>
<p>可见上面边迭代边删除列表的元素，但是最后却只输出了<code>1, 3, 5</code>，这是为啥？<br>既然迭代器只记得是在列表中第几个元素，那么当在第0个元素的时候将会输出1然后删除1，这是列表变成了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div></pre></td></tr></table></figure></p>
<p>但是迭代器记得我是在第二个位置上面，就指向了列表中的第二个位置上，也就是3，然后输出3.<br>以此类推，最后只能输出1，3，5了。<br>如果我猜测的没错的话，剩余的列表应该只剩下2和4了：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">In <span class="string">[17]</span>: c</div><div class="line">Out<span class="string">[17]</span>: <span class="string">[2, 4]</span></div></pre></td></tr></table></figure></p>
<p>果然！</p>
<p>以上就是我对python中迭代器方面的一点小总结。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Windows下py2与py3共存的方法]]></title>
      <url>http://pytlab.github.io/2016/04/30/Windows%E4%B8%8Bpy2%E4%B8%8Epy3%E5%85%B1%E5%AD%98%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>现在的情况是我已经在我的系统中安装了python2.7以及ipython和其他我经常用的库。现在我需要在安装python3.5的解释器以及相应版本的ipython。</p>
<h3 id="1-安装python3-5-1"><a href="#1-安装python3-5-1" class="headerlink" title="1. 安装python3.5.1"></a>1. 安装python3.5.1</h3><p>直接去官网下载后安装到默认路径下。我安装的路径为：</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:<span class="symbol">\U</span>sers<span class="symbol">\x</span>y<span class="symbol">\A</span>ppData<span class="symbol">\L</span>ocal<span class="symbol">\P</span>rograms<span class="symbol">\P</span>ython<span class="symbol">\P</span>ython35-32</div></pre></td></tr></table></figure>
<p>在这路径下可以看到python3.5的所有，为了与之前的python2.7分开，我将python重命名为<code>python3.exe</code></p>
<a id="more"></a>
<p><img src="/assets/images/blog_img/2016-04-30-Windows下py2与py3共存的方法/py3dir.png" alt=""></p>
<h3 id="2-添加至环境变量"><a href="#2-添加至环境变量" class="headerlink" title="2. 添加至环境变量"></a>2. 添加至环境变量</h3><p>为方便在shell中进入解释器，将python3.5的安装路径以及下面的Scripts路径添加至环境变量。<br><img src="/assets/images/blog_img/2016-04-30-Windows下py2与py3共存的方法/env_var.png" alt=""><br>添加scripts是为了安装ipython后方便启动。</p>
<h3 id="3-安装pip3"><a href="#3-安装pip3" class="headerlink" title="3. 安装pip3"></a>3. 安装pip3</h3><p>之前的pip是安装python2相应的库的，为了能给py3方便安装PyPI的库，需要重新安装pip3。<br>方法就是去下载<a href="https://bootstrap.pypa.io/get-pip.py" target="_blank" rel="external">get-pip.py</a>，然后使用python3去执行，pip3便会安装在Script路径下。<br><img src="/assets/images/blog_img/2016-04-30-Windows下py2与py3共存的方法/pip3.png" alt=""></p>
<h3 id="4-安装ipython"><a href="#4-安装ipython" class="headerlink" title="4. 安装ipython"></a>4. 安装ipython</h3><p>有了pip3，就可以直接在shell中使用<code>pip install</code>来安装ipython了。<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pip <span class="keyword">install</span> ipython</div></pre></td></tr></table></figure></p>
<p>相应版本的ipython就会安装在Scripts路径下<br><img src="/assets/images/blog_img/2016-04-30-Windows下py2与py3共存的方法/ipython3.png" alt=""></p>
<h3 id="安装完毕"><a href="#安装完毕" class="headerlink" title="安装完毕"></a>安装完毕</h3><p>这样我们就可以在shell中即可以执行py3也可以执行py2了。</p>
<h4 id="进入python2的ipython"><a href="#进入python2的ipython" class="headerlink" title="进入python2的ipython"></a>进入python2的ipython</h4><p><img src="/assets/images/blog_img/2016-04-30-Windows下py2与py3共存的方法/ipython2shell.png" alt=""></p>
<h4 id="进入python3的ipython"><a href="#进入python3的ipython" class="headerlink" title="进入python3的ipython"></a>进入python3的ipython</h4><p><img src="/assets/images/blog_img/2016-04-30-Windows下py2与py3共存的方法/ipython3shell.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 教程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> windows </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python中的私有变量和私有成员函数]]></title>
      <url>http://pytlab.github.io/2016/04/22/python%E4%B8%AD%E7%9A%84%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%E5%92%8C%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>python中类中并没有像C++中的public、private等关键字来定义类成员的访问权限（也就是所谓的访问控制符），但是python中也是有私有和公有变量的，他们使用特殊的变量名称来实现隐藏效果的。</p>
<p>python通过下划线作为变量的前缀来指定特殊变量：</p>
<ul>
<li><code>_xxx</code>：不能通过<code>from import *</code>导入到当前空间中</li>
<li><code>__xxx__</code>：python 内定的名称</li>
<li><code>__xxx</code>：私有变量名 相当于C++中的<code>private</code>关键字的作用。</li>
</ul>
<p>于是我自己写了个小例子理解了一下python的私有变量的大概机制，先上例子：</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">_g = <span class="string">"private global var"</span></div><div class="line"></div><div class="line">g = <span class="string">"public global var"</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.public_var = <span class="string">"A public_var"</span></div><div class="line">        self.__private_var = <span class="string">"A private_var"</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__private_func</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">"A private function."</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">public_func</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">"A public function."</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pub_call_private</span><span class="params">(self)</span>:</span></div><div class="line">        self.__private_func()</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        A.__init__(self)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__private_func</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">"B private function."</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">b_pub_call_private</span><span class="params">(self)</span>:</span></div><div class="line">        self.__private_func()</div></pre></td></tr></table></figure>
<h3 id="在分析之前先回一下python中变量的双下划线和单下划线："><a href="#在分析之前先回一下python中变量的双下划线和单下划线：" class="headerlink" title="在分析之前先回一下python中变量的双下划线和单下划线："></a>在分析之前先回一下python中变量的双下划线和单下划线：</h3><ol>
<li><p><strong>双下划线(__xxx)</strong><br> 双下划线是python为类元素（类属性和类函数）的私有性提供的初步形式。python解释器在运行时候会对具有双下划线的变量进行“混淆”处理，也就是把具有双下划线的变量名称按照某种规则进行改变，这有改变以后用户直接调用原始的变量是无法访问的，因为这个变量在混淆处理以后根本就不存在。例如python如果看到了一个类函数的名称为<code>__func(...)</code>则就会处理成<code>_Classname__func(...)</code>，这样如果用户直接调用<code>__func</code>根本就找不到这个变量，因为他改名了。<br> 通过加上类名的处理形成的新的名称可以防止父类和派生类变量名称的同名冲突。<br> 这里的处理有一点像C/C++预处理器宏展开，本身写程序的人在类中定义的变量或者函数名称为<code>__xxx</code>但是python会将其进行类似的展开处理成为<code>_classname__xxx</code>，像是单纯的纯文本操作。</p>
</li>
<li><p><strong>单下划线(_xxx)</strong><br> 这是针对简单的模块级私有化的，防止模块的属性使用<code>from mymodule import *</code>的形式加载模块私有化变量。</p>
</li>
</ol>
<h3 id="下面我针对自己写的这个例子来进行下python是如何实现数据封装的。"><a href="#下面我针对自己写的这个例子来进行下python是如何实现数据封装的。" class="headerlink" title="下面我针对自己写的这个例子来进行下python是如何实现数据封装的。"></a>下面我针对自己写的这个例子来进行下python是如何实现数据封装的。</h3><p>理解上面的规则来看这个例子就很清楚了。我先对其进行执行：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">In</span> [<span class="number">1</span>]: <span class="keyword">from</span> class_test import *</div><div class="line"></div><div class="line"><span class="built_in">In</span> [<span class="number">2</span>]: g</div><div class="line">Out[<span class="number">2</span>]: <span class="string">'public global var'</span></div><div class="line"></div><div class="line"><span class="built_in">In</span> [<span class="number">3</span>]: <span class="variable">_g</span></div><div class="line">---------------------------------------------------------------------------</div><div class="line">NameError                                 Traceback (most recent <span class="built_in">call</span> last)</div><div class="line">&lt;ipython-input-<span class="number">3</span>-<span class="number">2458</span>ddf91f55&gt; <span class="built_in">in</span> &lt;module&gt;()</div><div class="line">----&gt; <span class="number">1</span> <span class="variable">_g</span></div><div class="line"></div><div class="line">NameError: <span class="built_in">name</span> <span class="string">'_g'</span> is <span class="built_in">not</span> defined</div></pre></td></tr></table></figure></p>
<p>这就说明了单下划线的作用了，是无法通过<code>from class_test import *</code>将<code>_g</code>导入到当前空间中的。<br>当然如果使用如下的导入方式是可以的啦：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">In</span> [<span class="number">7</span>]: class_test.<span class="variable">_g</span></div><div class="line">Out[<span class="number">7</span>]: <span class="string">'private global var'</span></div><div class="line"></div><div class="line"><span class="built_in">In</span> [<span class="number">8</span>]: <span class="keyword">from</span> class_test import <span class="variable">_g</span></div><div class="line"></div><div class="line"><span class="built_in">In</span> [<span class="number">9</span>]:</div></pre></td></tr></table></figure></p>
<p><strong>好了下面测试下双下划线</strong>，为了好理解，我先把python处理的过程处理一遍，然后一切都清楚了，python的混淆处理会把我最初的代码处理成如下这样子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.public_var = <span class="string">"A public_var"</span></div><div class="line">        self._A__private_var = <span class="string">"A private_var"</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_A__private_func</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">"A private function."</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">public_func</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">"A public function."</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pub_call_private</span><span class="params">(self)</span>:</span></div><div class="line">        self._A__private_func()</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        A.__init__(self)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_B__private_func</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">"B private function."</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">b_pub_call_private</span><span class="params">(self)</span>:</span></div><div class="line">        self._B__private_func()</div></pre></td></tr></table></figure></p>
<h4 id="先看一下类变量和类方法："><a href="#先看一下类变量和类方法：" class="headerlink" title="先看一下类变量和类方法："></a>先看一下类变量和类方法：</h4><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">In</span> [<span class="number">2</span>]: dir(<span class="symbol">A</span>)</div><div class="line"><span class="symbol">Out</span>[<span class="number">2</span>]:</div><div class="line">[<span class="string">'_A__private_func'</span>,</div><div class="line"> <span class="string">'__doc__'</span>,</div><div class="line"> <span class="string">'__init__'</span>,</div><div class="line"> <span class="string">'__module__'</span>,</div><div class="line"> <span class="string">'pub_call_private'</span>,</div><div class="line"> <span class="string">'public_func'</span>]</div><div class="line"></div><div class="line"><span class="symbol">In</span> [<span class="number">3</span>]: dir(<span class="symbol">B</span>)</div><div class="line"><span class="symbol">Out</span>[<span class="number">3</span>]:</div><div class="line">[<span class="string">'_A__private_func'</span>,</div><div class="line"> <span class="string">'_B__private_func'</span>,</div><div class="line"> <span class="string">'__doc__'</span>,</div><div class="line"> <span class="string">'__init__'</span>,</div><div class="line"> <span class="string">'__module__'</span>,</div><div class="line"> <span class="string">'b_pub_call_private'</span>,</div><div class="line"> <span class="string">'pub_call_private'</span>,</div><div class="line"> <span class="string">'public_func'</span>]</div></pre></td></tr></table></figure>
<p>可见python已经进行了混淆处理。</p>
<h4 id="然后我们进行实例化："><a href="#然后我们进行实例化：" class="headerlink" title="然后我们进行实例化："></a>然后我们进行实例化：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">4</span>]: a = A()</div><div class="line"></div><div class="line">In [<span class="number">5</span>]: dir(a)</div><div class="line">Out[<span class="number">5</span>]:</div><div class="line">[<span class="string">'_A__private_func'</span>,</div><div class="line"> <span class="string">'_A__private_var'</span>,</div><div class="line"> <span class="string">'__doc__'</span>,</div><div class="line"> <span class="string">'__init__'</span>,</div><div class="line"> <span class="string">'__module__'</span>,</div><div class="line"> <span class="string">'pub_call_private'</span>,</div><div class="line"> <span class="string">'public_func'</span>,</div><div class="line"> <span class="string">'public_var'</span>]</div><div class="line"></div><div class="line">In [<span class="number">6</span>]: b = B()</div><div class="line"></div><div class="line">In [<span class="number">7</span>]: dir(b)</div><div class="line">Out[<span class="number">7</span>]:</div><div class="line">[<span class="string">'_A__private_func'</span>,</div><div class="line"> <span class="string">'_A__private_var'</span>,</div><div class="line"> <span class="string">'_B__private_func'</span>,</div><div class="line"> <span class="string">'__doc__'</span>,</div><div class="line"> <span class="string">'__init__'</span>,</div><div class="line"> <span class="string">'__module__'</span>,</div><div class="line"> <span class="string">'b_pub_call_private'</span>,</div><div class="line"> <span class="string">'pub_call_private'</span>,</div><div class="line"> <span class="string">'public_func'</span>,</div><div class="line"> <span class="string">'public_var'</span>]</div></pre></td></tr></table></figure>
<p>实例化后类方法与对象进行了绑定，同时初始化函数将变量也进行了初始化，私有变量也进行了混淆处理。</p>
<h4 id="看一看继承相关"><a href="#看一看继承相关" class="headerlink" title="看一看继承相关"></a>看一看继承相关</h4><p>B是A的派生类，也就拥有A的公有方法，<code>pub_call_private()</code>和<code>public_func()</code>，为了能说明问题我执行下<code>pub_call_private()</code>函数，<br>由于此函数中调用了私有变量，所以做过混淆处理，也就是真正执行的函数应该是这样的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">pub_call_private</span><span class="params">(self)</span>:</span></div><div class="line">    self._A__private_func()</div></pre></td></tr></table></figure></p>
<p>那么预期返回的值应该是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A private function.</div></pre></td></tr></table></figure></p>
<p>来看看结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">8</span>]: b.pub_call_private()</div><div class="line">A private function.</div><div class="line"></div><div class="line">In [<span class="number">9</span>]:</div></pre></td></tr></table></figure></p>
<p>恩，和我想的一样。其实私有变量是有继承给派生类B的，但是是以<code>_A__private_func</code>的名称进行传递的，所以如果要真正想查看A中的所谓私有数据是可行的。</p>
<h4 id="A中的所有变量是通过B中的初始化函数传递的"><a href="#A中的所有变量是通过B中的初始化函数传递的" class="headerlink" title="A中的所有变量是通过B中的初始化函数传递的"></a>A中的所有变量是通过B中的初始化函数传递的</h4><p>在B的初始化函数中，我们调用了A类的未绑定函数来讲B对象的成员数据进行了初始化，如果我重载B的初始化函数但是不执行其父类A的初始化函数，那这样调用A类继承来的函数应该会找不到相应的变量了。我稍微做了下修改：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.public_var = <span class="string">"A public_var"</span></div><div class="line">        self.__private_var = <span class="string">"A private_var"</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pub_call_private</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">print</span> self.__private_var</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div></pre></td></tr></table></figure></p>
<p>这样B中没有使用A的初始化函数来初始化自己的成员变量，但是公有方法<code>pub_call_private()</code>却被继承了过来，如果我使用B的实例调用继承来的这个函数，应该会找不到<code>_A__private_var</code>这个变量，因为B中并没有。<br>来测试下：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: from class_test import *</div><div class="line"></div><div class="line">In [<span class="number">2</span>]: b = B()</div><div class="line"></div><div class="line">In [<span class="number">3</span>]: b.pub_call_private()</div><div class="line">---------------------------------------------------------------------------</div><div class="line">AttributeError                            Traceback (most recent call last)</div><div class="line">&lt;ipython-input-<span class="number">3</span>-<span class="number">844</span>e272f133a&gt; <span class="keyword">in</span> &lt;<span class="keyword">module</span>&gt;()</div><div class="line">----&gt; <span class="number">1</span> b.pub_call_private()</div><div class="line"></div><div class="line"><span class="symbol">D:</span>\Dropbox\temp\class_test.py <span class="keyword">in</span> pub_call_private(<span class="keyword">self</span>)</div><div class="line">     <span class="number">10</span></div><div class="line">     <span class="number">11</span>     <span class="function"><span class="keyword">def</span> <span class="title">pub_call_private</span></span>(<span class="keyword">self</span>):</div><div class="line">---&gt; <span class="number">12</span>         print <span class="keyword">self</span>.__private_var</div><div class="line">     <span class="number">13</span></div><div class="line">     <span class="number">14</span></div><div class="line"></div><div class="line"><span class="symbol">AttributeError:</span> B instance has no attribute <span class="string">'_A__private_var'</span></div></pre></td></tr></table></figure></p>
<p>果然不出所料！</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>因此在这个例子中只要理解了python是如何进行混淆处理的，那么私有变量相关的东西就全部很清晰了。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++部分终于写差不多了，转移至python部分]]></title>
      <url>http://pytlab.github.io/2016/04/21/C-%E9%83%A8%E5%88%86%E7%BB%88%E4%BA%8E%E5%86%99%E5%B7%AE%E4%B8%8D%E5%A4%9A%E4%BA%86%EF%BC%8C%E8%BD%AC%E7%A7%BB%E8%87%B3python%E9%83%A8%E5%88%86/</url>
      <content type="html"><![CDATA[<p>在C++中添加SitesMap完工.<br>新增了些测试，所有测试全部通过。。<br>下面开始搞python了，希望会快一些！</p>
<p>　　　　　　<em>.，——..<br>　　　　　／　　　　　`＂</em><br>　　　　ノ　　　　　　　　\<br>　　　ノ　　　　　　　　　　\<br>　　　|　　／\　　／\　　　　|<br>　　　|　　　　　　　　　　｜<br>　　　\　　（<em>人</em>）　　　　/<br>　….—＼　　　　　　　＿／———.<br>|”　　　　‘ “<em>　　　　..,-＇　　　　　‘|<br>＇￣￣￣＼　　　　　　　／￣￣￣＇<br>　　　　　|　　　　　　　|<br>　　　　　\　　　|’￣＼｀　|<br>　　　　　＼　 　\　　　／<br>　　　　　　＼　　\</em>＿／<br>　　　　　　　＼_＿、\<br><a id="more"></a><br><img src="/assets/images/blog_img/2016-04-21-C-部分终于写差不多了，转移至python部分/test.png" alt=""></p>
]]></content>
      
        
        <tags>
            
            <tag> catalysis </tag>
            
            <tag> 随笔 </tag>
            
            <tag> KMCLib </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[为了组会临时写了个画三维网格的脚本]]></title>
      <url>http://pytlab.github.io/2016/04/15/%E4%B8%BA%E4%BA%86%E7%BB%84%E4%BC%9A%E4%B8%B4%E6%97%B6%E5%86%99%E4%BA%86%E4%B8%AA%E7%94%BB%E4%B8%89%E4%BD%8D%E7%BD%91%E6%A0%BC%E7%9A%84%E8%84%9A%E6%9C%AC/</url>
      <content type="html"><![CDATA[<p>这次组会之所以汇报KMCLib的原理，其中一个重要的原因是我想趁这个机会把看得东西进行总结，以免以后忘记了能够拿回来PPT快速回忆起来重要的东西。所以为了能够让下面的人听懂我在讲什么特地用python写了个绘制三维网格图的脚本，帮我节省了不少时间。不多扯了，进入主题吧。</p>
<p>三维网格主要是用来描述三维晶格的，因为KMCLib是一个可以模拟一维到三维的KMC模拟库，因此想要绘制三维图还是要结束matplotlib库的plot3d。同时还要配合着python的<code>itertools</code>提供的<code>product</code>和<code>combinations</code>函数，方便坐标的操作。<br>先倒入要用的库，然后创建figure对象和axes对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</div><div class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> proj3d</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product, combinations, permutations</div><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line">fig = plt.figure()</div><div class="line">ax = fig.gca(projection=<span class="string">'3d'</span>)</div><div class="line">ax.set_aspect(<span class="string">"equal"</span>)</div></pre></td></tr></table></figure>
<p>首先是三维网格的框架，先上一个效果图吧：<br><a id="more"></a><br><img src="/assets/images/blog_img/2016-04-15-为了组会临时写了个画三位网格的脚本/lines.png" alt=""></p>
<h3 id="三维网格格点与线"><a href="#三维网格格点与线" class="headerlink" title="三维网格格点与线"></a>三维网格格点与线</h3><p>网格主要是要画线，就是直接画三维直线即可(一下均用4x4x4的网格举例)。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">r = range(<span class="number">0</span>, <span class="number">4</span>)</div><div class="line"></div><div class="line"><span class="comment"># line width</span></div><div class="line">lw = <span class="number">1</span></div><div class="line"></div><div class="line"><span class="comment"># line color</span></div><div class="line">lc = <span class="string">'#919191'</span></div><div class="line"></div><div class="line"><span class="comment"># get all position in a 2d plane</span></div><div class="line">coordinates = product(r, repeat=<span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment"># draw line parallel to x axis</span></div><div class="line">x = (r[<span class="number">0</span>], r[<span class="number">-1</span>])</div><div class="line"><span class="keyword">for</span> y, z <span class="keyword">in</span> coordinates:</div><div class="line">    ax.plot3D(x, [y, y], [z, z], color=lc, lw=lw)</div><div class="line">    ax.plot3D([y, y], x, [z, z], color=lc, lw=lw)</div><div class="line">    ax.plot3D([y, y], [z, z], x, color=lc, lw=lw)</div></pre></td></tr></table></figure></p>
<p>接下来就是要往网格个点上进行填充，这要先获取每个网格的每个坐标值，这时候就用到了itertools提供的接口了, 同时为了后面方便我把所有的坐标tuple保存了下来：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># get all points coordinates</span></div><div class="line">coord_it = product(r, repeat=<span class="number">3</span>)</div><div class="line"><span class="comment"># collect all points</span></div><div class="line">coords = []</div><div class="line"><span class="keyword">for</span> c <span class="keyword">in</span> coord_it:</div><div class="line">    coords.append(c)</div></pre></td></tr></table></figure></p>
<h3 id="三维散点进行填充"><a href="#三维散点进行填充" class="headerlink" title="三维散点进行填充"></a>三维散点进行填充</h3><p>接下来要是使用三维散点往晶格上撒点，有了坐标了，这种撒点就很容易操作了，上效果图：<br><img src="/assets/images/blog_img/2016-04-15-为了组会临时写了个画三位网格的脚本/sites_points.png" alt=""></p>
<h3 id="给晶格添加坐标"><a href="#给晶格添加坐标" class="headerlink" title="给晶格添加坐标"></a>给晶格添加坐标</h3><p>一开始我想用annotate来实现不过好像不用，<code>ax.text()</code>就很好，方便快捷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># add text</span></div><div class="line"><span class="keyword">for</span> i, (x, y, z) <span class="keyword">in</span> enumerate(coords):</div><div class="line">    ax.text(z, y, x, <span class="string">'%s'</span> % (str(i)), size=<span class="number">13</span></div><div class="line"> add coordinates</div><div class="line"><span class="keyword">for</span> z, y, x <span class="keyword">in</span> coords:</div><div class="line">    ax.text(x, y, z,</div><div class="line">            <span class="string">"(%s, %s, %s)"</span> % (float(z), float</div><div class="line">            size=<span class="number">13</span>, zorder=<span class="number">2</span>, color=<span class="string">'k'</span>)</div></pre></td></tr></table></figure></p>
<p>效果图：<br><img src="/assets/images/blog_img/2016-04-15-为了组会临时写了个画三位网格的脚本/coordinates.png" alt=""></p>
<h3 id="添加含有basis-site的全局索引值"><a href="#添加含有basis-site的全局索引值" class="headerlink" title="添加含有basis site的全局索引值"></a>添加含有basis site的全局索引值</h3><p>由于KMCLib中一个很重要的概念就是basis_site因为他的存在，是的kmclib足够强大能够模拟任何晶格的kMC过程，所以要实现能够画出这种效果的程序也很简单，把所有的点全部标号，只不过标号的时候要进行分组，这里就要用的数组的变形的，即<code>numpy.array</code>的<code>reshape</code>成员函数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># add basis sites</span></div><div class="line">nbasis = <span class="number">3</span></div><div class="line">site_indices = np.array(range(len(coords)*nbasis)).reshape(<span class="number">-1</span>, nbasis)</div><div class="line">site_indices = site_indices.tolist()</div><div class="line"></div><div class="line"><span class="keyword">for</span> basis_sites, position <span class="keyword">in</span> zip(site_indices, coords):</div><div class="line">    x, y, z = position</div><div class="line">    bsite_str = (<span class="string">"("</span> + <span class="string">"%s, "</span>*(nbasis<span class="number">-1</span>) + <span class="string">"%s)"</span>) % tuple(map(str, ba</div><div class="line">    ax.text(z, y, x, bsite_str, size=<span class="number">10</span>, zorder=<span class="number">2</span>, color=<span class="string">'k'</span>)</div></pre></td></tr></table></figure></p>
<p>效果图：<br><img src="/assets/images/blog_img/2016-04-15-为了组会临时写了个画三位网格的脚本/basis_sites.png" alt=""></p>
<p>关于注释部分我是在stackoverflow上看到有人这么写我也就搬过来了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># add annotate</span></div><div class="line">x2, y2, _ = proj3d.proj_transform(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, ax.get_proj())</div><div class="line">label = ax.annotate(</div><div class="line">    <span class="string">"Center site"</span>,</div><div class="line">    xy = (x2, y2), xytext = (<span class="number">-20</span>, <span class="number">20</span>),</div><div class="line">    textcoords = <span class="string">'offset points'</span>, ha = <span class="string">'right'</span>, va = <span class="string">'bottom'</span>,</div><div class="line">    bbox = dict(boxstyle = <span class="string">'round,pad=0.5'</span>, fc = <span class="string">'yellow'</span>, alpha = <span class="number">1.0</span>),</div><div class="line">    arrowprops = dict(arrowstyle = <span class="string">'-&gt;'</span>, connectionstyle = <span class="string">'arc3,rad=0'</span>))</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_position</span><span class="params">(e)</span>:</span></div><div class="line">    x2, y2, _ = proj3d.proj_transform(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, ax.get_proj())</div><div class="line">    label.xy = x2,y2</div><div class="line">    label.update_positions(fig.canvas.renderer)</div><div class="line">    fig.canvas.draw()</div></pre></td></tr></table></figure></p>
<h3 id="向还有多个basis-site的网格填充散点"><a href="#向还有多个basis-site的网格填充散点" class="headerlink" title="向还有多个basis site的网格填充散点"></a>向还有多个basis site的网格填充散点</h3><p>这里就要获取每个basis site的绝对坐标，获取方法就是在每个网格点上进行偏移处理，然后撒点。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># cadd additional points</span></div><div class="line">offset_1 = (<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.1</span>)</div><div class="line">offset_2 = (<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.2</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> x, y, z <span class="keyword">in</span> coords:</div><div class="line"><span class="comment">#    if 3 in (x, y, z):</span></div><div class="line"><span class="comment">#        continue</span></div><div class="line">    new_x = x + offset_1[<span class="number">0</span>]</div><div class="line">    new_y = y + offset_1[<span class="number">1</span>]</div><div class="line">    new_z = z + offset_1[<span class="number">2</span>]</div><div class="line">    color = colors[int(random.random()*<span class="number">3</span>)]</div><div class="line">    ax.scatter(new_x, new_y, new_z, color=color, s=<span class="number">80</span>, marker=<span class="string">'o'</span>)</div><div class="line">    <span class="comment"># plot linking line</span></div><div class="line">    ax.plot3D((x, new_x), (y, new_y), (z, new_z), color=lc, lw=lw)</div><div class="line"></div><div class="line">    new_x = x + offset_2[<span class="number">0</span>]</div><div class="line">    new_y = y + offset_2[<span class="number">1</span>]</div><div class="line">    new_z = z + offset_2[<span class="number">2</span>]</div><div class="line">    color = colors[int(random.random()*<span class="number">3</span>)]</div><div class="line">    ax.scatter(new_x, new_y, new_z, color=color, s=<span class="number">80</span>, marker=<span class="string">'o'</span>)</div><div class="line">    <span class="comment"># plot linking line</span></div><div class="line">    ax.plot3D((x, new_x), (y, new_y), (z, new_z), color=lc, lw=lw)</div></pre></td></tr></table></figure></p>
<p>效果图：<br><img src="/assets/images/blog_img/2016-04-15-为了组会临时写了个画三位网格的脚本/basis_sites_points.png" alt=""></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>由于还有要画一些封闭的面，这里就是直接使用<code>plot_surface</code>来画的，不多讲了，直接上图吧：<br><img src="/assets/images/blog_img/2016-04-15-为了组会临时写了个画三位网格的脚本/surface1.png" alt=""><br><img src="/assets/images/blog_img/2016-04-15-为了组会临时写了个画三位网格的脚本/surface2.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 我的日常 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> catalysis </tag>
            
            <tag> matplotlib </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初探SWIG对函数的封装]]></title>
      <url>http://pytlab.github.io/2016/04/06/%E5%88%9D%E6%8E%A2SWIG%E5%AF%B9%E5%87%BD%E6%95%B0%E7%9A%84%E5%B0%81%E8%A3%85/</url>
      <content type="html"><![CDATA[<p>看到KMCLib中在python中直接使用c++的函数，不禁又让我开始联想这是为什么，于是我就自己写个小测试看看swig是怎么封装函数的。</p>
<p>先定义两个C++函数:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file: temp.h</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">showg</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>函数实现文件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file: temp.cpp</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"temp.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> a + b;    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">double</span> g = <span class="number">10.0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">showg</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> g;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>开始用swig进行封装：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ swig -python -c++ -verbose temp<span class="selector-class">.i</span></div><div class="line"></div><div class="line">$ g++ -shared -fPIC temp<span class="selector-class">.cpp</span> temp_wrap<span class="selector-class">.cxx</span> -o _temp.so</div></pre></td></tr></table></figure></p>
<p>ok，这个程序能在python中执行，我现在想看swig是怎么封装这两个函数的。<br>先看看python直接调用的py模块文件中的代码，找到add和showg函数的定义：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></div><div class="line">    <span class="keyword">return</span> _temp.add(a, b)</div><div class="line">add = _temp.add</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">showg</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> _temp.showg()</div><div class="line">showg = _temp.showg</div></pre></td></tr></table></figure></p>
<p>可见他们都是将_temp模块中的相应的函数进行了封装或者说代理。那么python调用的应该是封装过以后的c++函数，毕竟python不可能直接调用C++函数（不然为什么要封装。。。</p>
<p></p><p><br>在temp_wrap.cpp中可以找到swig对两个原始C++函数的封装函数，通过封装，能够将传入的python数据转换成C++的数据类型并调用真正的C++函数返回C++数据，在将C++数据转换成python相应的数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">SWIGINTERN PyObject *_wrap_add(PyObject *SWIGUNUSEDPARM(self), PyObject *args) &#123;</div><div class="line">  PyObject *resultobj = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> arg1 ;</div><div class="line">  <span class="keyword">int</span> arg2 ;</div><div class="line">  <span class="keyword">int</span> val1 ;</div><div class="line">  <span class="keyword">int</span> ecode1 = <span class="number">0</span> ;</div><div class="line">  <span class="keyword">int</span> val2 ;</div><div class="line">  <span class="keyword">int</span> ecode2 = <span class="number">0</span> ;</div><div class="line">  PyObject * obj0 = <span class="number">0</span> ;</div><div class="line">  PyObject * obj1 = <span class="number">0</span> ;</div><div class="line">  <span class="keyword">int</span> result;</div><div class="line">  </div><div class="line">  <span class="keyword">if</span> (!PyArg_ParseTuple(args,(<span class="keyword">char</span> *)<span class="string">"OO:add"</span>,&amp;obj0,&amp;obj1)) SWIG_fail;</div><div class="line">  ecode1 = SWIG_AsVal_int(obj0, &amp;val1);</div><div class="line">  <span class="keyword">if</span> (!SWIG_IsOK(ecode1)) &#123;</div><div class="line">    SWIG_exception_fail(SWIG_ArgError(ecode1), <span class="string">"in method '"</span> <span class="string">"add"</span> <span class="string">"', argument "</span> <span class="string">"1"</span><span class="string">" of type '"</span> <span class="string">"int"</span><span class="string">"'"</span>);</div><div class="line">  &#125; </div><div class="line">  arg1 = <span class="keyword">static_cast</span>&lt; <span class="keyword">int</span> &gt;(val1);</div><div class="line">  ecode2 = SWIG_AsVal_int(obj1, &amp;val2);</div><div class="line">  <span class="keyword">if</span> (!SWIG_IsOK(ecode2)) &#123;</div><div class="line">    SWIG_exception_fail(SWIG_ArgError(ecode2), <span class="string">"in method '"</span> <span class="string">"add"</span> <span class="string">"', argument "</span> <span class="string">"2"</span><span class="string">" of type '"</span> <span class="string">"int"</span><span class="string">"'"</span>);</div><div class="line">  &#125; </div><div class="line">  arg2 = <span class="keyword">static_cast</span>&lt; <span class="keyword">int</span> &gt;(val2);</div><div class="line">  result = (<span class="keyword">int</span>)add(arg1,arg2);</div><div class="line">  resultobj = SWIG_From_int(<span class="keyword">static_cast</span>&lt; <span class="keyword">int</span> &gt;(result));</div><div class="line">  <span class="keyword">return</span> resultobj;</div><div class="line">fail:</div><div class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于在python中所有的数据包括<code>int</code>, <code>float</code>这种基本数据类型也都是用<code>PyObject</code>来实现的，因此swig要做的数据转换就是<code>PyObject</code> &lt;–&gt; <code>int</code>等数据之间的转换，数据转换好以后就可以在封装函数内直接调用C++的函数了。我特地做了个图：<br><img src="assets/images/blog_img/2016-04-06-初探SWIG对函数的封装/funcwrap.png" alt=""></p>
<p>可见所谓函数封装也就是给真正的内部函数套一个壳子，壳子的主要作用是数据转换工作（传入参数和返回值的操作）。这样我们在python中调用C++函数实际上就是操作壳子中的C/C++函数。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> C </tag>
            
            <tag> Cpp </tag>
            
            <tag> swig </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SWIG对结构和类的封装]]></title>
      <url>http://pytlab.github.io/2016/04/05/SWIG%E5%AF%B9%E7%BB%93%E6%9E%84%E5%92%8C%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85/</url>
      <content type="html"><![CDATA[<p>为了能够将C++的类映射到目标语言，swig使用目标语言自动生成一个代理类（Proxy Class）来讲真正的C++类封装在里面，并通过使用一些accessor函数来使其看起来和用C++类一样的效果。</p>
<p>举个例子：<br>我有如下C++的类：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Foo</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Foo();</div><div class="line">    ~Foo();</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>代理类只是一种思想，可以用C++本身来实现一个代理类封装自己的类：<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> FooProxy</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Foo * <span class="keyword">this</span>;  <span class="comment">// 这个指针就是指向真正的被封装的类对象</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    FooProxy() &#123; <span class="keyword">this</span> = new_Foo(); &#125;  <span class="comment">// new_Foo()函数就是一个accessor函数，使用C++创建一个Foo对象，并返回其地址</span></div><div class="line">    ~FooProxy() &#123; delete_Foo(<span class="keyword">this</span>); &#125;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> Foo_bar(<span class="keyword">this</span>, x); &#125;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">x_get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Foo_x_get(<span class="keyword">this</span>); &#125;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">x_set</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; Foo_x_set(<span class="keyword">this</span>, x); &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>当然要生成目标语言的代理类，那就要使用目标函数来生成，使用python的话：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.this = new_Foo()  <span class="comment"># 这里的new_Foo函数是封装过的accessor函数</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></div><div class="line">        delete_Foo(self.this)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self, x)</span>:</span></div><div class="line">        <span class="keyword">return</span> Foo_bar(self.this, x)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></div><div class="line">        <span class="keyword">if</span> name == <span class="string">'x'</span>:</div><div class="line">            <span class="keyword">return</span> Foo_x_get(self.this)</div><div class="line">        ...</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></div><div class="line">        <span class="keyword">if</span> name == <span class="string">'x'</span>:</div><div class="line">            Foo_x_set(self.this, value)</div><div class="line">        ...</div></pre></td></tr></table></figure></p>
<blockquote>
<p>Again, it’s important to emphasize that the low-level accessor functions are always used by the proxy classes.</p>
</blockquote>
<p>感觉swig映射或者说封装C/C++的类或者结构的时候是先生成一套accessor functions进行封装，然后生成目标语言的proxy class调用accessor functions形成一个看似和原始类型为相同的封装类。</p>
<p>在这里举个简单的例子：<br>swig接口文件(temp.i)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">%<span class="keyword">module</span> temp</div><div class="line"></div><div class="line">%<span class="keyword">inline</span> %&#123;</div><div class="line"><span class="keyword">class</span> A </div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> a_;</div><div class="line">    A() &#123;&#125;</div><div class="line">    ~A() &#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">const</span> <span class="title">a</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a_; &#125;</div><div class="line">&#125;;</div><div class="line">%&#125;</div></pre></td></tr></table></figure></p>
<p>直接将其编译成模块，在python中执行：<br><img src="assets/images/blog_img/2016-04-05-SWIG对结构和类的封装/inpython.png" alt=""><br>可见封装后的a对象中的this成员是一个指针（在python中是个swigpyobject指针对象），其他的方法也都有相应的accessor function来操作对象。</p>
]]></content>
      
        
        <tags>
            
            <tag> python </tag>
            
            <tag> C </tag>
            
            <tag> Cpp </tag>
            
            <tag> swig </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SWIG中的指针]]></title>
      <url>http://pytlab.github.io/2016/04/04/SWIG%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88/</url>
      <content type="html"><![CDATA[<p>SWIG有一个简单规则就是</p>
<blockquote>
<p>Everything else is a pointer</p>
</blockquote>
<p>即除了基本的类型以外的其他数据类型，swig全部通过指针来处理。大致过程就是将操作C/C++中的结构，类，数组等是通过操作指向这些数据的指针操作，封装成python的数据也是一个包含指针信息的python对象。<br>C/C++的指针在python中是通过一个特殊的对象来保存的，在python中的变量保存的C/C++的数组以及类对象其实就是保存的这些指针对象，然后封装函数也是操作指针来操作真正的结构和数组等对象。</p>
<a id="more"></a>
<p>下面我通过自己写的两个例子来说明：</p>
<h3 id="python操作C的struct"><a href="#python操作C的struct" class="headerlink" title="python操作C的struct"></a>python操作C的struct</h3><p>首先是C的源程序，定义vector结构和向量相加的函数</p>
<ul>
<li><p>vector.h</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Vector &#123;</div><div class="line">    <span class="keyword">double</span> x, y, z;</div><div class="line">&#125; Vector;</div><div class="line"></div><div class="line"><span class="function">Vector <span class="title">add</span><span class="params">(Vector a, Vector b)</span></span>;</div></pre></td></tr></table></figure>
</li>
<li><p>vector.c</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector.h"</span></span></div><div class="line"></div><div class="line"><span class="function">Vector <span class="title">add</span><span class="params">(Vector a, Vector b)</span></span></div><div class="line">&#123;</div><div class="line">    Vector sum;</div><div class="line">    sum.x = a.x + b.x;</div><div class="line">    sum.y = a.y + b.y;</div><div class="line">    sum.z = a.z + b.z;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  函数的实现。</p>
</li>
<li><p>vector.i</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">%<span class="keyword">module</span> <span class="built_in">vector</span></div><div class="line"></div><div class="line">%&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector.h"</span>  <span class="comment">// 让生成的封装函数知道原型和结构定义</span></span></div><div class="line">%&#125;</div><div class="line"></div><div class="line">%include <span class="string">"vector.h"</span>  <span class="comment">// 封装结构和函数</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>这样就可以在生成封装文件并一并编译链接生成最终的模块文件。</p>
<p><img src="assets/images/blog_img/2016-04-04-SWIG中的指针/vector.png" alt=""></p>
<p>可见，封装以后可以向使用类一样使用C结构，对象的类型是一种<code>Swig Object</code>其中对象中包含了指针的类型和保存的地址的值。<br>包括按值返回的<code>add</code>函数也是返回一个”指针对象”。</p>
<h3 id="python中操作C数组"><a href="#python中操作C数组" class="headerlink" title="python中操作C数组"></a>python中操作C数组</h3><ul>
<li><p>array_test.h</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_array</span><span class="params">(<span class="keyword">int</span> * a, <span class="keyword">int</span> n)</span></span>;</div></pre></td></tr></table></figure>
</li>
<li><p>array_test.c</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"array_test.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_array</span><span class="params">(<span class="keyword">int</span> * a, <span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d, "</span>, a[i]);</div><div class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>array_test.i</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">%<span class="keyword">module</span> array_test</div><div class="line"></div><div class="line">%&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"array_test.h"</span></span></div><div class="line">%&#125;</div><div class="line"></div><div class="line">%<span class="keyword">inline</span> %&#123;</div><div class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;  <span class="comment">// 不仅让swig封装，还要把这个复制到生成的封装文件中</span></div><div class="line">%&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_array</span><span class="params">(<span class="keyword">int</span> *, <span class="keyword">int</span>)</span></span>;  <span class="comment">// 让swig封装这个函数</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>现在就可以使用swig来生成最终的扩展模块库</p>
<p><img src="assets/images/blog_img/2016-04-04-SWIG中的指针/array.png" alt=""></p>
<p>可见，在python中操作的array也是通过一个<code>Swig Object</code>对象。其中放置了指针类型和指针的值。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> C </tag>
            
            <tag> Cpp </tag>
            
            <tag> swig </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SWIG给C结构增加‘成员函数’]]></title>
      <url>http://pytlab.github.io/2016/04/03/SWIG%E7%BB%99C%E7%BB%93%E6%9E%84%E5%A2%9E%E5%8A%A0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>由于之前看的是《Python科学计算》上面关于swig的简单介绍，上面说了如何在python中如何像类一样的使用C结构，但是也只是停留在如何使用结构的成员数据上，但是没有讲如何将C的函数封装成python的类方法的方法。相反由于C++有原生OOP的支持，固然swig直接可以将C++的类封装成python的类。所以我以前一直认为这时候只能用C++了。<br>但其实，还是读书读的少啊。swig这么强大的封装工具，这早就想到了。毕竟OO是一种思想，C照样能写出OO的代码来（多重继承和多态这种行么？）。</p>
<p>所以今天看到swig文档中关于<code>%extend</code>指令的介绍才感觉相见恨晚啊。<br><a id="more"></a></p>
<h3 id="给C结构添加成员函数"><a href="#给C结构添加成员函数" class="headerlink" title="给C结构添加成员函数"></a>给C结构添加成员函数</h3><p>C语言的OO通常都是写操作结构的接口函数，尽管SWIG为C++提供了直接的面向对象的类映射，C却没有。尽管如此SWIG还是提供了一个<code>%extend</code>指令，就是这个指令能够将C语言封装成支持OO的语言的接口。</p>
<p><br></p>
<h4 id="向已定义的结构添加成员函数"><a href="#向已定义的结构添加成员函数" class="headerlink" title="向已定义的结构添加成员函数"></a>向已定义的结构添加成员函数</h4><p>具体的使用方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Vector &#123;</div><div class="line">    <span class="keyword">double</span> x, y, z;</div><div class="line">&#125; Vector;</div></pre></td></tr></table></figure></p>
<p>这样封装的话在python中只能这样调用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>v = Vector(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>);</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>v.x</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1.0</span></div></pre></td></tr></table></figure></p>
<p>但是这个类并没有成员函数，那如何给这个结构绑定函数，并封装成python类的成员函数呢？上<code>%extend</code>!<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file : vector.i</span></div><div class="line"></div><div class="line">%<span class="keyword">module</span> modulename</div><div class="line"></div><div class="line">%&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector.h"</span>  <span class="comment">// 这一部分会原封不动的复制到生成封装c源码中，是给C编译器看的</span></span></div><div class="line">%&#125;</div><div class="line"></div><div class="line">%include <span class="string">"vector.h"</span>  <span class="comment">// 在这个.i文件中宏展开，让后面的函数知道结构定义</span></div><div class="line">%extend Vector &#123;     <span class="comment">// 将里面的函数绑定到Vector结构，如果没有typedef的话要写成struct Vector</span></div><div class="line"></div><div class="line">    <span class="comment">// 类似C++的构造函数，但是要进行动态内存分配</span></div><div class="line">    Vector(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> z)</div><div class="line">    &#123;</div><div class="line">        Vector * v;</div><div class="line">        v = (Vector *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Vector));</div><div class="line">        v-&gt;x = x;</div><div class="line">        v-&gt;y = y;</div><div class="line">        v-&gt;z = z;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 析构函数，将构造函数动态分配的内存释放掉。</span></div><div class="line">    ~Vector()</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">free</span>($self);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Vector [%g, %g, %g]\n"</span>, $self-&gt;x, $self.y, $self-&gt;z);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>是的，通过上面的代码可以看出SWIG在模仿C++的语法，其中构造函数和析构函数就不多说了。<code>$self</code>是一个内置的变量，作用类似于C++中的<code>this</code>，也就是指向当前对象的指针。</p>
<p><code>%extend</code>指令不仅定义了成员函数，而且还相当于在<code>vector.i</code>文件中对这些函数进行了声明，这样不仅C编译器会编译这些函数，SWIG也会处理这些函数生成接口代码。</p>
<p>这样我们在Python中就可以这样使用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> vector <span class="keyword">import</span> *</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>v = Vector(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>v.print()</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> v  <span class="comment"># 删除此对象的引用</span></div></pre></td></tr></table></figure></p>
<p><br></p>
<h4 id="在定义结构的时候直接添加成员函数"><a href="#在定义结构的时候直接添加成员函数" class="headerlink" title="在定义结构的时候直接添加成员函数"></a>在定义结构的时候直接添加成员函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file : vector.i</span></div><div class="line">%<span class="keyword">module</span> modulename</div><div class="line">%&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector.h"</span></span></div><div class="line">%&#125;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Vector &#123;</div><div class="line">    <span class="keyword">double</span> x, y, z;</div><div class="line">    %extend &#123;</div><div class="line">        Vector(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> z) &#123; ... &#125;</div><div class="line">        ~Vector() &#123; ... &#125;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125; Vector;</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="使用已定义的函数作为结构的成员函数"><a href="#使用已定义的函数作为结构的成员函数" class="headerlink" title="使用已定义的函数作为结构的成员函数"></a>使用已定义的函数作为结构的成员函数</h4><p>如果在源代码中的实现文件中已经定义结构的接口函数（名称要按照swig的规定），则可以直接在结构定义中扩展这些函数。<br>例如如果我在实现文件中定义了如下几个函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file : vector.c</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector.h"</span></span></div><div class="line"><span class="function">Vector * <span class="title">new_Vector</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> z)</span></span></div><div class="line">&#123;</div><div class="line">    Vector * v;</div><div class="line">    v = (Vector *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Vector));</div><div class="line">    v-&gt;x = x;</div><div class="line">    v-&gt;y = y;</div><div class="line">    v-&gt;z = z;</div><div class="line">    <span class="keyword">return</span> v;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_Vector</span><span class="params">(Vector * v)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">free</span>(v);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Vector_print</span><span class="params">(Vector * v)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Vector [%g, %g, %g]\n"</span>, $self-&gt;x, $self.y, $self-&gt;z);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后我在<code>*.i</code>文件中给SWIG声明Vector类的时候就可以直接添加成员函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file : vector.i</span></div><div class="line">%<span class="keyword">module</span> modulename</div><div class="line">%&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector.h"</span></span></div><div class="line">%&#125;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Vector &#123;</div><div class="line">    <span class="keyword">double</span> x, y, z;</div><div class="line">    %extend &#123;</div><div class="line">        Vector(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>);  <span class="comment">// 这个函数将会调用实现文件中的new_Vector()</span></div><div class="line">        ~Vector();              <span class="comment">// 将会调用delete_Vector()</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;           <span class="comment">// 将调用Vector_print()</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<div class="alert alert-info"><i class="fa fa-info"></i>  这里感觉和C++很像了，有了`%extend`的struct就相当于直接在头文件中定义类（包括成员数据和成员函数），然后类成员函数的实现在实现代码中。</div>
<p>但是这里的命名是由要求的，因为在python中或者其他目标语言中调用成员方法是通过调用<code>Vector_print</code>来实现的，因此如果要认为定义成员函数，函数的名称也要符合这些规则。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> C </tag>
            
            <tag> Cpp </tag>
            
            <tag> swig </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在CMake中使用SWIG构建封装模块]]></title>
      <url>http://pytlab.github.io/2016/04/02/%E5%9C%A8CMake%E4%B8%AD%E4%BD%BF%E7%94%A8SWIG%E6%9E%84%E5%BB%BA%E5%B0%81%E8%A3%85%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<p>由于CMake与SWIG的相互支持，使得在cmake脚本中直接定义封装模块的构建成为可能，KMCLib中也是使用这种方式直接使用swig进行自动封装。也就是在生成的Makefile中包含了使用swig命令封装库文件。</p>
<p>在这里我主要参考了<a href="http://www.swig.org/Doc1.3/Introduction.html#Introduction_build_system" target="_blank" rel="external">swig文档中关于cmake的部分</a>和<a href="https://cmake.org/cmake/help/v3.5/module/UseSWIG.html" target="_blank" rel="external">cmake文档中使用swig的部分</a>。</p>
<a id="more"></a>
<p>还是上例子吧</p>
<h3 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># This is a CMake example for Python</span></div><div class="line"></div><div class="line"><span class="keyword">FIND_PACKAGE</span>(SWIG REQUIRED)  </div><div class="line"><span class="keyword">INCLUDE</span>(<span class="variable">$&#123;SWIG_USE_FILE&#125;</span>)  </div><div class="line"></div><div class="line"><span class="keyword">FIND_PACKAGE</span>(PythonLibs)  </div><div class="line"><span class="keyword">INCLUDE_DIRECTORIES</span>(<span class="variable">$&#123;PYTHON_INCLUDE_PATH&#125;</span>)</div><div class="line"></div><div class="line"><span class="keyword">INCLUDE_DIRECTORIES</span>(<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)</div><div class="line"></div><div class="line"><span class="keyword">SET</span>(CMAKE_SWIG_FLAGS <span class="string">""</span>)</div><div class="line"></div><div class="line"><span class="keyword">SET_SOURCE_FILES_PROPERTIES</span>(example.i PROPERTIES CPLUSPLUS <span class="keyword">ON</span>)</div><div class="line"><span class="keyword">SET_SOURCE_FILES_PROPERTIES</span>(example.i PROPERTIES SWIG_FLAGS <span class="string">"-includeall"</span>)</div><div class="line">SWIG_ADD_MODULE(example python example.i example.cxx)</div><div class="line">SWIG_LINK_LIBRARIES(example <span class="variable">$&#123;PYTHON_LIBRARIES&#125;</span>)</div></pre></td></tr></table></figure>
<h3 id="每条语句分析："><a href="#每条语句分析：" class="headerlink" title="每条语句分析："></a>每条语句分析：</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">FIND_PACKAGE</span><span class="params">(SWIG REQUIRED)</span></span></div></pre></td></tr></table></figure>
<p>寻找swig有没有安装在本机上，如果没有，由于指定了<code>REQUIRED</code>参数，cmake会产生一个fatal error然后停止构建。</p>
<hr>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">INCLUDE</span><span class="params">($&#123;SWIG_USE_FILE&#125;)</span></span></div></pre></td></tr></table></figure>
<p>载入预定义的cmake模块</p>
<hr>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">FIND_PACKAGE</span><span class="params">(PythonLibs)</span></span></div></pre></td></tr></table></figure>
<p>查看python是否安装并生成几个变量确定python的头文件以及库文件在哪里。变量列表：<br><div class="alert alert-info"><i class="fa fa-info"></i>  <br>
<code>PYTHONLIBS_FOUND</code>           - have the Python libs been found<br>
<code>PYTHON_LIBRARIES</code>           - path to the python library<br>
<code>PYTHON_INCLUDE_PATH</code>     - path to where Python.h is found (deprecated)<br>
<code>PYTHON_INCLUDE_DIRS</code>        - path to where Python.h is found<br>
<code>PYTHON_DEBUG_LIBRARIES</code>     - path to the debug library (deprecated)<br>
<code>PYTHONLIBS_VERSION_STRING</code>  - version of the Python libs found (since CMake 2.8.8)<br></div></p>
<hr>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">INCLUDE_DIRECTORIES</span><span class="params">($&#123;PYTHON_INCLUDE_PATH&#125;)</span></span></div></pre></td></tr></table></figure>
<p>将python的include路径加入编译的include路径中。</p>
<hr>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">INCLUDE_DIRECTORIES</span><span class="params">($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;)</span></span></div></pre></td></tr></table></figure>
<p>将当前路径加入到编译的include路径中。</p>
<hr>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">SET</span><span class="params">(CMAKE_SWIG_FLAGS <span class="string">""</span>)</span></span></div></pre></td></tr></table></figure>
<p><code>CMAKE_SWIG_FLAGS</code>可以用来设置给所有要调用swig的地方的参数，例如<code>-python</code>, <code>-c++</code>等</p>
<hr>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">SET_SOURCE_FILES_PROPERTIES</span><span class="params">(example.i PROPERTIES CPLUSPLUS ON)</span></span></div><div class="line"><span class="function"><span class="title">SET_SOURCE_FILES_PROPERTIES</span><span class="params">(example.i PROPERTIES SWIG_FLAGS <span class="string">"-includeall"</span>)</span></span></div></pre></td></tr></table></figure>
<p>如果某个swig生成的原代码需要某种参数就要通过这个macro进行设置，上面的第一个应该就相当于在swig的参数中添加<code>-c++</code>以生成<code>cxx</code>文件。</p>
<hr>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SWIG_ADD_MODULE(<span class="built_in">example</span> python <span class="built_in">example</span>.i <span class="built_in">example</span>.cxx)</div></pre></td></tr></table></figure>
<p>这个cmake函数是定义swig生成的最终模块的名称和封装的语言</p>
<hr>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">SWIG_LINK_LIBRARIES</span><span class="params">(example $&#123;PYTHON_LIBRARIES&#125;)</span></span></div></pre></td></tr></table></figure>
<p>将库与swig模块一起链接。上文已说明<code>PYTHON_LIBRARY</code>变量存放的是python库的路径。</p>
<h3 id="KMCLib中CMakeLists-txt中的swig"><a href="#KMCLib中CMakeLists-txt中的swig" class="headerlink" title="KMCLib中CMakeLists.txt中的swig"></a>KMCLib中CMakeLists.txt中的swig</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Make sure the swig package is loaded.</span></div><div class="line"><span class="keyword">find_package</span>(SWIG REQUIRED)</div><div class="line"><span class="keyword">include</span>(<span class="variable">$&#123;SWIG_USE_FILE&#125;</span>)</div><div class="line"></div><div class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)</div><div class="line"><span class="keyword">include_directories</span>( <span class="variable">$&#123;KMCLib_SOURCE_DIR&#125;</span>/src )</div><div class="line"></div><div class="line"><span class="comment"># Set the flags.</span></div><div class="line"><span class="keyword">set</span>(CMAKE_SWIG_FLAGS <span class="string">""</span>)</div><div class="line"></div><div class="line"><span class="comment"># Set the properties for the interface file.</span></div><div class="line"><span class="keyword">set_source_files_properties</span>(backend.i PROPERTIES CPLUSPLUS <span class="keyword">ON</span>)</div><div class="line"><span class="keyword">set_source_files_properties</span>(backend.i PROPERTIES SWIG_FLAGS <span class="string">""</span>)</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment"># Add the target.</span></div><div class="line">swig_add_module( Backend python backend.i )</div><div class="line"></div><div class="line"><span class="comment"># -----------------------------------------------------------------------------</span></div><div class="line"><span class="comment"># LINK</span></div><div class="line"><span class="comment"># -----------------------------------------------------------------------------</span></div><div class="line"></div><div class="line"><span class="keyword">message</span>( STATUS <span class="string">"Creating makefiles for system: $&#123;CMAKE_SYSTEM&#125;"</span>)</div><div class="line"><span class="comment"># For Mac OS X</span></div><div class="line"><span class="keyword">if</span>(<span class="variable">$&#123;CMAKE_SYSTEM_NAME&#125;</span> <span class="keyword">MATCHES</span> <span class="string">"Darwin"</span>)</div><div class="line"></div><div class="line">  <span class="comment"># To force a Mac OSX with macports Python, use with -DMACPORT=TRUE</span></div><div class="line">  <span class="keyword">if</span> (MACPORT)</div><div class="line">    <span class="keyword">set</span>(CMAKE_LIBRARY_PATH <span class="string">"/opt/local/Library/Frameworks"</span>)</div><div class="line">    <span class="keyword">message</span>( STATUS <span class="string">"Looking for libraries in $&#123;CMAKE_LIBRARY_PATH&#125;"</span> )</div><div class="line">  <span class="keyword">endif</span>()</div><div class="line"></div><div class="line">  <span class="keyword">find_library</span>( PYTHON_LIB python )</div><div class="line">  <span class="keyword">message</span>( STATUS <span class="string">"Using python library $&#123;PYTHON_LIB&#125;"</span>)</div><div class="line">  swig_link_libraries( Backend <span class="variable">$&#123;PYTHON_LIB&#125;</span> src )</div><div class="line"></div><div class="line"><span class="comment"># For Linux (Ubuntu 12.04 LTS)</span></div><div class="line"><span class="keyword">else</span>()<span class="comment">#$&#123;CMAKE_SYSTEM_NAME&#125; MATCHES "Linux")</span></div><div class="line">  swig_link_libraries( Backend src )</div><div class="line"><span class="keyword">endif</span>()</div></pre></td></tr></table></figure>
<p>按照上面的介绍，这里的cmake也不难理解了。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> Cpp </tag>
            
            <tag> swig </tag>
            
            <tag> CMake </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识代码封装工具SWIG]]></title>
      <url>http://pytlab.github.io/2016/04/02/%E5%88%9D%E8%AF%86%E4%BB%A3%E7%A0%81%E5%B0%81%E8%A3%85%E5%B7%A5%E5%85%B7SWIG/</url>
      <content type="html"><![CDATA[<p>这不是我最早使用swig了，之前在写Kynetix的时候就使用了swig为python封装了C语言写的扩展模块。但是当时我对C++还不是很了解，对其中的一些概念也只是拿来直接用，没有理解到底是什么，为什么会有这种功能。所以昨天我又拿出了《python科学计算》这本书来温习了一下swig那一部分，果然对swig又有了新的认识。</p>
<p>对swig真正全的使用都在swig的文档中有详细的介绍，而且由于swig支持很多种语言，例如java、python、Tcl等，因此这份文档内容相当的丰富。由于现在还没有很好的中文资源，所以现在只能默默的看英文文档了。</p>
<a id="more"></a>
<h3 id="SWIG用来做什么？"><a href="#SWIG用来做什么？" class="headerlink" title="SWIG用来做什么？"></a>SWIG用来做什么？</h3><p>swig是个封装器，它读取C/C++的函数或者类声明，并将这些函数或者类进行封装，生成一个封装代码，其中包含一个目标语言的文件供目标文件调用，还包含一个C/C++的封装文件以<code>&lt;source&gt;_wrap.c</code>或者<code>&lt;source&gt;_wrap.cxx</code>命名。这个生成的<code>_wrap.cxx</code>文件就是个封装文件，然后我们将这个封装文件同我们自己的C/C++代码或者是已经编译好的目标文件（<code>*.o</code>或者<code>*.obj</code>文件）或者库文件（<code>*.lib/*.a</code>文件）一起编译并连接，就会生成一个我们目标语言能够认识并且调用的模块。</p>
<p>其中的swig生成的封装代码的作用就是能够使得python与C/C++之间能够无阻碍的沟通，也就是</p>
<ul>
<li>将封装函数接收到的Python对象转换成C/C++能够处理的数据</li>
<li>有了数据以后便执行C/C++的函数</li>
<li>执行C/C++函数将返回值在转换成python对象返回给python代码去处理</li>
</ul>
<p><img src="/assets/images/blog_img/2016-04-02-在CMake中使用SWIG构建封装模块/swig.png" alt=""></p>
<h3 id="简单的操作"><a href="#简单的操作" class="headerlink" title="简单的操作"></a>简单的操作</h3><p>swig需要一个<code>*.i</code>文件，也就是swig接口文件(interface)告诉swig需要如何处理C/C++的数据、函数和类。</p>
<ol>
<li><p>先生成封装代码</p>
 <figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">swig </span>-c++ -python demo.i</div></pre></td></tr></table></figure>
<p> 这个命令就会生成python的封装代码，当前路径下会出现<code>demo.py</code>和<code>demo_wrap.cxx</code>文件。其中<code>demo.py</code>文件中是python代码，也就是一个壳子，他能够让python程序调用这个模块中的函数，但是函数的实体并不在里面，因为函数的实体是C/C++编译后的动态库文件。</p>
</li>
<li><p>编译封装代码<br> 这一步只说明生成的C/C++的封装代码是可以单独编译的，这就将封装同C/C++库分割开，我按照我的方式写C/C++代码不用管封装的事情，最后只要把wrap的目标文件链接起来就好了。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ g++ <span class="_">-f</span>PIC -c demo_wrap.cxx</div></pre></td></tr></table></figure>
<p> 需要注意的是<code>-fPIC</code>这个参数是一定要加的，不然就无法生成动态链接库。具体这个参数是做什么的，顾名思义就是生成一个位置独立的代码段，这样无论函数在哪都能够动态的调用这个动态库了，详见：<a href="http://stackoverflow.com/questions/5311515/gcc-fpic-option" target="_blank" rel="external">http://stackoverflow.com/questions/5311515/gcc-fpic-option</a></p>
</li>
<li><p>链接成扩展模块<br> 将封装文件与库文件链接成为python能够调用的动态库，这一步就好像是使用wrap这个文件给C/C++库文件进行化妆，化成python认识的那种样子。当然swig也可以根据使用者的需求把C/C++的库化妆成其他语言认识的样子如java、ruby等。<br> 这样就会生成一个<code>_demo.so</code>或者<code>_demo.pyd</code>的库文件，python可以通过之前的<code>demo.py</code>或者直接<code>_demo.pyd</code>来用自己的方式调用C/C++的函数和类来为自己服务。</p>
 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ g++ -shared demo_wrap<span class="selector-class">.o</span> demo<span class="selector-class">.c</span> -o _demo.so</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="关于类型映射"><a href="#关于类型映射" class="headerlink" title="关于类型映射"></a>关于类型映射</h3><p><code>.i</code>文件描述了如何创建封装文件，具体的语法我不在这里总结了可以直接去看文档。其中比较重要的部分就是如何让python和C/C++进行交流，比如如何处理python没有指针操作与C/C++传入指针的矛盾，如何处理python返回多个值与C/C++只能返回一个值的矛盾等。</p>
<p>类型映射就是一套规则，告诉swig如何将这些矛盾化解，并定义名称参数，将名称参数写道接口文件的类和函数声明中，让swig处理。<br>SWIG已经有了默认的一些类型映射，例如<code>* OUTPUT</code>, <code>* INPUT</code>, <code>* INOUT</code>等来告诉swig这些参数处理成python接口时候怎么处理。<br>例如如果我在接口文件中声明了一个C函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_multi</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> * OUTPUT, <span class="keyword">double</span> * OUTPUT)</span></span>;</div></pre></td></tr></table></figure></p>
<p>这时候swig就认出了OUTPUT是一种类型映射定义的名称参数，C语言修改这两个指针指向的值要处理成python调用这个函数返回这两个指针指向的值的list。</p>
<p>除了使用已定义的类型映射，swig还支持自定义的类型映射，这里我也不多讲了，以后如果在写类型映射的时候我会更新。</p>
<h3 id="回调Python函数"><a href="#回调Python函数" class="headerlink" title="回调Python函数"></a>回调Python函数</h3><p>这里主要是能够让C/C++代码调用python的函数。现在必须要理解这一点，因为KMCLib中就用到了这个，使得能够让用户使用python自定义RateCalculator然后重新定义C++的虚函数，是C++程序能够调用python类的方法。<br>我在这里举一个例子，就是在python中能够继承C++中定义的类，并且在python中重新定义C++类的虚函数。</p>
<ol>
<li><p>开启此功能，在接口文件中的模块名称定义中要加入<code>director</code>参数</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%<span class="keyword">module</span>(director=<span class="string">"1"</span>) demo</div></pre></td></tr></table></figure>
</li>
<li><p>在希望能够调用python函数的C++类中，通过<code>%feature</code>指令开启director功能：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%feature(<span class="string">"director"</span>) Sum;</div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p>我下面把别人的例子贴上来，方便以后自己回忆：</p>
<p>定义一个求和类：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Sum</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Sum() &#123;&#125;;</div><div class="line"></div><div class="line">    ~Sum() &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Cal</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;             <span class="comment">// 从start开始到end结束，将Func作用于中间的整数然后球和。</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Func</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> x &#125;; <span class="comment">// python 中的Sum类的子类可以重写这个虚函数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在接口文件中我们放入此类的声明的时候开启”director”功能：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">%feature(<span class="string">"director"</span>) Sum</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Sum() &#123;&#125;;</div><div class="line"></div><div class="line">    ~Sum() &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Cal</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>; </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Func</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> x &#125;; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样在python中我们就可以这么用了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> demo</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumReciprocal</span><span class="params">(demo.Sum)</span>:</span>  <span class="comment"># Sum类的派生类</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Func</span><span class="params">(self, x)</span>:</span>          <span class="comment"># 重写Sum的Func虚方法</span></div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>/x</div></pre></td></tr></table></figure></p>
<p>然后我们就可以直接在python中使用这个重写过Sum类方法的子类了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>swig很强大，能够熟练使用，是快速而且方便独立的构建python语言以及其他动态语言的扩展模块，真是感觉我站在了巨人的肩膀上了。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> swig </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[KMCLib中的Matcher]]></title>
      <url>http://pytlab.github.io/2016/03/31/KMCLib%E4%B8%AD%E7%9A%84Matcher/</url>
      <content type="html"><![CDATA[<p>这个类算是KMCLib中最后一个大类了，也回答了我在看代码之初有的很多疑问，例如如何更新匹配相关的信息，如何更新事件列表等。<br>这个类是没有成员数据的，可以把<code>Matcher</code>类看作是与匹配相关的函数的封装。</p>
<p>但是在头文件中却定义了两个相关的结构来存储操作信息：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// A minimal struct for representing a task with a rate.</span></div><div class="line"><span class="keyword">struct</span> RateTask</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> index;</div><div class="line">    <span class="keyword">int</span> process;</div><div class="line">    <span class="keyword">double</span> rate;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/// A minimal struct for representing a remove task.</span></div><div class="line"><span class="keyword">struct</span> RemoveTask</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> index;</div><div class="line">    <span class="keyword">int</span> process;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><ul>
<li><p><code>void calculateMatching()</code><br>  原型：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculateMatching</span><span class="params">(Interactions &amp; interactions,</span></span></div><div class="line">                       Configuration &amp; configuration,</div><div class="line">                       <span class="keyword">const</span> LatticeMap &amp; lattice_map,</div><div class="line">                       <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; indices) <span class="keyword">const</span>;</div></pre></td></tr></table></figure>
<p>  此函数就把参数中的indices对应的元素用所有的process进行匹配，从而将process中的信息进行更新，例如有些点已经不能发生此process则要针对这个process中进行删除操作。执行这个函数后interactions中的process都会进行更新。</p>
</li>
<li><p><code>void Matcher::matchIndicesWithProcesses()</code><br>  原型：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Matcher::matchIndicesWithProcesses(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; &amp; index_process_to_match,</div><div class="line">                                        <span class="keyword">const</span> Interactions  &amp; interactions,</div><div class="line">                                        <span class="keyword">const</span> Configuration &amp; configuration,</div><div class="line">                                        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;RemoveTask&gt; &amp; remove_tasks,</div><div class="line">                                        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;RateTask&gt;   &amp; update_tasks,</div><div class="line">                                        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;RateTask&gt;   &amp; add_tasks) <span class="keyword">const</span></div></pre></td></tr></table></figure>
<p>  此函数主要用于从<code>index_process_to_match</code>中根据匹配的情况将其分类到不同的任务中，例如本身不能匹配的但是现在能匹配上的就执行添加操作，就将位点和process的index以及process的速率放入到add_tasks中。其他情况也是类似的。这样执行完这个函数，remove_tasks, update_tasks, add_tasks将会被填充。</p>
</li>
<li><p><code>void Matcher::updateProcesses()</code><br>  原型：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Matcher::updateProcesses(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;RemoveTask&gt; &amp; remove_tasks,</div><div class="line">                              <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;RateTask&gt;   &amp; update_tasks,</div><div class="line">                              <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;RateTask&gt;   &amp; add_tasks,</div><div class="line">                              Interactions &amp; interactions) <span class="keyword">const</span></div></pre></td></tr></table></figure>
<p>  此函数读取上面的三个tasks列表，根据列表进行相应的process更新操作，主要是更新process的site和rate等成员数据的值。函数执行后，相应的process将全部更新。</p>
</li>
</ul>
<p>此函数还有两个函数分别是</p>
<ul>
<li><p><code>void Matcher::updateRates()</code></p>
</li>
<li><p><code>double Matcher::updateSingleRate()</code></p>
</li>
</ul>
<p>这是个回调函数，具体用途上没发现，后面进行补充。</p>
]]></content>
      
        <categories>
            
            <category> 学术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> catalysis </tag>
            
            <tag> chemistry </tag>
            
            <tag> Cpp </tag>
            
            <tag> 学术 </tag>
            
            <tag> Monte Carlo </tag>
            
            <tag> KMCLib </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[发现了KMCLib中的数组内存越界隐患]]></title>
      <url>http://pytlab.github.io/2016/03/29/%E5%8F%91%E7%8E%B0%E4%BA%86KMCLib%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E8%B6%8A%E7%95%8C%E9%9A%90%E6%82%A3/</url>
      <content type="html"><![CDATA[<p>之前在看代码的时候就发现了这个问题，就是在初始化configuration的match_lists的时候，最后一步是为configuration分配内存空间，但是作者使用的是match_lists中的第一个minimal_match_list的长度来分配内存，这样就留下了数组越界的隐患，我写了个单元测试，测试了下，果然！<br><strong>因为由于周期性边界条件的原因，第一个minimal_match_list可能并不是长度最长的</strong><br><br><br>于是我就向leetmaa/KMCLib的主分支提交了自己的代码，今天他接受了我的pull requests。具体的pull request信息以及我做的bug修复就不多扯了，贴上github上的链接来好了：<br><a href="https://github.com/leetmaa/KMCLib/pull/5" target="_blank" rel="external"><span class="fa fa-github"></span> Fix the out-of-bound bug by PytLab · Pull Request #5 · leetmaa/KMCLib</a></p>
]]></content>
      
        <categories>
            
            <category> 学术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Git </tag>
            
            <tag> Monte Carlo </tag>
            
            <tag> KMCLib </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[KMCLib中的Interactions]]></title>
      <url>http://pytlab.github.io/2016/03/29/KMCLib%E4%B8%AD%E7%9A%84Interactions/</url>
      <content type="html"><![CDATA[<p>这两天由于一直在学习CMake相关的东西，没有把看的代码及时总结。特地现在补上。<br>Interaction类可以看作是process相应的集合，他在全局角度操作process。</p>
<h3 id="成员数据"><a href="#成员数据" class="headerlink" title="成员数据"></a>成员数据</h3><ul>
<li><p><code>std::vector&lt;Process&gt; processes_</code><br>  通过构造函数的参数传入，是所有能在lattice上面发生的process对象的集合。</p>
</li>
<li><p><code>std::vector&lt;Process*&gt; process_pointers_</code><br>  存放指向processes_中process对象的指针，后面的函数都是在操作这个指针vector。</p>
</li>
<li><p><code>std::vector&lt;std::pair&lt;double,int&gt; &gt; probability_table_</code><br>  这里叫做概率列表，其实里面并没有放于概率的数据，其中的pair的第一个entry放的是incremental rate，第二个entry放的是对应这个process能在当前lattice上面发生的位点的总数(也就是他的nSite数)。</p>
</li>
<li><p><code>bool implicit_wildcards_</code><br>  是否使用通配符</p>
</li>
<li><p><code>bool use_custom_rates_</code><br>  是否使用自定义速率</p>
</li>
</ul>
<p>其他的几个成员数据目前还没有看到具体怎么用，先挖个坑，后面填。</p>
<a id="more"></a>
<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>这里也只是拎出来几个重要的。</p>
<ul>
<li><p><code>int Interactions::totalAvailableSites() const</code><br>  计算整个lattice中能够发生process(无论是哪个process)的位点的总数。</p>
</li>
<li><p><code>void Interactions::updateProbabilityTable()</code><br>  probability_table_这个变量在构造函数中初始化为与processes_长度相同全部为<0.0, 0="">的vector。<br>  这个函数就是使用两个迭代器遍历processes_和probability_table_，然后将总速率叠加，并将相应的nSite填充到probability_table_中，结构我用下面的列向量来进行表示：<br>$$<br>\left[\begin{matrix}<br>   k_{0} &amp; n_{0} \\<br>   k_{0} + k_{1} &amp; n_{1}\\<br>   k_{0} + k_{1} + k_{2} &amp; n_{2}\\<br>   . &amp; .\\<br>   . &amp; .\\<br>   . &amp; .\\<br>\end{matrix} \right]<br>$$</0.0,></p>
</li>
<li><p><code>int Interactions::pickProcessIndex() const</code><br>  此函数的作用是在probability_table中随机抽取一种process，并返回此process在列表中的索引号。<br>  这里算是kMC中比较重要的一个函数了，虽然代码不多，但是却可以在上面做文章。关键点就在于用什么算法进行查找并抽取事件。<br>  这里KMCLib的作者直接使用了STL中的lower_bound函数，此函数内部是通过二分查找实现定位，也就是说此查找的复杂度为 $O(logN)$</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> T&gt;</div><div class="line">    <span class="function">ForwardIterator <span class="title">lower_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last, <span class="keyword">const</span> T&amp; val)</span></span></div><div class="line">    &#123;</div><div class="line">        ForwardIterator it;</div><div class="line">        iterator_traits&lt;ForwardIterator&gt;::difference_type count, step;</div><div class="line">        count = distance(first,last);</div><div class="line">        <span class="keyword">while</span> (count&gt;<span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            it = first; step=count/<span class="number">2</span>; advance (it,step);</div><div class="line">            <span class="keyword">if</span> (*it&lt;val) &#123;                 <span class="comment">// or: if (comp(*it,val)), for version (2)</span></div><div class="line">            first=++it;</div><div class="line">            count-=step+<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> count=step;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> first;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><br></p>
<ul>
<li><p><code>void Interactions::updateProcessMatchLists()</code><br>  该函数的原型：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Interactions::updateProcessMatchLists(<span class="keyword">const</span> Configuration &amp; configuration,</div><div class="line">                                           <span class="keyword">const</span> LatticeMap &amp; lattice_map)</div></pre></td></tr></table></figure>
<p>  此函数算是interaction类中最复杂的一个成员函数了。其作用是更新所有process的matchlist。通过将process的match list与configuration的minimal match list进行匹配，也就是使用两个迭代器分别遍历向量，判断entry是否相等，（根据MinimalMatchListEntry的运算符重载函数，相等也就意味着元素类型和相应的坐标都相等）。如果不相等就在process的matchlist中插入通配符<code>*</code>，若相等就要记录位置索引（因为插入通配符的原因，索引会发生偏移）。最后更新process中相关的信息即可。</p>
<p>  <strong>我结合着其中的unittest来把这个东东的图像总结出来：</strong><br>  首先建个3x3x3的lattice map，初始化一个configuration，其中每个各点有2个basis_points，分别初始化为：</p>
  <figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(V, <span class="keyword">B), </span>(V, <span class="keyword">B), </span>(V, <span class="keyword">B), </span>(V, <span class="keyword">B), </span>...</div></pre></td></tr></table></figure>
<p>  其中的坐标分别为:</p>
  <figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">( (0<span class="selector-class">.0</span>, 0<span class="selector-class">.0</span>, 0<span class="selector-class">.0</span>), (0<span class="selector-class">.3</span>, 0<span class="selector-class">.3</span>, 0<span class="selector-class">.3</span>) ), (1<span class="selector-class">.0</span>, 1<span class="selector-class">.0</span>, 1<span class="selector-class">.0</span>), (1<span class="selector-class">.3</span>, 1<span class="selector-class">.3</span>, 1<span class="selector-class">.3</span>) ), ( (...), (...) ), ...</div></pre></td></tr></table></figure>
<p>  可能的所有元素类型映射:</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"*"</span>: <span class="number">0</span>, <span class="string">"A"</span>: <span class="number">1</span>, <span class="string">"B"</span>:<span class="number">2</span>, <span class="string">"C"</span>: <span class="number">3</span></div></pre></td></tr></table></figure>
<p>  在创建一个process,其中包含三个元素,<br>  元素类型为：</p>
  <figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">A</span>, B, V --&gt; B, <span class="keyword">A</span>, <span class="keyword">A</span></div></pre></td></tr></table></figure>
<p>  在执行此函数之后,程序会向process的match_list中插入相应的通配符,这样能够与configuration中minimal_match_list的顺序匹配上,当然直到process或者configuration的minimal_match_list的迭代器到达超尾位置,这种插入操作就终止了,然后更新process中的move_id相关信息.<br>  操作之后按照下图的顺序:<br>  <img src="assets/images/blog_img/2016-03-29-KMCLib中的Interactions/lattice.png" alt=""><br>  则process的minimal_match_list元素顺序就更新为:</p>
  <figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A, V, *, *, *, B</div><div class="line"><span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span></div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> catalysis </tag>
            
            <tag> chemistry </tag>
            
            <tag> Cpp </tag>
            
            <tag> 学术 </tag>
            
            <tag> KMCLib </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于CMake中添加共享库]]></title>
      <url>http://pytlab.github.io/2016/03/27/%E5%85%B3%E4%BA%8ECMake%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%B1%E4%BA%AB%E5%BA%93/</url>
      <content type="html"><![CDATA[<p>这两天学习一下CMake的一点语法，为了以后能使用CMake跨平台构建项目。但是在为target添加共享库的时候，即使我在CMakeLists.txt中使用了<code>LINK_DIRECTORIES()</code>和<code>TARGET_LINK_LIBRARIES()</code>，<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">ADD_EXECUTABLE</span><span class="params">(hellomain main.c)</span></span></div><div class="line"><span class="function"><span class="title">SET</span><span class="params">(EXECUTABLE_OUTPUT_PATH $&#123;HELLOMAIN_BINARY_DIR&#125;/bin)</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="title">INCLUDE_DIRECTORIES</span><span class="params">(BEFORE /mnt/hgfs/CentOS_code/cmake_practice/t4/zjshao/include/hello)</span></span></div><div class="line"><span class="function"><span class="title">LINK_DIRECTORIES</span><span class="params">(/mnt/hgfs/CentOS_code/cmake_practice/t4/zjshao/lib)</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="title">TARGET_LINK_LIBRARIES</span><span class="params">(hellomain libhello.so)</span></span></div></pre></td></tr></table></figure></p>
<p>但是在make的时候还是很出现了<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">/usr/</span>bin/<span class="string">ld:</span> cannot find -lhello</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>在看过别人的CMakeLists.txt之后，才知道是我cmake指令的顺序有问题，改成如下这样便可以找到链接库了：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">SET</span><span class="params">(EXECUTABLE_OUTPUT_PATH $&#123;HELLOMAIN_BINARY_DIR&#125;/bin)</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="title">INCLUDE_DIRECTORIES</span><span class="params">(BEFORE /mnt/hgfs/CentOS_code/cmake_practice/t4/zjshao/include/hello)</span></span></div><div class="line"><span class="function"><span class="title">LINK_DIRECTORIES</span><span class="params">(/mnt/hgfs/CentOS_code/cmake_practice/t4/zjshao/lib)</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="title">ADD_EXECUTABLE</span><span class="params">(hellomain main.c)</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="title">TARGET_LINK_LIBRARIES</span><span class="params">(hellomain libhello.so)</span></span></div></pre></td></tr></table></figure></p>
<p>也就是说在<code>ADD_EXECUTABLE()</code>之前就要将<code>LINK_DIRECTORIES</code>和<code>INCLUDE_DIRECTORIES</code>设置好。</p>
]]></content>
      
        
        <tags>
            
            <tag> C </tag>
            
            <tag> 随笔 </tag>
            
            <tag> Cpp </tag>
            
            <tag> CMake </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[消除蛋疼的^M]]></title>
      <url>http://pytlab.github.io/2016/03/25/%E6%B6%88%E9%99%A4%E8%9B%8B%E7%96%BC%E7%9A%84-M/</url>
      <content type="html"><![CDATA[<p>在github上面向别人的项目代码pull request的时候遇到了一个蛋疼的问题，问题都在一个字符上面就是<code>^M</code>，我的代码虽然只修改了几行代码，但是使用<code>git diff</code>的时候发现整个文件全部修改了。</p>
<p></p><p><br>原因就是我修改的文件在每一行末尾都新增了一个<code>^M</code>字符，这样就导致每一行都和以前不同diff的时候自然就全部不同了，这样就非常的蛋疼，向别人项目中pull request的时候一整片红色和一整片绿色，别人包括我自己都不知道我到底是修改的哪一部分，感觉像是在捣乱的。。。像这样的pull request人家才不会给我merge呢。</p>
<p></p><p><br>真是太不好意思了，诶…效果就是这蛋疼的下图：<br><a id="more"></a><br><img src="assets/images/blog_img/2016-03-25-消除蛋疼的-M/git-diff.png" alt=""></p>
<p><br></p>
<h4 id="那造成这种的原因是什么呢？"><a href="#那造成这种的原因是什么呢？" class="headerlink" title="那造成这种的原因是什么呢？"></a>那造成这种的原因是什么呢？</h4><p>原因就是我用的是windows而写项目的人是使用的*nix。在一般的C语言入门书里的关于I/O的章节中应该都有写过，就是Windows和*nix的文本文件中的换行符是不同的。</p>
<p></p><p><br><strong>在Windows中</strong>：使用<code>\r\n</code>来标志换行的，也就是所谓的<em>CR TF</em>，其中<em>CR</em>的全称是<em>Carriage Return</em> ,或者表示为<code>\r</code>, 意思是回车。<em>LF</em>全称是<em>Line Feed</em>，它才是真正意义上的换行表示符。<br><strong>在Linux中</strong>：使用的只有<code>\n</code>即<em>LF</em>来表示换行。</p>
<p>这样我在Windows下修改的文件在每次换行的时候都会有一个多余的<code>\r</code>了。</p>
<p><br></p>
<h4 id="如何解决这个问题？"><a href="#如何解决这个问题？" class="headerlink" title="如何解决这个问题？"></a>如何解决这个问题？</h4><p>在github官网有针对这个问题的解决方案：<a href="https://help.github.com/articles/dealing-with-line-endings/" target="_blank" rel="external">https://help.github.com/articles/dealing-with-line-endings/</a><br>使Git在<code>git diff</code>的时候能够忽略操作系统之间换行符的差异。</p>
<p>总结起来就是两个方法：</p>
<ol>
<li><p>全局设置<br> 使用<code>git config core.autocrlf</code>来告诉Git如何处理行尾的换行符</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global core.autocrlf true</div><div class="line"># Configure Git on Windows to properly handle line endings</div></pre></td></tr></table></figure>
</li>
<li><p>针对某个项目而不是全局设置<br> 这样就需要在项目的根目录中添加<code>.gitattributes</code>文件，在文件中配置当前项目。<br> 关于<code>.gitattributes</code>文件的格式，官网有解释，就好象是包含了两列的列表，第一列是Git需要匹配的文件名称，第二列是配置参数。</p>
 <figure class="highlight vhdl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># Set the <span class="keyword">default</span> behavior, <span class="keyword">in</span> <span class="keyword">case</span> people don<span class="symbol">'t</span> have core.autocrlf set.</div><div class="line">* <span class="literal">text</span>=auto</div><div class="line"></div><div class="line"># Explicitly declare <span class="literal">text</span> files you want <span class="keyword">to</span> always be normalized <span class="keyword">and</span> converted</div><div class="line"># <span class="keyword">to</span> native <span class="literal">line</span> endings <span class="keyword">on</span> checkout.</div><div class="line">*.c <span class="literal">text</span></div><div class="line">*.h <span class="literal">text</span></div><div class="line"></div><div class="line"># Declare files that will always have CRLF <span class="literal">line</span> endings <span class="keyword">on</span> checkout.</div><div class="line">*.sln <span class="literal">text</span> eol=crlf</div><div class="line"></div><div class="line"># Denote <span class="keyword">all</span> files that are truly binary <span class="keyword">and</span> should <span class="keyword">not</span> be modified.</div><div class="line">*.png binary</div><div class="line">*.jpg binary</div></pre></td></tr></table></figure>
<p> 左边是文件名称：<code>*.c</code>, <code>*.sln</code>, <code>*.png</code><br> 右边是配置参数：<code>text</code>, <code>text eol=crlf</code>, <code>binary</code></p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Git </tag>
            
            <tag> Vim </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[KMCLib中的Configuration]]></title>
      <url>http://pytlab.github.io/2016/03/24/KMCLib%E4%B8%AD%E7%9A%84Configuration/</url>
      <content type="html"><![CDATA[<p>这个类由于在之前都有提及到，而且已经针对其中重要的成员函数进行了分析，在这里就不多扯了。<br>总之这个类是独立于晶格LatticeMap类的类型类，我还剩听佩服作者这样抽象的，这样如果后面我想加入多位点的话，也可以独立于晶格之外描述多位点的类，这样实现起来耦合量可以尽量减小。</p>
<p>其实这里我一直有个疑问，不知道看完全部代码的时候能不能找到答案，就是在<code>performProcess()</code>函数中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Configuration::performProcess(Process &amp; process,</div><div class="line">                                   <span class="keyword">const</span> <span class="keyword">int</span> site_index,</div><div class="line">                                   <span class="keyword">const</span> LatticeMap &amp; lattice_map)</div></pre></td></tr></table></figure></p>
<p>根本就没有用到这个变量，为啥要传他进来？？</p>
]]></content>
      
        <categories>
            
            <category> 学术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> catalysis </tag>
            
            <tag> chemistry </tag>
            
            <tag> Cpp </tag>
            
            <tag> 学术 </tag>
            
            <tag> KMCLib </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于KMCLib中的Move]]></title>
      <url>http://pytlab.github.io/2016/03/24/%E5%85%B3%E4%BA%8EKMCLib%E4%B8%AD%E7%9A%84Move/</url>
      <content type="html"><![CDATA[<p>move来源于process并作用于configuration。</p>
<h3 id="Process中的move相关"><a href="#Process中的move相关" class="headerlink" title="Process中的move相关"></a>Process中的move相关</h3><h4 id="Process中与move相关的变量："><a href="#Process中与move相关的变量：" class="headerlink" title="Process中与move相关的变量："></a>Process中与move相关的变量：</h4><ul>
<li><p><code>std::vector&lt;int&gt; move_origins</code><br>  说明在process中那些元素是在process发生时有移动的，(0, 1)的话就是指第一个（中心）和第二个元素发生了移动。</p>
</li>
<li><p><code>std::vector&lt;Coordinate&gt; move_vectors</code><br>  对应move_origin的元素移动的向量。</p>
</li>
<li><p><code>std::vector&lt; std::pair&lt;int,int&gt; &gt; id_moves_</code><br>  用于描述元素移动前后位置的变化，通过元素在process中的minimal_match_list中的索引号来表示，例如<br>  id_moves_[0]中存放着两个值 (1, 4)，则就说明在minimal_match_list中的第1号元素（也就是第二个）通过process的作用之后会移动到第4号位置上。</p>
<a id="more"></a>
<p>  变化如下图所示：<br>  <img src="assets/images/blog_img/2016-03-24-关于KMCLib中的Move/move.png" alt=""><br>  因此对应上图的id_moves_的内容为：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;1, 4&gt;, &lt;4, 2&gt;, &lt;2, 0&gt;, &lt;0, 1&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Process中相关的成员方法"><a href="#Process中相关的成员方法" class="headerlink" title="Process中相关的成员方法"></a>Process中相关的成员方法</h4><p>有process只是描述变化的信息，因此只要把移动相关的索引值和移动向量添加到process的minimal_match_list中即可，麻烦的操作在configuration那里。</p>
<h3 id="Configuration中的move相关"><a href="#Configuration中的move相关" class="headerlink" title="Configuration中的move相关"></a>Configuration中的move相关</h3><h4 id="Configuration与move相关的成员变量"><a href="#Configuration与move相关的成员变量" class="headerlink" title="Configuration与move相关的成员变量"></a>Configuration与move相关的成员变量</h4><ul>
<li><p><code>int n_moved_</code><br>  记录在一次process执行时有多少元素发生了改变（只要是前后元素类型不一致且不是通配符的时候，这个值就自加1，每次执行process时这个值会先重置。</p>
</li>
<li><p><code>std::vector&lt;int&gt; moved_atom_ids_</code><br>  记录在process中有移动过的元素的全局id号，例如若其中的值为：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">| <span class="number">1434</span> | <span class="number">150</span> | ...</div></pre></td></tr></table></figure>
<p>  则代表id为1434和150的元素发生了移动</p>
</li>
<li><p><code>std::vector&lt;Coordinate&gt; recent_move_vectors_</code><br>  存储对应moved_atom_ids元素的移动向量值</p>
</li>
<li><p><code>std::vector&lt;std::string&gt; elements_</code><br>  与move间接相关，以为位置的移动会改变elements的排列。</p>
</li>
<li><p><code>std::vector&lt;int&gt; types_</code><br>  与上一条的原因相同</p>
</li>
<li><p><code>std::vector&lt;std::string&gt; atom_id_elements_</code><br>  这个值其实与移动无关，毕竟移动并不会改变id对应的元素类型，但是process仍然会造成这个值的改变，不是移动，而是通过直接的替换。</p>
</li>
<li><p><code>std::vector&lt;int&gt; atom_id_</code><br>  因为移动，所以必定会造成id之间的互换。</p>
</li>
<li><p><code>std::vector&lt; std::vector&lt;MinimalMatchListEntry&gt; &gt; match_lists_</code><br>  全局晶格的元素发生了移动或者替换，必定需要更新configuration的match_lists_中的数据，但是其实只需要更新match_type就好了，位置不会变（晶格没有变动），configuration的minimal_match_list不存储移动相关的数据。</p>
</li>
</ul>
<h4 id="Configuration与move相关的成员函数"><a href="#Configuration与move相关的成员函数" class="headerlink" title="Configuration与move相关的成员函数"></a>Configuration与move相关的成员函数</h4><ul>
<li><p>performProcess()</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Configuration::performProcess(Process &amp; process,</div><div class="line">                                   <span class="keyword">const</span> <span class="keyword">int</span> site_index,</div><div class="line">                                   <span class="keyword">const</span> LatticeMap &amp; lattice_map)</div></pre></td></tr></table></figure>
<p>  不得不吐槽这个函数让我看了很久，不过也要感谢这个函数，他让我把KMCLib的最难理解的部分搞清楚了。<br>  这个函数中同时移动着<strong>5个</strong>迭代器</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 遍历process中的minimal_match_list</span></div><div class="line"><span class="keyword">auto</span> it1 = process_match_list.begin();</div><div class="line"></div><div class="line"><span class="comment">// 遍历全局晶格中某点的minimal_match_list</span></div><div class="line"><span class="keyword">auto</span> it2 = site_match_list.begin();</div><div class="line"></div><div class="line"><span class="comment">// 下面三个都用于用记录信息的</span></div><div class="line"><span class="keyword">auto</span> it3 = process.affectedIndices().begin();</div><div class="line"><span class="keyword">auto</span> it4 = moved_atom_ids_.begin();</div><div class="line"><span class="keyword">auto</span> it5 = recent_move_vectors_.begin();</div></pre></td></tr></table></figure>
</li>
</ul>
<p><br></p>
<h4 id="我在这里决定把这个函数贴上来通过注释的方式解读这段代码："><a href="#我在这里决定把这个函数贴上来通过注释的方式解读这段代码：" class="headerlink" title="我在这里决定把这个函数贴上来通过注释的方式解读这段代码："></a>我在这里决定把这个函数贴上来通过注释的方式解读这段代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Configuration::performProcess(Process &amp; process,</div><div class="line">                                   <span class="keyword">const</span> <span class="keyword">int</span> site_index,</div><div class="line">                                   <span class="keyword">const</span> LatticeMap &amp; lattice_map)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// PERFORMME</span></div><div class="line">    <span class="comment">// Need to time and optimize the new parts of the routine.</span></div><div class="line"></div><div class="line">    <span class="comment">// Get the proper match lists.</span></div><div class="line">    <span class="comment">// 同时获取相对应的两个minimal_match_list的迭代器用于遍历容器</span></div><div class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;MinimalMatchListEntry&gt; &amp; process_match_list = process.minimalMatchList();</div><div class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;MinimalMatchListEntry&gt; &amp; site_match_list    = minimalMatchList(site_index);</div><div class="line"></div><div class="line">    <span class="comment">// Iterators to the match list entries.</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;MinimalMatchListEntry&gt;::const_iterator it1 = process_match_list.begin();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;MinimalMatchListEntry&gt;::const_iterator it2 = site_match_list.begin();</div><div class="line"></div><div class="line">    <span class="comment">// Iterators to the info storages.</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it3 = process.affectedIndices().begin();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it4 = moved_atom_ids_.begin();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Coordinate&gt;::iterator it5 = recent_move_vectors_.begin();</div><div class="line"></div><div class="line">    <span class="comment">// Reset the moved counter.</span></div><div class="line">    n_moved_ = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Loop over the match lists and get the types and indices out.</span></div><div class="line">    <span class="keyword">for</span>( ; it1 != process_match_list.end(); ++it1, ++it2)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// Get the type out of the process match list.</span></div><div class="line">        <span class="comment">// 这里应该被更新的元素类型，</span></div><div class="line">        <span class="comment">// 如果process没有改变类型则与(*it2).match_type的值是相同的</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">int</span> update_type = (*it1).update_type;</div><div class="line"></div><div class="line">        <span class="comment">// Get the index out of the configuration match list.</span></div><div class="line">        <span class="comment">// 这个元素在全局晶格中的索引值，因为之后的所有操作都离不开这个索引值来定位，</span></div><div class="line">        <span class="comment">// 都是在这个位置上进行一系列操作的</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">int</span> index = (*it2).index;</div><div class="line"></div><div class="line">        <span class="comment">// <span class="doctag">NOTE:</span> The &gt; 0 is needed for handling the wildcard match.</span></div><div class="line">        <span class="comment">// 如果类型的确是发生了改变，就需要更新一系列的数据</span></div><div class="line">        <span class="keyword">if</span> (types_[index] != update_type &amp;&amp; update_type &gt; <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">// Get the atom id to apply the move vector to.</span></div><div class="line">            <span class="comment">// 获取原本位置上的元素的id号</span></div><div class="line">            <span class="keyword">const</span> <span class="keyword">int</span> atom_id = atom_id_[index];</div><div class="line"></div><div class="line">            <span class="comment">// Apply the move vector to the atom coordinate.</span></div><div class="line">            <span class="comment">// 由于发生了移动，这个id的元素的位置要进行更新</span></div><div class="line">            atom_id_coordinates_[atom_id] += (*it1).move_coordinate;</div><div class="line"></div><div class="line">            <span class="comment">// Set the type at this index.</span></div><div class="line">            <span class="comment">// 修改全局晶格的信息</span></div><div class="line">            <span class="comment">// 以前晶格位置上的类型进行更新</span></div><div class="line">            types_[index]    = update_type;  </div><div class="line">            elements_[index] = type_names_[update_type];</div><div class="line"></div><div class="line">            <span class="comment">// Update the atom id element.</span></div><div class="line">            <span class="comment">// 这里主要是针对直接替换掉的元素而不是移动造成的元素变更</span></div><div class="line">            <span class="comment">// 正常通过移动是无法改变id对应元素类型的</span></div><div class="line">            <span class="keyword">if</span> (!(*it1).has_move_coordinate)</div><div class="line">            &#123;</div><div class="line">                atom_id_elements_[atom_id] = elements_[index];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Mark this index as affected.</span></div><div class="line">            <span class="comment">// 下面这些都是记录一些信息</span></div><div class="line"></div><div class="line">            <span class="comment">// 这个process改动了的全局晶格索引</span></div><div class="line">            (*it3) = index;</div><div class="line">            ++it3;</div><div class="line"></div><div class="line">            <span class="comment">// Mark this atom_id as moved.</span></div><div class="line">            <span class="comment">// 哪些元素被移动了</span></div><div class="line">            (*it4) = atom_id;</div><div class="line">            ++it4;</div><div class="line">            ++n_moved_;</div><div class="line"></div><div class="line">            <span class="comment">// Save this move vector.</span></div><div class="line">            <span class="comment">// 保存相应元素的移动坐标，如果是直接替换这里应该是(0.0, 0.0, 0.0)</span></div><div class="line">            (*it5) = (*it1).move_coordinate;</div><div class="line">            ++it5;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 下面的操作时用来更新atom_ids_</span></div><div class="line">    <span class="comment">// 由于元素通过process进行了位置的移动，相应的atom_ids中的顺序也要进行及时的更新</span></div><div class="line">    <span class="comment">// Perform the moves on all involved atom-ids.</span></div><div class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; &amp; process_id_moves = process.idMoves();</div><div class="line"></div><div class="line">    <span class="comment">// Local vector to store the atom id updates in.</span></div><div class="line">    <span class="comment">// 这个pair里面放了关于什么元素移动到了哪里的信息，例如</span></div><div class="line">    <span class="comment">// &lt;元素id, 移动到的晶格索引号（也就是位置）&gt;</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; id_updates(process_id_moves.size());</div><div class="line"></div><div class="line">    <span class="comment">// Setup the id updates list.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; process_id_moves.size(); ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">int</span> match_list_index_from = process_id_moves[i].first;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">int</span> match_list_index_to   = process_id_moves[i].second;</div><div class="line"></div><div class="line">        <span class="comment">// 获取在全局晶格中跳动的起始位置和终点位置（这里都是用索引号确定的）</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">int</span> lattice_index_from = site_match_list[match_list_index_from].index;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">int</span> lattice_index_to   = site_match_list[match_list_index_to].index;</div><div class="line"></div><div class="line">        id_updates[i].first  = atom_id_[lattice_index_from];  <span class="comment">// 什么元素（id号）</span></div><div class="line">        id_updates[i].second = lattice_index_to;              <span class="comment">// 移动到了全局的哪里（全局索引号）</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Apply the id updates on the configuration.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; id_updates.size(); ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">int</span> id    = id_updates[i].first;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">int</span> index = id_updates[i].second;</div><div class="line"></div><div class="line">        <span class="comment">// Set the atom id at this lattice site index.</span></div><div class="line">        atom_id_[index] = id;                      <span class="comment">// 跳到的地方把元素id更新</span></div><div class="line">        atom_id_elements_[id] = elements_[index];  <span class="comment">// 更新元素相应的元素类型，感觉没必要？</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>void Configuration::updateMatchList(const int index)</code><br>  process执行过后需要对configuration的match_lists_进行更新，但是这里只需要对里面的match_type进行更新就可以了。<br>  但是这个成员是对minmal_match_list的更新时针对一个index的minimal_match_list的，所以我猜测后面他会用他对发生反应的周围nearst neighbor和the next nearst neighbor的每个index。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> catalysis </tag>
            
            <tag> chemistry </tag>
            
            <tag> Cpp </tag>
            
            <tag> 学术 </tag>
            
            <tag> KMCLib </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[KMCLib中的match_list]]></title>
      <url>http://pytlab.github.io/2016/03/24/KMCLib%E4%B8%AD%E7%9A%84match-list/</url>
      <content type="html"><![CDATA[<p>match_list是由MinimalMatchList类对象组成的vector。</p>
<h3 id="MinimalMatchListEntry类"><a href="#MinimalMatchListEntry类" class="headerlink" title="MinimalMatchListEntry类"></a>MinimalMatchListEntry类</h3><p>这其实是一个结构，用于存储每个位点相关的信息，或者说每个minimal_match_list中的元素。</p>
<ul>
<li><p><code>bool has_move_coordinate;</code><br>  用于标记这个元素是否移动，<br>  通常在创建process对象时候提供了move_origin和move_vector时会将此值设为true;</p>
</li>
<li><p><code>Coordinate move_coordinate;</code><br>  这个元素如果有移动，他的移动向量，<br>  通常在创建process对象时候提供了move_origin和move_vector时会将此值设为move_vector中的值。</p>
</li>
<li><p><code>int match_type;</code><br>  主要用于process中，存储process之<strong>前</strong>的元素类型int</p>
</li>
<li><p><code>int update_type;</code><br>  主要用于process中，存储process之<strong>后</strong>的元素类型int</p>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p><code>int index;</code><br>  此处元素在全局中的索引值</p>
</li>
<li><p><code>int move_cell_i;</code></p>
</li>
<li><p><code>int move_cell_j;</code></p>
</li>
<li><p><code>int move_cell_k;</code></p>
</li>
<li><p><code>int move_basis;</code><br>  这个到底是有什么用处我现在还没看到，应该不是用于process中的</p>
</li>
<li><p><code>double distance;</code><br>  此处元素相对中心元素的距离，通过坐标做差获取。</p>
</li>
<li><p><code>Coordinate coordinate;</code><br>  这里的坐标是相对坐标，相对于中心坐标的<br>  （也就是minimal_match_list中的第一个MinimalMatchListEntry）</p>
</li>
</ul>
<h4 id="关于MinmalMatchListEntry的一些操作符重载："><a href="#关于MinmalMatchListEntry的一些操作符重载：" class="headerlink" title="关于MinmalMatchListEntry的一些操作符重载："></a>关于MinmalMatchListEntry的一些操作符重载：</h4><ul>
<li><p><code>==</code>和<code>&lt;</code><br>  这两个主要是用于比较，其中优先比较距离中心元素的距离，若距离相同在进行坐标的比较。<br>  坐标是KMCLib中自定义的类，按照坐标的x, y, z依次进行比较。</p>
</li>
<li><p><code>!=</code><br>  判别是否相等，若match_type为0，也就是这个entry中放的是通配符”*”则返回false，也就是不相等。<br>  否则按照match_type的值进行比较。<br>  如果类型也相同，就按照distance和坐标进行比较。<br>  比较的优先级顺序：</p>
<ol>
<li>通配符</li>
<li>初始类型</li>
<li>距离</li>
<li>坐标</li>
</ol>
</li>
</ul>
<p>上面的运算符重载主要用于创建minimal_match_list之后进行排序，使得process的minimal_match_list和configuration的可以匹配上。</p>
<h3 id="Process类中的match-list"><a href="#Process类中的match-list" class="headerlink" title="Process类中的match_list"></a>Process类中的match_list</h3><p>每个Process对象中都有一个相应的<code>minimal_match_list_</code>成员数据，他是一个<code>std::vector&lt;MinimalMatchListEntry&gt;</code>，里面放着与这个Process相关的每个元素的信息。</p>
<ol>
<li><p>由于Process是描述的前后元素的变化因此MinimalMatchListEntry对象中的<code>update_type</code>, <code>has_move_coordinate</code>, <code>move_coordinate</code>的值会特别设置用来描述元素变化的情况。</p>
</li>
<li><p>Process中的minimal_match_list是在构造函数中进行填充的。根据local_configuration的元素顺序进行填充。<br> 其中MinimalMatchListEntry中的has_move_coordinate成员和move_coordinate成员先初始化成默认数据false和Coordinate(0.0, 0.0, 0.0)。在后面再进行判断如果有传入move_origin和move_vector时再将相应的成员数据改成传入的数据。</p>
</li>
<li><p>由于process只是局部信息，所以index成员全部设成-1，因此在process中的MinimalMatchListEntry中的index是个鸡肋。</p>
</li>
<li><p>在最后将minimal_match_list中的数据填充完毕后，按照MinimalMatchListEntry升序进行排序，这也是为了和configuration中的match_list的顺序匹配上。</p>
</li>
</ol>
<h3 id="Configuration类中的match-list"><a href="#Configuration类中的match-list" class="headerlink" title="Configuration类中的match_list_"></a>Configuration类中的match_list_</h3><p>Configuration这个类是用于描述全局类型信息的，其中的每个点都有一个自己的minimal_match_list合并起来形成一个vector就成为了Configuration类的match_lists。<br>因此类型为<code>std::vector&lt; std::vector&lt;MinimalMatchListEntry&gt; &gt; match_lists_;</code></p>
<p>Configuration在构造函数中的成员初始化列表中通过resize来创建初始的列表，但是没有填充内容。</p>
<p>通过调用专门写的initMatchList()函数来初始化所有位置的minimal_match_list然后添加到match_lists中。这个函数并不是什么重要的函数，只是一个遍历操作而已，关键的任务在minimalMatchList()身上。</p>
<h4 id="minimalMatchList-函数"><a href="#minimalMatchList-函数" class="headerlink" title="minimalMatchList()函数"></a>minimalMatchList()函数</h4><p>这个函数有重载版本，另一个是用于返回值的const成员函数，用于返回相应位置上的minimal_match_list函数。<br>关键的函数在于另一个版本的这个：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;MinimalMatchListEntry&gt; &amp; minimalMatchList(<span class="keyword">const</span> <span class="keyword">int</span> origin_index,</div><div class="line">                                                            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; indices,</div><div class="line">                                                            <span class="keyword">const</span> LatticeMap &amp; lattice_map) <span class="keyword">const</span>;</div></pre></td></tr></table></figure></p>
<p>此函数返回相应origin_index元素为中心的minimal_match_list。参数indices是他的neighbor indices，初始顺序为正常顺序。</p>
<p>从indices中使用迭代器进行遍历，填充数据：</p>
<ul>
<li>match_type: 当前位置的元素类型</li>
<li>update_type: 此数据在configuration中没有作用，设为-1</li>
<li>distance: 相对于中心坐标的距离。</li>
<li>coordinate: 相对于中心坐标的坐标（<strong>因此凡是在minimal_match_list中的坐标和距离全部都是相对于中心点的相对值</strong>）</li>
<li>index: 这个值在这里就有用了，用来标记此元素在全局中的索引。</li>
</ul>
<p>当然最后还是要进行升序排序，为了与process中的match_list位置能够对应上。</p>
]]></content>
      
        <categories>
            
            <category> 学术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> catalysis </tag>
            
            <tag> chemistry </tag>
            
            <tag> Cpp </tag>
            
            <tag> 学术 </tag>
            
            <tag> KMCLib </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[KMCLib中的LatticeMap]]></title>
      <url>http://pytlab.github.io/2016/03/21/KMCLib%E4%B8%AD%E7%9A%84LatticeMap/</url>
      <content type="html"><![CDATA[<p>这里的成员数据全部<code>protected</code></p>
<h3 id="成员数据"><a href="#成员数据" class="headerlink" title="成员数据"></a>成员数据</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> n_basis_;                   <span class="comment">// 基点个数</span></div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; repetitions_;  <span class="comment">// site各个方向上重复次数</span></div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; periodic_;    <span class="comment">// 周期性边界条件</span></div></pre></td></tr></table></figure>
<p>这个类的成员数据相对比较少，就三个，就可以描述整个三维网格的所有性质了。<br>其中后两个好理解，但是第一个我看了许久代码都不知道是个啥东西，还好曹老师给的指点，终于弄明白了所谓基点数目和基点到底是什么东西。<br><a id="more"></a></p>
<h4 id="关于basis-points和n-basis"><a href="#关于basis-points和n-basis" class="headerlink" title="关于basis_points和n_basis"></a>关于<code>basis_points</code>和<code>n_basis</code></h4><p>其实也没啥好说的，本身没有什么难理解的，只要知道是怎么操作的了就一切都好说了。先上图吧：<br><img src="/assets/images/blog_img/2016-03-21-KMCLib中的LatticeMap/lattice_indices.png" alt=""><br>上图描述了KMCLib中三维网格模型的基本信息（忽略我拙劣的画风 -_-！），其中包括：</p>
<ul>
<li>三个基向量的方向和顺序</li>
<li>每个位点的索引号和顺序</li>
<li>基点的信息</li>
</ul>
<p>从上图中可以看出，所谓基点数目就是小括号中的数目，虽然目前还没看到这样做的作用是什么，不过好像的确是能够通过这种方式模拟多位点如hollow、top、bridge这种，现在概念都明了了，代码看起来速度可以飞起了，嗖嗖嗖～～===3333</p>
<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>这里也只是罗列几个比较重要的方法<br>类方法实现代码中有一个static变量，用于存储含有不同n_basis的index<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Temporary storage for the indices form cell.</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp_cell_indices__;</div></pre></td></tr></table></figure></p>
<ul>
<li><p><code>indicesFromCell()</code> 和 <code>indexToCell()</code></p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; LatticeMap::indicesFromCell(<span class="keyword">const</span> <span class="keyword">int</span> i,</div><div class="line">                                                     <span class="keyword">const</span> <span class="keyword">int</span> j,</div><div class="line">                                                     <span class="keyword">const</span> <span class="keyword">int</span> k) <span class="keyword">const</span></div><div class="line">&#123; </div><div class="line">    ... </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> LatticeMap::indexToCell(<span class="keyword">const</span> <span class="keyword">int</span> index,</div><div class="line">                             <span class="keyword">int</span> &amp; cell_i,</div><div class="line">                             <span class="keyword">int</span> &amp; cell_j,</div><div class="line">                             <span class="keyword">int</span> &amp; cell_k) <span class="keyword">const</span></div><div class="line">&#123; </div><div class="line">    ... </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  这两个函数是可逆的，第一个是提供位点在x、y、z三个方向上分别的序号，返回全局索引序号；第二个则是相反的操作，提供全局索引，返回相对应的在三个方向上的分量索引值。具体数据可以去看KMCLib的unittest代码 <a href="https://github.com/PytLab/KMCLib/blob/master-pytlab/c%2B%2B/unittest/test_latticemap.cpp" target="_blank" rel="external"><span class="fa fa-github"></span> KMCLib/test_latticemap.cpp at master-pytlab · PytLab/KMCLib</a></p>
</li>
<li><p><code>indexFromMoveInfo()</code></p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> LatticeMap::indexFromMoveInfo(<span class="keyword">const</span> <span class="keyword">int</span> index,</div><div class="line">                                  <span class="keyword">const</span> <span class="keyword">int</span> i,</div><div class="line">                                  <span class="keyword">const</span> <span class="keyword">int</span> j,</div><div class="line">                                  <span class="keyword">const</span> <span class="keyword">int</span> k,</div><div class="line">                                  <span class="keyword">const</span> <span class="keyword">int</span> basis) <span class="keyword">const</span></div><div class="line">&#123; </div><div class="line">    ... </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  此函数是用于返回某个位点加上某个向量以后新位点的索引，虽然还没看到此函数用在什么地方，不出意外是用于元素在网格中移动的时候用的。<br>  具体的操作：<br>  例如最开始一个site的索引值为16，这个网格的基点数目是3，也就是说每个点上的索引都是一个三维向量例如<code>(15, 16, 17)</code>，则参数中index就为<code>16</code>;<br>  接下来的三个参数代表位移向量在三个方向上的分量<code>(i, j, k)</code>;<br>  最后是<code>basis</code>这个参数有点不好理解，它指的是在basis_point内的相对于初始位置的偏移量，例如最开始是<code>(15, 16, 17)</code>中的<code>16</code>，经过向量的位移之后，到达全局索引<code>(18, 19, 20)</code>但是还是指向的中间的19，因此若需要一个相对的偏移量指向第一个的话，则就需要<code>basis</code>这个值了，他的值应该为-1。</p>
</li>
<li><p><code>neighbourIndices()</code>和<code>supersetNeighbourIndices()</code></p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; LatticeMap::neighbourIndices(<span class="keyword">const</span> <span class="keyword">int</span> index,</div><div class="line">                                              <span class="keyword">const</span> <span class="keyword">int</span> shells) <span class="keyword">const</span></div><div class="line">&#123; </div><div class="line">    ... </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; LatticeMap::supersetNeighbourIndices(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; indices,</div><div class="line">                                                      <span class="keyword">const</span> <span class="keyword">int</span> shells) <span class="keyword">const</span></div><div class="line">&#123; </div><div class="line">    ... </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  这两个函数相似，后者就是循环调用前者然后去重的产物。至于所谓的neighbor，还是先上图吧：<br>  <img src="/assets/images/blog_img/2016-03-21-KMCLib中的LatticeMap/neighbors.png" alt=""><br>  所谓找neighbor就是将shell包含的内部全部site的索引数按顺序返回出来。如果有周期性边界条件的限制，例如a和b轴都没有周期性边界条件，寻找0位置的neighbor，则按照图上的顺序返回neighbor的全局索引。</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> catalysis </tag>
            
            <tag> chemistry </tag>
            
            <tag> Cpp </tag>
            
            <tag> 学术 </tag>
            
            <tag> KMCLib </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[KMCLib中的CustomRateProcess]]></title>
      <url>http://pytlab.github.io/2016/03/21/KMCLib%E4%B8%AD%E7%9A%84CustomRateProcess/</url>
      <content type="html"><![CDATA[<p>此类是<code>Process</code>的派生类，所以在<code>Process</code>类中的成员变量为<code>protected</code>，而且很多成员函数都为虚函数。</p>
<h3 id="成员数据"><a href="#成员数据" class="headerlink" title="成员数据"></a>成员数据</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 由于不同site上面的速率不同，因此此vector存放对应sites_的速率</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; site_rates_;</div><div class="line"></div><div class="line"><span class="comment">// 递增的速率列表</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; incremental_rate_table_;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>具体可以用下图表示：<br><img src="assets/images/blog_img/2016-03-21-KMCLib中的CustomRateProcess/rate_table.png" alt=""></p>
<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>其他成员函数的作用与Process类似，只是由于每个位点的速率不同所采用的求和和抽取的方法稍有差别，这里就不做详解了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 根据site_rates_生成incremental_rate_table_</span></div><div class="line"><span class="keyword">void</span> CustomRateProcess::updateRateTable()</div><div class="line">&#123;</div><div class="line">    <span class="comment">// Resize and update the incremental rate table.</span></div><div class="line">    incremental_rate_table_.resize(site_rates_.size());</div><div class="line">    <span class="keyword">double</span> previous = <span class="number">0.0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; site_rates_.size(); ++i)</div><div class="line">    &#123;</div><div class="line">        incremental_rate_table_[i] = previous + site_rates_[i];</div><div class="line">        previous = incremental_rate_table_[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// DONE</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 学术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> catalysis </tag>
            
            <tag> chemistry </tag>
            
            <tag> Cpp </tag>
            
            <tag> Monte Carlo </tag>
            
            <tag> KMCLib </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[KMCLib中的Process]]></title>
      <url>http://pytlab.github.io/2016/03/20/KMCLib%E4%B8%AD%E7%9A%84Process/</url>
      <content type="html"><![CDATA[<h3 id="成员数据"><a href="#成员数据" class="headerlink" title="成员数据"></a>成员数据</h3><p>此类的成员数据均为<code>protected</code></p>
<ul>
<li><p><code>int process_number_;</code><br>  该过程ID号；</p>
</li>
<li><p><code>int range_;</code><br>  还未完全弄清楚其作用，是和坐标有关的一个范围，后续添加。</p>
</li>
<li><p><code>double rate_;</code><br>  这没什么好说的，反应速率；</p>
</li>
<li><p><code>double cutoff</code><br>  和坐标距离相关，数值上应该等于process涉及到的点到中心<br>  也就是process中第一个点）的最大距离，<br>  尚未弄清求作用；</p>
</li>
<li><p><code>std::vector&lt;int&gt; sites_;</code><br>  在整个网格中能和此反应匹配上的位点的向量；</p>
</li>
<li><p><code>std::vector&lt;MinimalMatchListEntry&gt; minimal_match_list_;</code><br>  用于存储每个位点信息的数据结构；</p>
</li>
<li><p><code>std::vector&lt;int&gt; affected_indices_;</code><br>  查看process前后每个位点类型是否相同<br>  如果不同则将0追加到其末尾<br>  (2016-03-31更新)<br>  这个变量主要用于更新process发生后确定发生process的index周围有哪些位置<strong>受影响</strong>,<br>  所谓受影响，也就是指由于该点由于参与了反应，元素的类型会发生变化，他的match_list也就相应的发生变化，也导致原本能够匹配的process不再能够在该点匹配或者原本不能匹配的process可以在该点匹配了。这个信息主要是用于Matcher类中。</p>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p><code>std::vector&lt;int&gt; basis_sites_</code><br>  这个用于描述这个process可以用在basis_sites中的哪一个点上。<br>  例如若此变量的值为(0, 1)，则这个process可以用在每个latticesite上的第一个和第二个点，若有第三个点则不能作用在第三个点上</p>
</li>
<li><p><code>std::vector&lt; std::pair&lt;int,int&gt; &gt; id_moves_;</code><br>  记录这个process中涉及到元素移动的信息。<br>  其中每个pair的第一个值放置元素的初始位置（process中的位置），第二个元素放置移动到的目标位置。<br>  例如，有个元素从1号位置移动到了4号位置，则pair中的数据就为(1, 4)</p>
</li>
</ul>
<p><br></p>
<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>这里只罗列几个重要的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">大致过程是</div><div class="line">- 先创建两个局部的Configuration对象，</div><div class="line">- 针对每个Configuration对象进行遍历，</div><div class="line">  将元素信息都生成一个`MinimalMatchListEntry`对象然后在添加到`minimal_match_list_`变量中，</div><div class="line">- 最后再处理和移动向量相关的操作，具体的用途还不清楚，感觉可能与扩散的模拟相关；</div><div class="line">*/</div><div class="line">Process(<span class="keyword">const</span> Configuration &amp; first,</div><div class="line">        <span class="keyword">const</span> Configuration &amp; second,</div><div class="line">        <span class="keyword">const</span> <span class="keyword">double</span> rate,</div><div class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; basis_sites,</div><div class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; move_origins=<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>),</div><div class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Coordinate&gt; &amp; move_vectors=<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Coordinate&gt;(<span class="number">0</span>),</div><div class="line">        <span class="keyword">const</span> <span class="keyword">int</span> process_number=<span class="number">-1</span>);</div><div class="line"></div><div class="line"><span class="comment">// 返回在整个网格中该过程的所有速率总和；</span></div><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">totalRate</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line"></div><div class="line"><span class="comment">// 将编号为index的site加入到process的`sites_`中，说明在该点上能够与该过程匹配成功。</span></div><div class="line"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">addSite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> index, <span class="keyword">const</span> <span class="keyword">double</span> rate=<span class="number">0.0</span>)</span></div><div class="line"></div><div class="line"><span class="comment">// 前面的逆过程；</span></div><div class="line"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">removeSite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> index)</span></div><div class="line"></div><div class="line"><span class="comment">// 在`site_`中随机抽取一个site；</span></div><div class="line"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">pickSite</span><span class="params">()</span> <span class="keyword">const</span></div></pre></td></tr></table></figure></p>
<p><br></p>
<h4 id="亮点"><a href="#亮点" class="headerlink" title="亮点"></a>亮点</h4><p>在<code>virtual void removeSite(const int index)</code>中作者有个小技巧降低了删除的时间复杂度：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Process::removeSite(<span class="keyword">const</span> <span class="keyword">int</span> index)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// Find the index to remove.</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it1 = <span class="built_in">std</span>::find(sites_.begin(),</div><div class="line">                                               sites_.end(),</div><div class="line">                                               index);</div><div class="line">    <span class="comment">// Swap the index to remove with the last index.</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator last = sites_.end()<span class="number">-1</span>;</div><div class="line">    <span class="built_in">std</span>::swap((*it1), (*last));</div><div class="line">    <span class="comment">// Remove the last index from the list.</span></div><div class="line">    sites_.pop_back();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>STL的<code>vector</code>内部是使用数组来存储数据的而不是链表，因此插入和删除的平均时间复杂度是$O(N)$，因此<code>erase()</code>方法的时间复杂度为$O(N)$，但是作者的做法通过先将要删除的元素与最后一个元素对调然后再用<code>pop_back()</code>方法删除末尾元素，通过两个复杂度为常数$O(1)$的操作将整体复杂度也降到了常数级。</p>
]]></content>
      
        
        <tags>
            
            <tag> catalysis </tag>
            
            <tag> chemistry </tag>
            
            <tag> Cpp </tag>
            
            <tag> 学术 </tag>
            
            <tag> KMCLib </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python开发者沙龙之后的小感想]]></title>
      <url>http://pytlab.github.io/2016/03/20/Python%E5%BC%80%E5%8F%91%E8%80%85%E6%B2%99%E9%BE%99/</url>
      <content type="html"><![CDATA[<p>昨天大老远跑到杨浦区去参加Python开发者沙龙，主要是听听牛人对Python的认识和见解，也想和喜欢python的朋友们进行线下的交流，同时也想知道自己大概是处在什么样的水平上。<br>结果一早我就背着我那有厚有重的T430和一堆线和移动电源出发了，大概坐地铁要一个小时才能到杨浦，我就带着我现在的宝贝《Effective C++》在车上看（最后事实证明其实我只需要带着本书就够了，电脑啥的压根我就没打开。<br>早到了一个小时，我还是喝了杯咖啡接着看我的宝贝。<br>。。。好烦，不想再记流水账了，直接进入主题吧</p>
<h3 id="一般人不知道的python秘密"><a href="#一般人不知道的python秘密" class="headerlink" title="一般人不知道的python秘密"></a>一般人不知道的python秘密</h3><p>这个是Coding CTO 孙宇聪讲的报告，主要讲解了他在Google使用python的一些原因和经历，对python中的一些优缺点进行了评价，同时对python内置的基本数据类型进行了简单的讲解其中最重要的还是python中避不开的话题GIL（全局解释器锁）。<br><a id="more"></a><br>虽然都是很基础的东西，但是在大牛的解说下我对以前虽然知道的东西的认识也加深了。<br>这里我就不再讲python的优点了，任何一个使用python的人肯定初见python时都会深深体会到他的优点并为之痴迷。但是世界上并没有完美的东西，优点的背后就是掩藏着的缺点与不足。</p>
<ul>
<li><p><strong>动态类型</strong><br>这个问题是在python，js上面很常见的问题，变量定义时并不声明其类型，这就会造成使用python进行运算时需要解释器去动态的判断其类型，必然会造成效率上的问题和项目庞大以后的一些未知的隐患。</p>
</li>
<li><p><strong>python的对象模型</strong><br>python中一切皆对象，就连int什么的也是一个<code>PyObject</code>, 这就会造成占用内存和运行效率低下的问题。</p>
</li>
<li><p>python的强制缩进（没有大括号）带来的不方便之处<br>有的时候一个<code>code block</code>写的很长超过一个屏幕时候，这种特点就会造成对应代码段困难。这时候大括号就会让人开始想念了。同样的，之前知乎上的@vczh也说过看python教程的时候最怕的应该就是翻页了吧，一旦翻页，没有中括号就会让人头疼。</p>
</li>
<li><p><strong>python中的string</strong><br>在python3.0之前，对Unicode的支持真的是和翔一样，不谈了。</p>
</li>
<li><p><strong>python的List</strong><br>python中List并不是数据结构中的链表结构，他其实是一个动态的数组。如下图：<br><img src="/assets/images/blog_img/2016-03-20-Python开发者沙龙/python_list.png" alt=""><br>可以看到，List对象中的数据成员包含list长度和items，其中items中存储着List中数据的指针，然后通过指针去操作真正的数据（这里由于我没看过python源码剖析，只能大概的理解下了。<br>这里就会遇到一个问题，就是由于List不是链表而是数组，那么对于插入数据和删除数据的复杂度将不是 $O(1)$ ，而是 $O(n)$ ! 所以要尽量减少对List的插入和删除操作。当然我平时是几乎很少用到<code>insert</code>这种的。</p>
</li>
<li><p><strong>python中的Tuple</strong><br>Tuple是不可变的，因此在做函数参数的时候以及返回值的时候都是返回的tuple，谁也不想传入和返回的值是个可变的list吧，这样带来的将会是未知的隐患。</p>
</li>
</ul>
<p><br></p>
<h4 id="全局解释器锁（GIL）"><a href="#全局解释器锁（GIL）" class="headerlink" title="全局解释器锁（GIL）"></a>全局解释器锁（GIL）</h4><p>这个真是已经是使用python的人没有一个不知道的东西了，经常会被人喷，说python没有真正的多线程。不过的确，GIL的存在使得python解释器中同时只能跑一个线程。使用multi-threading面对计算密集型的程序通常会使得效率降低！这样串行反而对于python是高效的做法。<br><img src="/assets/images/blog_img/2016-03-20-Python开发者沙龙/GIL_test.png" alt=""><br><img src="/assets/images/blog_img/2016-03-20-Python开发者沙龙/GIL_battle.png" alt=""></p>
<p>所以面对计算密集型程序使用多进程利用多CPU的优势来实现并行，感觉像是开了多个解释器，使用<code>Pool</code>和<code>process</code>也是很简单形象的。<br><img src="/assets/images/blog_img/2016-03-20-Python开发者沙龙/multi-process.png" alt=""></p>
<hr>
<h3 id="我的小感想"><a href="#我的小感想" class="headerlink" title="我的小感想"></a>我的小感想</h3><div class="alert alert-info"><i class="fa fa-info"></i>  我的一点小感想吧算是
<br>
<br>
当然在最近这两年强度比较大的使用python的情况下我也感受到了python的一些缺点，最近在写C++深深体会到python为了易开发而付出的效率上的代价，很多的语法糖，导致程序效率降低。慢慢的我对python的认识也渐渐趋于了理性，后续又使用C和C++使用SWIG来给python写extension，这样不仅能在语言层面上提升python的效率，也能够使用OpenMP和MPI等方式实现并行化。
<br>
<br>
的确，python的角色在不同领域甚至是不同大小的公司内部扮演的角色是不一样的。
<ul>
<li> 在Google这种大公司的确是希望写的程序能够运行十年是目标，因此稳定性是主要的，而不是开发速度，因此在这种角度来看python也许并不是合适的语言。但是对于小公司而言python开发快的特点是必需的。当然作为万金油，在服务器写脚本和做运维python可算是如鱼得水了。
</li><li> 对于科学计算，我觉得我还是很有发言权的。这个真的是要看科学计算的需求了，如果仅仅是进行算法的验证和尝试，用python写个小demo测试是效率很高的。没人喜欢用C或者C++写好函数写好驱动程序然后在编译这么麻烦吧。但是真的想用写好的程序开始大规模做计算获取数据的时候，一份高效规范的代码往往节省的时间是很可观的，谁也不想程序崩溃了都不知道是什么原因，然后找到写程序的人把程序改好然后在到每个计算节点编译安装一遍吧。所以这个时候选择C/C++来将其重写，外层在使用python将其封装调用，将内外层分离开来，外层可以用写的快的python写一些plugin但是内层C/C++编译好了可以不用再动了。
</li></ul>
<br>
不过我是能够感受到python社区是个健康蓬勃发展的，我很看好python的未来。</div>
<hr>
<h3 id="这次沙龙的资源："><a href="#这次沙龙的资源：" class="headerlink" title="这次沙龙的资源："></a>这次沙龙的资源：</h3><ol>
<li><a href="/assets/files/一般人不知道的Python秘密.pdf">一般人不知道的Python秘密.pdf</a></li>
<li><a href="/assets/files/用Python做增长黑客案例分享.pdf">用Python做增长黑客案例分享.pdf</a></li>
</ol>
<hr>
<h3 id="拍了几张图片也放上来吧"><a href="#拍了几张图片也放上来吧" class="headerlink" title="拍了几张图片也放上来吧"></a>拍了几张图片也放上来吧</h3><p><img src="/assets/images/blog_img/2016-03-20-Python开发者沙龙/IMG_20160319_124628.jpg" alt=""><br><img src="/assets/images/blog_img/2016-03-20-Python开发者沙龙/IMG_20160319_140713.jpg" alt=""><br><img src="/assets/images/blog_img/2016-03-20-Python开发者沙龙/IMG_20160319_140754.jpg" alt=""><br><img src="/assets/images/blog_img/2016-03-20-Python开发者沙龙/IMG_20160319_161839.jpg" alt=""><br><img src="/assets/images/blog_img/2016-03-20-Python开发者沙龙/IMG_20160319_163055.jpg" alt=""><br><img src="/assets/images/blog_img/2016-03-20-Python开发者沙龙/IMG_20160319_181523.jpg" alt=""></p>
<h5 align="center">我也争取到了一件限量款PyConT恤</h5>
]]></content>
      
        <categories>
            
            <category> 我的日常 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> 随记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++类型转换运算符]]></title>
      <url>http://pytlab.github.io/2016/03/18/C-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      <content type="html"><![CDATA[<h3 id="C风格（C-Style）强制转型"><a href="#C风格（C-Style）强制转型" class="headerlink" title="C风格（C-Style）强制转型"></a>C风格（C-Style）强制转型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(T) expression  <span class="comment">// 将expression类型强制转换成T</span></div><div class="line"></div><div class="line"><span class="comment">// 函数风格</span></div><div class="line">T(expression)  <span class="comment">// cast expression to be of type T</span></div></pre></td></tr></table></figure>
<p>这两种形式之间没有本质上的不同，纯粹就是形式的区别。</p>
<h3 id="C-的四种强制类型转换"><a href="#C-的四种强制类型转换" class="headerlink" title="C++的四种强制类型转换"></a>C++的四种强制类型转换</h3><p>在C++创始人Bjarne Stroustrup看来，C与阿燕的类型转换太过松散，因此采取了措施，就是更严格地限制允许的类型转换，并添加4个类型转换运算符，是转换过程更规范。</p>
<ul>
<li><code>dynamic_cast</code></li>
<li><code>const_cast</code></li>
<li><code>static_cast</code></li>
<li><code>reinterpret_cast</code></li>
</ul>
<p>这样可以根据转换的目的选择类型转换运算符，而不是通用的类型转换，让编译器能够检查程序的行为是否与设计者的想法吻合。<br><a id="more"></a></p>
<ol>
<li><p><code>dynamic_cast</code><br> 主要用于执行“安全的向下转型（safe downcasting）”，也就是说，要确定一个对象是否是一个继承体系中的一个特定类型。他是唯一不能用就风格语法执行的强制类型转换，也是唯一可能有重大运行时代价的强制类型转换。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A &#123; ... &#125;;</div><div class="line"><span class="keyword">class</span> B : <span class="keyword">public</span> A &#123; ... &#125;;</div><div class="line"><span class="keyword">class</span> C : <span class="keyword">public</span> B &#123; ... &#125;;</div><div class="line"></div><div class="line"><span class="comment">// 定义每种类型的指针</span></div><div class="line">A * pa;</div><div class="line">B * pb;</div><div class="line">C * pc;</div></pre></td></tr></table></figure>
<p> <code>dynamic_cast</code>的语法：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">B * pb = <span class="keyword">dynamic_cast</span>&lt;B *&gt;(pa);</div></pre></td></tr></table></figure>
<p> pa的类型是否可被安全的转换为<code>B *</code>? 如果可以则返回转换后的指针，如果不可以则返回一个空指针；<br> 所谓安全是为了让写程序的人知道自己调用的是哪个类的相应的方法。<br> 例如A,B,C三个类都有<code>Speak</code>方法，但是B类中定义了一个A类中没有的<code>Say()</code>方法。若我不清楚指针指向的是哪个对象的话我就不知道我能不能通过指针调用<code>Say()</code>方法了。因此我需要验证一下，于是可以用<code>dynamic_cast&lt;B *&gt;</code>看看是不是能转换成功，如果可以，那说明是B类，可以调用其<code>Say()</code>方法。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">B * ps;</div><div class="line"><span class="keyword">if</span> (ps = <span class="keyword">dynamic_cast</span>&lt;B *&gt;(pa))</div><div class="line">&#123;</div><div class="line">    ps-&gt;Say();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>const_cast</code><br>一般用于强制消除对象的常量性。它是唯一能做到这一点的C++风格的强制类型转换。<br>但是<code>const_cast</code>不是万能的，如果一个值在声明的时候就声明为<code>const</code>则可能编译器会禁止修改它。</p>
</li>
<li><p><code>static_cast</code><br>可以被用于强制隐型转换（例如，<code>non-const</code> 对象转型为<code>const</code>对象, <code>int</code>转型为<code>double</code>, 等等），它还可以用于很多这样的转换的反向转换（例如，<code>void\*</code> 指针转型为有类型指针，基类指针转型为派生类指针），但是它不能将一个<code>const</code>对象转型为<code>non-const</code>对象（只有<code>const_cast</code>能做到），它最接近于C-style的转换。</p>
</li>
<li><p><code>reinterpret_cast</code><br>特意用于底层的强制转型，导致实现依赖（implementation-dependent）（就是说，不可移植）的结果，例如，将一个指针转型为一个整数。这样的强制转型在底层代码以外应该极为罕见。</p>
</li>
</ol>
<div class="alert alert-info"><i class="fa fa-info"></i>  旧风格的强制转型依然合法，但是新的形式更可取。首先，在代码中它们更容易识别（无论是人还是像 grep 这样的工具都是如此），这样就简化了在代码中寻找类型系统被破坏的地方的过程。第二，更精确地指定每一个强制转型的目的，使得编译器诊断使用错误成为可能。例如，如果你试图使用一个 const_cast 以外的新风格强制转型来消除常量性。</div>
<p><br></p>
<h4 id="dynamic-cast-vs-static-cast"><a href="#dynamic-cast-vs-static-cast" class="headerlink" title="dynamic_cast .vs. static_cast"></a><code>dynamic_cast</code> .vs. <code>static_cast</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A * pa = <span class="keyword">new</span> A;</div><div class="line"></div><div class="line">B * p1 = <span class="keyword">dynamic_cast</span>&lt;B *&gt;(pa);</div><div class="line">B * p2 = <span class="keyword">static_cast</span>&lt;B *&gt;(pa);</div></pre></td></tr></table></figure>
<p>在这里<code>dynamic_cast</code>运算符知道转换时不合法的，于是他将返回空指针。但是<code>static_cast</code>则要依赖写程序的人的判断了，他将会简单的返回一个指向一个B类型的指针，实际指向的对象并不是B类型的。<br>即<code>dynamic_cast</code>可用于继承体系中的向下转型，即将基类指针转换为派生类指针，比<code>static_cast</code>更严格更安全。<code>dynamic_cast</code>在执行效率上比<code>static_cast</code>要差一些,但<code>static_cast</code>在更宽上范围内可以完成映射,这种不加限制的映射伴随着不安全性.<code>static_cast</code>覆盖的变换类型除类层次的静态导航以外,还包括无映射变换,窄化变换(这种变换会导致对象切片,丢失信息),用<code>VOID*</code>的强制变换,隐式类型变换等…</p>
<p><br></p>
<h4 id="static-cast-vs-reinterpret-cast"><a href="#static-cast-vs-reinterpret-cast" class="headerlink" title="static_cast .vs. reinterpret_cast"></a><code>static_cast</code> .vs. <code>reinterpret_cast</code></h4><p><code>reinterpret_cast</code>是为了映射到一个完全不同类型的意思,这个关键词在我们需要把类型映射回原有类型时用到它.我们映射到的类型仅仅是为了故弄玄虚和其他目的,这是所有映射中最危险的.(这句话是C++编程思想中的原话)</p>
<p><code>static_cast</code>和<code>reinterpret_cast</code> 操作符修改了操作数类型. 它们不是互逆的; <code>static_cast</code>在编译时使用类型信息执行转换, 在转换执行必要的检测(诸如指针越界计算, 类型检查). 其操作数相对是安全的. 另一方面, <code>reinterpret_cast</code>仅仅是重新解释了给出的对象的比特模型而没有进行二进制转换, 例子如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> n = <span class="number">9</span>;</div><div class="line"><span class="keyword">double</span> d = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(n);</div></pre></td></tr></table></figure>
<p>上面的例子中, 我们将一个变量从<code>int</code>转换到 <code>double</code>. 这些类型的二进制表达式是不同的. 要将整数 9 转换到 双精度整数 9, <code>static_cast</code> 需要正确地为双精度整数 d 补足比特位. 其结果为 9.0. 而<code>reinterpret_cast</code> 的行为却不同:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> n=<span class="number">9</span>;</div><div class="line"><span class="keyword">double</span> d = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">double</span> &amp; &gt; (n);</div></pre></td></tr></table></figure></p>
<p>这次, 结果有所不同. 在进行计算以后, d 包含无用值. 这是因为 <code>reinterpret_cast</code> 仅仅是复制 n 的比特位到 d, 没有进行必要的分析.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一共四种<code>cast</code>。</p>
<ol>
<li><code>static_cast</code>，支持子类指针到父类指针的转换，并根据实际情况调整指针的值，反过来也支持，但会给出编译警告，它作用最类似C风格的“强制转换”，一般来说可认为它是安全的；</li>
<li><code>dynamic_cast</code>，支持父类指针到子类指针的转换，并根据实际情况调整指针的值，和<code>static_cast</code>不同，反过来它就不支持了，会导致编译错误，这种转换是最安全的转换；</li>
<li><code>reinterpret_cast</code>，支持任何转换，但仅仅是如它的名字所描述的那样“重解释”而已，不会对指针的值进行任何调整，用它完全可以做到“指鹿为马”，但很明显，它是最不安全的转换，使用它的时候，你得头脑清醒，知道自己在干什么；</li>
<li><code>const_cast</code>，这个转换能剥离一个对象的<code>const</code>属性，也就是说允许你对常量进行修改。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[开始看KMCLib源码]]></title>
      <url>http://pytlab.github.io/2016/03/17/%E5%BC%80%E5%A7%8B%E7%9C%8BKMCLib%E6%BA%90%E7%A0%81/</url>
      <content type="html"><![CDATA[<div class="alert alert-info"><i class="fa fa-info"></i>  <br>
今天开始看KMCLib的源码，预计一周之内搞定。<br>
同时学习下人家C++的编码风格，我觉得人家代码写的很优美啊。<br>
不多说了，开干吧～</div>
]]></content>
      
        <categories>
            
            <category> 学术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> catalysis </tag>
            
            <tag> chemistry </tag>
            
            <tag> 随笔 </tag>
            
            <tag> Cpp </tag>
            
            <tag> KMCLib </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++中输出的格式控制]]></title>
      <url>http://pytlab.github.io/2016/03/16/C-%E4%B8%AD%E8%BE%93%E5%87%BA%E7%9A%84%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>在上一篇总结里也提到过，<code>ostream</code>是从<code>ios</code>类派生出来的，而<code>ios</code>类是从<code>ios_base</code>类派生出来的。<br>对于输出的格式控制，<code>ios_base</code>类起到了至关重要的作用，因为他提供了控制格式的成员方法和成员数据。</p>
<h3 id="字段宽度和精度"><a href="#字段宽度和精度" class="headerlink" title="字段宽度和精度"></a>字段宽度和精度</h3><p>先介绍这两个，因为控制这两个格式的成员数据是单独存储在ios_base类中的。</p>
<h4 id="控制字段宽度"><a href="#控制字段宽度" class="headerlink" title="控制字段宽度"></a>控制字段宽度</h4><p>函数原型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">width</span><span class="params">()</span></span>;  <span class="comment">// 返回字段宽度的当前设置</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">width</span><span class="params">(<span class="keyword">int</span> i)</span></span>;  <span class="comment">// 将字段宽度设置为i个空格，并返回以前的字符宽度值</span></div></pre></td></tr></table></figure></p>
<p><strong>width()方法只影响接下来显示的一个项目</strong><br><a id="more"></a></p>
<h3 id="ios-base类的setf-成员函数"><a href="#ios-base类的setf-成员函数" class="headerlink" title="ios_base类的setf()成员函数"></a>ios_base类的setf()成员函数</h3><p><code>ios_base</code>类中有一个protected成员数据，这个数据的每一位（这里的位是指bit）分别控制着格式化的各个方面，例如计数系统，是否显示结尾的0等。打开一个位意味着相应的位的值被设为1.例如hex、dec、oct控制符调整计数系统的三个标记位。其中<strong><code>setf()</code>成员方法控制着调整标记位的途径</strong>。</p>
<p><code>setf()</code>有两个原型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">fmtflag <span class="title">setf</span><span class="params">(fmtflag)</span></span>;</div><div class="line"><span class="function">fmtflag <span class="title">setf</span><span class="params">(fmtflag, fmtflag)</span></span>;</div></pre></td></tr></table></figure></p>
<div class="alert alert-info"><i class="fa fa-info"></i>  <code>fmtflag</code>是<code>bitmask</code>类型的typedef，用于存储格式标记。它可以是整形、枚举、也可以是STL bitset容器。这里的主要思想是:<br>
每一位都是可以单独访问的，都有自己的含义，也就是需要位操作。</div>
<p>setf()函数通过传递给他的参数来改变状态位。但是直接操作位比较麻烦，所以在<code>ios_base</code>中定义了一些常量代表位值，例如<code>ios_base::boolalpha</code>, <code>ios_base::showbase</code>…</p>
<p>第二种原型，提供了两个<code>fmtflag</code>值，第一个用于设置某一位打开或关闭，第二位的作用是清扫其他位。其实两个参数的作用顺序是相反的，先用第二个参数清除一些相关位，在用第一个参数设置哪一位。<br>通过这两个不同的组合可以进行输出格式的设置：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cout</span>.setf(ios_base::floatfield, ios_base::fixed);       <span class="comment">// 使用定点计数法</span></div><div class="line"><span class="built_in">cout</span>.setf(ios_base::floatfield, ios_base::scientific);  <span class="comment">// 使用科学计数法</span></div><div class="line"><span class="comment">/************************************************************************/</span></div><div class="line"><span class="built_in">cout</span>.setf(ios_base::adjustfield, ios_base::left);      <span class="comment">// 使用左对齐</span></div><div class="line"><span class="built_in">cout</span>.setf(ios_base::adjustfield, ios_base::right);     <span class="comment">// 使用右对齐</span></div><div class="line"><span class="built_in">cout</span>.setf(ios_base::adjustfield, ios_base::internal);  <span class="comment">// 符号或基数前缀左对齐，值右对齐</span></div></pre></td></tr></table></figure></p>
<h4 id="清除设置unsetf"><a href="#清除设置unsetf" class="headerlink" title="清除设置unsetf()"></a>清除设置unsetf()</h4><p>unsetf()的原型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unsetf</span><span class="params">(fmtflag mask)</span></span>;</div></pre></td></tr></table></figure></p>
<p>mask将所有的位都设为1，是的对应的位被复位（通过位运算）。例如:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cout</span>.setf(ios_base::showpoint);  <span class="comment">// 将其中的某位设为1</span></div><div class="line"><span class="built_in">cout</span>.setf(ios_base::showpoint);  <span class="comment">// 将相应的那位恢复位0</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C和C++中的I/O]]></title>
      <url>http://pytlab.github.io/2016/03/16/C-Cpp%E4%B8%AD%E7%9A%84IO/</url>
      <content type="html"><![CDATA[<h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p>C和C++程序都把输入和输出看作是字节流。即输入的时候从输入流中抽取字节；输出的时候将字节放入到流中。输入流中的字节可能来自键盘，也可能来自存储设备（如硬盘）或其他程序。同样，输出流中的字节可以流向屏幕、打印机、存储设备或者其他程序。<br>这里<strong>流充当了程序和流源或者流目标之间的桥梁</strong>。<br>C/C++程序只是检查字节流就好了，这使得程序可以以相同方式处理来自不同的输入源，程序不需要知道这字节流是最初是来自哪里的，输出流也是如此。<br>因此要管理输入和输出需要两步：</p>
<ol>
<li>将流域输入和输出去向的程序关联起来</li>
<li>将流与文件关联起来<a id="more"></a>
</li>
</ol>
<p><img src="/assets/images/blog_img/2016-03-16-C-Cpp中的IO/io-ins.gif" alt=""></p>
<p><img src="/assets/images/blog_img/2016-03-16-C-Cpp中的IO/io-outs.gif" alt=""></p>
<h5 align="center">图片来自网络,非原创</h5>

<div class="alert alert-info"><i class="fa fa-info"></i>  这里可以做个比较好的比喻就是：可以把C/C++程序看成是在河边喝水的我，对于我来说，水就是从河里喝到的，这是我得到水的唯一方式，但是河里的水可能从任何地方来，也能到任何地方去。</div>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>通过使用缓冲区可以更高效的处理输入和输出。缓冲区是用作中介的内存块，是将信息从数据源传输到程序或者程序到目标数据设备的临时存储工具。通常程序都是一个字节一个字节的接受和发出数据的，而磁盘驱动器这样的设备是以512Bytes或者更多字节这样一块一块传输数据的。缓冲区变为这种吞吐量的不匹配做缓冲。这样先把文件中的数据放到缓冲区中，然后程序从缓冲区中一个字节一个字节的去读取数据。当把缓冲区中的数据读取完毕后，会再从文件中读取下一批数据。。。</p>
<div class="alert alert-info"><i class="fa fa-info"></i>  这就好像水库在暴风雨中收集了大量的水，由于人喝水不可能接受那么大的水量，所以先通过水库缓冲，水库用较慢的速度将水发放给人类喝，或者说放到流中，然后人从流中一口一口的喝。</div>
<p><img src="/assets/images/blog_img/2016-03-16-C-Cpp中的IO/BufferedStream.png" alt=""></p>
<h5 align="center">图片来自网络,非原创</h5>

<h3 id="C-C-对流和缓冲区的管理"><a href="#C-C-对流和缓冲区的管理" class="headerlink" title="C/C++对流和缓冲区的管理"></a>C/C++对流和缓冲区的管理</h3><p>通过对流进行管理便可以管理程序对数据的输出和输入。</p>
<ul>
<li>C语言通过FILE结构体以及标准库函数来对流中的数据的读取和插入进行管理，</li>
<li>C++则是使用定义在标准库中的类（如istream, ifstream…等）来对流和数据的抽取和插入进行管理。</li>
</ul>
<p><br></p>
<h4 id="C语言中使用FILE结构体（或者其指针）"><a href="#C语言中使用FILE结构体（或者其指针）" class="headerlink" title="C语言中使用FILE结构体（或者其指针）"></a>C语言中使用FILE结构体（或者其指针）</h4><p>通常使用标准I/O的第一步就是使用<code>fopen()</code>函数打开一个文件（其中<code>stdin</code>, <code>stderr</code>, <code>stdout</code>文件时自动打开的）。当使用<code>fopen()</code>打开一个文件的时候，不仅打开了文件，而且还创建了缓冲区（如果是读写模式将创建两个缓冲区），同时还创建了一个包含文件和缓冲区相关信息的结构体，然后返回此结构体的指针。这个结构体就是<code>FILE</code>结构。<br>我们就称<strong>fopen()打开了一个流（文本流或者二进制流）</strong></p>
<p>这个<code>FILE</code>结构体都包含的信息：</p>
<ul>
<li>文件位置指示器（确定在流中当前的位置）</li>
<li>错误指示器</li>
<li>文件结尾指示器</li>
<li>一个指向缓冲区起始处的指针</li>
<li>一个文件标志符</li>
<li>一个记录实际复制到缓冲区中的字节数的计数器。</li>
</ul>
<p>通过标准库函数来操作流中的数据</p>
<ol>
<li>正常创建流以后会通过标准库中的输入函数来获取数据，比如<code>fscanf()</code>, <code>getc()</code>, <code>fgets()</code>。<strong>调用这些函数中的任意一个都会把一块数据从文件复制到缓冲区中</strong>，除了填充缓冲区外，第一次调用读取数据的函数还会设置FILE中的一些信息，例如流中当前的位置（默认从字节0开始）。</li>
<li>由于所有输入函数都是用用一个缓冲区，所以任何一个被调用的函数都将在前一次函数调用停止的地方（流中）继续开始。</li>
<li>当缓冲区的数据全部被程序读取完时，再请求下一块数据填入到缓冲区中，知道读入文件中的全部内容。</li>
<li><code>FILE</code>中的文件结尾指示器设为<code>true</code>,于是下一个使用该结构体的函数将返回<code>EOF</code>。</li>
</ol>
<p>输出的方式类似，当缓冲区填满时，将数据恢复到文件中。</p>
<p><br></p>
<h4 id="C-使用iostream对象"><a href="#C-使用iostream对象" class="headerlink" title="C++使用iostream对象"></a>C++使用iostream对象</h4><p>iostream文件中包含了专门设计用来实现管理流和缓冲区的类。</p>
<ul>
<li><code>streambuf</code>类为缓冲区提供了内存，并提供了用于填充缓冲区、访问缓冲区内容、刷新缓冲区和管理缓冲区内存的类方法</li>
<li><code>ios_base</code>类表示流的一般特征，是否可读取、是二进制流还是文本流<br>  这个类也存储了描述格式状态的信息，例如，一个类成员的某些为决定了使用的计数系统，而另一个成员则决定了字段宽度。<br>  同时这个类也有个成员函数<code>setf()</code>配合着他的静态常量例如<code>ios_base::showpoint</code>可以控制多种格式化特性。</li>
<li><code>ios</code>类基于<code>ios_base</code>，其中包括了一个指向<code>streambuf</code>对象的指针成员，<strong>是不是有些像FILE结构体中的那个指向缓冲区内存的指针？</strong></li>
<li><code>ostream</code>类是从<code>ios</code>类派生来的，提供了想输出流中输出的方法</li>
<li><code>istream</code>类也是从<code>ios</code>派生来的，提供了从流中输入的方法。</li>
<li><code>iostream</code>类是多重继承于<code>istream</code>和<code>ostream</code>类的，继承了他两个的所有方法。</li>
</ul>
<p>通过创建一个这些类的对象来创建流，开辟缓冲区、并将其与流关联起来。</p>
<p><strong>cout对象凭借着streambuf对象的帮助管理之流中的字节流</strong></p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C </tag>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识STL迭代器(iterator)和函数符(functor)]]></title>
      <url>http://pytlab.github.io/2016/03/16/%E5%88%9D%E5%A7%8BSTL%E8%BF%AD%E4%BB%A3%E5%99%A8-iterator-%E5%92%8C%E5%87%BD%E6%95%B0%E7%AC%A6-functor/</url>
      <content type="html"><![CDATA[<p>对于STL我真的是久仰大名了，这次从《Cpp Primer Plus》中初次学习STL中的一些知识，学习到迭代器将算法从具体的容器类型中抽离出来，真的是很nb的想法。<br>我在这里稍微总结下我初次学习STL时候对其中迭代器和函数符概念的一点理解。<br><br></p>
<h4 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h4><p>首先还是泛型编程，这种编程的范式是我之前没有接触过的，之前的面向对象编程的关注点是编程的数据方面，例如如何控制数据的访问权限等等。但是泛型编程的关注点是<strong>算法</strong>，例如将算法从数据类型中抽离出来，将算法从容器类型中抽离出来等等。<br>虽然面向对象和泛型编程的思想都是抽象和创建可重用的代码，但他们的理念是决然不同的。</p>
<p>C++中的模板为编写独立于数据类型的函数和类提供了可能，而STL通过迭代器将编写独立于容器类型的通用函数提供了可能。<br><a id="more"></a><br><br></p>
<h4 id="STL中的迭代器"><a href="#STL中的迭代器" class="headerlink" title="STL中的迭代器"></a>STL中的迭代器</h4><p>这里的迭代器当然和python中的迭代器不同啦，python中的迭代器可以理解为为实现<code>for...in...</code>语法糖而实现了<code>__iter__()</code>和<code>next()</code>迭代协议的类。而STL中的迭代器虽然也是类，但是理念完全不同。<br>理解迭代器是理解STL的关键所在。<br>迭代器的存在使得泛型编程能够使用同一个函数如<code>find()</code>来处理不同的容器类型（数组、链表和其他任何容器），及函数不仅独立于容器中存储的数据类型，而且还独立于容器本身的数据结构（算是将泛类型的抽象更提高了一层！）。<br>模板提供了存储在容器中的数据类型的通用表示，因此还需要遍历容器中的之的通用表示，迭代器正是这样的通用表示。</p>
<p>迭代器是一种广义的指针，其作用和指针类似，这样也就为访问容器中的内容提供了可能<br>迭代器类应该具有以下几个特征：</p>
<ul>
<li>能够对迭代器对象执行接触引用的操作–重载<code>*</code>运算符</li>
<li>能够进行赋值</li>
<li>能够进行比较–重载<code>==</code>,<code>&gt;</code>, <code>&lt;</code>等运算符</li>
<li>能够遍历容器中的元素–重载<code>++</code>运算符</li>
</ul>
<p>例如链表迭代器中重载<code>++</code>运算符函数定义可以是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">iterator &amp; <span class="keyword">operator</span>++()</div><div class="line">&#123;</div><div class="line">    pt = pt-&gt;next;</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另外每个容器类中都有个typedef的iterator类型，通过作用域解析运算符可以访问该类型来定义迭代器类型的变量：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::iterator pr;</div></pre></td></tr></table></figure></p>
<p>同时也可以使用C++11中<code>auto</code>关键字来达到目的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; test(<span class="number">10</span>, <span class="number">0.1</span>);</div><div class="line"><span class="keyword">auto</span> pr = test.begin();</div></pre></td></tr></table></figure></p>
<p><br></p>
<h4 id="STL中的函数符"><a href="#STL中的函数符" class="headerlink" title="STL中的函数符"></a>STL中的函数符</h4><p>函数符可以看成是广义的函数，但他其实是重载了<code>()</code>运算符的一个类，这是理解函数符的关键。<br>例如一个类：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Functor</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">double</span> a;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Functor(<span class="keyword">double</span> a_ = <span class="number">1.0</span>) : a(a_) &#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> a*x; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样就能够将Functor类的对象当作函数来用，例如<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">Functo <span class="title">f1</span><span class="params">(<span class="number">2.0</span>)</span></span>;</div><div class="line"><span class="keyword">double</span> y = f1(<span class="number">9.0</span>);  <span class="comment">// y = 18.0</span></div></pre></td></tr></table></figure></p>
<hr>
<p>这里就写这么点吧，以后在使用的时候有新的理解我会在写总结的。<br>另外附上一个可以方便查询的网站，我一般有些函数的原型忘记了会到这里来查:<a href="http://www.cplusplus.com/" target="_blank" rel="external">http://www.cplusplus.com/</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> STL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于C++中的智能指针模板类]]></title>
      <url>http://pytlab.github.io/2016/03/16/%E5%85%B3%E4%BA%8EC-%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%A8%A1%E6%9D%BF%E7%B1%BB/</url>
      <content type="html"><![CDATA[<p>智能指针是行为类似于指针的类对象，但是他们还有更重要的功能来帮助管理动态内存分配。<br>他们的一个主要的思想就是：</p>
<div class="alert alert-info"><i class="fa fa-info"></i>  使用智能指针指向堆中的内存（这和常规指针相同），但是智能指针<strong>会在智能指针变量过期销毁时自动将其指向的堆内存释放掉</strong>。这样就避免了程序员忘记释放内存而造成的隐患，如内存泄漏。。。
<br>
其本质也就是将智能指针模板类的<code>*</code>运算符进行了重载，然后再析构函数中添加了释放对内存的功能。</div>
<a id="more"></a>
<p>C++中内置了三种智能指针模板：<code>auto_ptr</code>, <code>unique_ptr</code>, <code>shared_ptr</code></p>
<p><br></p>
<h4 id="使用这三种指针的时候要注意："><a href="#使用这三种指针的时候要注意：" class="headerlink" title="使用这三种指针的时候要注意："></a>使用这三种指针的时候要注意：</h4><ul>
<li><p>智能指针类在含有一个参数的构造函数中使用了<code>explicit</code>关键字，因此只能通过显示调用而不是赋值的方式进行初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">double</span>&gt; pshared = p_reg;  <span class="comment">// 不允许，隐式类型转换</span></div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">double</span>&gt; pshared(p_reg);  <span class="comment">// 允许，这是显式调用构造函数</span></div></pre></td></tr></table></figure>
</li>
<li><p>不能将智能指针指向非对内存中的数据，因为当智能指针过期时，程序会尝试释放非堆内存中的数据，这样是错误的。</p>
</li>
</ul>
<p><br></p>
<h4 id="为什么有三种智能指针？"><a href="#为什么有三种智能指针？" class="headerlink" title="为什么有三种智能指针？"></a>为什么有三种智能指针？</h4><p>关于这三类智能指针的区别主要是围绕一点区分： <strong>如何处理当两个指针共同指向同一个对象</strong><br>对于常规指针，这没啥问题。但是对于智能指针，由于其自动释放内存的特性，将两个智能指针同时指向一个对象就意味着会将<strong>同一块内存释放两次</strong>，这当然是不允许的了。</p>
<p>处理上面的问题的方式：</p>
<ul>
<li>定义复制运算符，进行深复制，再另外开辟出一段内存来存放相同的对象。</li>
<li>建立所有权（ownership）的概念，对于一个对象只能有一个智能指针指向他，只有拥有所有权的智能指针的析构函数能够释放该内存。赋值的时候会转让所有权，老的智能指针将会变成一个空指针，无法使用。这是<code>auto_ptr</code>和<code>unique_ptr</code>所采用的策略。</li>
<li>采用引用计数（reference counting），仅当最后一个指针过期时，才调用delete释放内存，这是<code>shared_ptr</code>所采用的策略。</li>
</ul>
<p><br></p>
<h4 id="auto-ptr和unique-ptr的区别？"><a href="#auto-ptr和unique-ptr的区别？" class="headerlink" title="auto_ptr和unique_ptr的区别？"></a><code>auto_ptr</code>和<code>unique_ptr</code>的区别？</h4><p>采用所有权的策略会有一种隐患就是，当一个指针的所有权转让出去以后便不再有用和数据对象之间的关系，但是程序员可能还会通过它来访问数据。这个时候就相当于使用了一个空指针访问了无效的数据。<br><code>auto_ptr</code>指针不会在编译阶段报错通过编译后程序在运行的时候会出现运行阶段错误，而<code>unique_ptr</code>会在编译阶段发现此错误从而禁止程序员这种危险的行为。毕竟编译阶段的错误比潜在的程序崩溃更安全。<br>由于C++11引入移动构造函数和右值引用，所以可以使用<code>std::move()</code>函数来达到只能指针赋值的效果，如<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; ps1, ps2;</div><div class="line">ps1 = demo(<span class="string">"test"</span>);  <span class="comment">// demo() 返回一个unique_ptr&lt;string&gt;类型的变量</span></div><div class="line">ps2 = move(ps1);  <span class="comment">// 类似于ps2 = ps1， 但这样编译器是允许的</span></div></pre></td></tr></table></figure></p>
<p><br></p>
<h4 id="unique-ptr独有的特点"><a href="#unique-ptr独有的特点" class="headerlink" title="unique_ptr独有的特点"></a><code>unique_ptr</code>独有的特点</h4><p><code>unique_ptr</code>有指向数组的变体。即使用<code>new []</code>来分配内存和使用<code>delete []</code>释放内存。可以这样<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">double</span> []&gt; pda(<span class="keyword">new</span> <span class="keyword">double</span> [<span class="number">10</span>]);</div></pre></td></tr></table></figure></p>
<p>但是其他两种智能指针却无法这样做。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++ Primer Plus 6th, complete!]]></title>
      <url>http://pytlab.github.io/2016/03/16/C-Primer-Plus-6th-complete/</url>
      <content type="html"><![CDATA[<p>终于把《C++ Primer Plus 6th》看完啦，课后习题全部敲玩，算是一只脚踩进了C++的大坑里.</p>
<p>习题代码已放到GitHub上 $\rightarrow$ <a href="https://github.com/PytLab/Cpp-Primer-Plus" target="_blank" rel="external"><span class="fa fa-github"></span> Cpp-Primer-Plus Answers</a></p>
<p>接下来开始砍树啦，<br>KMCLib，先让我摸透你然后再搞定了你！</p>
<a id="more"></a>
<p><img src="assets/images/blog_img/2016-03-16-C-Primer-Plus-6th-complete/cpp_primer_plus.jpg" alt=""></p>
]]></content>
      
        
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ios_base()对象没有公共复制构造函数]]></title>
      <url>http://pytlab.github.io/2016/03/16/ios-base-%E5%AF%B9%E8%B1%A1%E6%B2%A1%E6%9C%89%E5%85%AC%E5%85%B1%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>今天写C++ Primer Plus17章的最后一题，要构造一个Store函数符来将vector中的string对象写入文件，但是写好后编译器一直报错<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::ios_base::ios_base(<span class="keyword">const</span> <span class="built_in">std</span>::ios_base&amp;) is <span class="keyword">private</span></div></pre></td></tr></table></figure></p>
<p>看样子是标准库里面的报错，我写的Store类如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// functor Store</span></div><div class="line"><span class="keyword">class</span> Store</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">std</span>::ostream os;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Store(<span class="built_in">std</span>::ostream &amp; o) : os(o) &#123;&#125;</div><div class="line">    <span class="comment">// overloaded funtions</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; s)</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>报错里面说<code>ios_base</code>的复制构造函数是私有的，我好像在哪里见过。。。然后就想到了在讨论C++函数返回值时候关于返回非const引用中有说<code>cout</code>对象<strong>没有公共的复制构造函数</strong>因此不能返回对象，返回对象要创建临时对象，这样会调用复制构造函数，然而<code>ios_base</code>类（包括他的子类iostream…）没有公开他的复制构造函数于是外部不能调用，自然会报错了。<br>需要将<code>std::ostream os</code>改成<code>std::ostream &amp; os</code></p>
<p>同样我这里也是这个问题，我在<code>Store</code>类中将<code>os</code>变量声明为<code>ostream</code>而不是其引用，这样我在<code>Store</code>的构造函数中会初始化这个成员，自然会调用<code>os</code>对象的复制构造函数，这个错误也就会报出来了。<br>因此以后要使用<code>ios_base</code>类的时候一定要<strong>注意声明称引用</strong>。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++中的向前声明(forward declaration)]]></title>
      <url>http://pytlab.github.io/2016/03/14/Cpp%E4%B8%AD%E7%9A%84%E5%90%91%E5%89%8D%E5%A3%B0%E6%98%8E-forward-declaration/</url>
      <content type="html"><![CDATA[<p>在涉及到友元类方法的时候会用到向前声明，至于为什么要使用向前声明我还是直接上例子理解的快：<br>在Tv类中<code>Remote</code>类中的<code>set_chan()</code>方法设为友元类方法，也就是<code>Remote</code>的这个方法是可以访问<code>Tv</code>的私有成员数据的（包括修改）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Tv</div><div class="line">&#123;</div><div class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> Remote::set_chan(Tv &amp; t, <span class="keyword">int</span> c);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，既然是Tv类的友元，<code>set_chan</code>中自然要有<code>Tv</code>类的变量，但是编译器在编译<code>Remote</code>类的时候至少要知道Tv这个东西是个自定义的类，不然会报错，所以应该把Tv类声明在Remote类的前面。但是Tv类中由于将Remote中的方法设为自己的友元，所以编译器也要知道<code>Remote::set_chan(Tv &amp; t, int c)</code>中的Remote以及它的方法是在哪里，不然也会报错。这样就前后矛盾了。<br><a id="more"></a><br>所以向前声明就是在这时候出现的。因为在Remote类中只是在参数中提到了Tv类，并没有提及Tv类的方法，因此只要要编译器知道<code>Tv</code>这是个什么东西就好了，所以向前声明一下，让编译器知道<code>Tv</code>是个类。因此类定义排序如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> TV;  <span class="comment">// 向前声明</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> Remote  <span class="comment">// Remote中提到了Tv一下，只要看到向前声明就可以了</span></div><div class="line">&#123; ... &#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Tv  <span class="comment">// Tv也知道Remote的所有东西了</span></div><div class="line">&#123; ... &#125;;</div></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：这里需要注意的是Remote类定义中不能将类方法的定义直接写在类定义中了，因为在编译Remote的时候编译器还不知道Tv类里面有啥东西。所以应该将Remote的类方法定义写在其他地方，或者当前文件中使用<code>inline</code>关键字使其成为内联函数。</p>
<hr>
<p>另外关于向前声明的作用我在google的C++编码规范中看到</p>
<blockquote>
<p>使用<strong>前置声明</strong>尽量减少<code>.h</code>文件中的<code>#include</code>的数量</p>
</blockquote>
<p>当一个头文件被包含的同时也引入了一项新的依赖（dependency），只要该头文件被修改，代码就要重新编译。如果你的头文件包含了其他头文件，这些头文件的任何改变也将导致那些包含了你的头文件的代码重新编译。因此，我们宁可尽量少包含头文件，尤其是那些包含在其他头文件中的</p>
<p>例如我头文件中用到了File类但是我并不需要访问File的声明（也就是知道他是个什么东西就行的程度），则只需前置声明<code>class File</code>；无需<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"file/base/file.h"</span></span></div></pre></td></tr></table></figure></p>
<p>那具体哪些情况下只是用类而不需要访问File类定义呢？</p>
<ol>
<li>将参数成员类型声明为<code>File *</code>或<code>File &amp;</code></li>
<li>参数、返回值类型为<code>File</code>的函数只是声明（但不定义实现）</li>
<li>静态数据成员的类型可以被声明为<code>File</code>，因为静态数据成员的定义在类定义之外。</li>
</ol>
<div class="alert alert-info"><i class="fa fa-info"></i>  如果类是<code>File</code>类的子类或者还有类型为<code>File</code>的非静态数据成员，则必须包含有其定义的头文件。</div>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Google的C++编码规范]]></title>
      <url>http://pytlab.github.io/2016/03/12/Cpp%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      <content type="html"><![CDATA[<p>C++ 是 Google 大部分开源项目的主要编程语言。正如每个 C++ 程序员都知道的，C++ 有很多强大的特性，但这种强大不可避免的导致它走向复杂，使代码更容易产生 bug，难以阅读和维护。</p>
<p>Google 经常会发布一些开源项目，意味着会接受来自其他代码贡献者的代码。但是如果代码贡献者的编程风格与 Google 的不一致，会给代码阅读者和其他代码提交这造成不小的困扰。Google 因此发布了这份自己的编程风格，使所有提交代码的人都能获知 Google 的编程风格。</p>
<p>创新工场董事长兼 CEO 李开复曾经对 Google C++ 编码规范给予了极高的评价：“我认为这是地球上最好的一份 C++ 编程规范，没有之一，建议广大国内外 IT 研究使用。”</p>
<a id="more"></a>
<hr>
<p>Google C++ 编码规范（英文）在线地址：<a href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml" target="_blank" rel="external">http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml</a><br>中文版下载：<a href="../../../assets/files/Google_Cpp_Style_guide_CN.pdf">Google C++ 编码规范(PDF)</a></p>
<hr>
<p>附上腾讯的规范：<a href="../../../assets/files/腾讯C++编码规范.pdf">腾讯C++编码规范(PDF)</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> Cpp </tag>
            
            <tag> Google </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++类模板小结]]></title>
      <url>http://pytlab.github.io/2016/03/11/Cpp%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>之前有总结过C++的<a href="../../../2016/02/05/Cpp函数模板小结/"><strong>函数模板具体化</strong></a>，里面按照隐式实例化、显式实例化和显式具体化来总结的。<br>类似函数模板的具体化，类模板具体化除了上面三种具体化方式还有一种叫部分具体化，下面简单总结下：</p>
<h3 id="隐式实例化"><a href="#隐式实例化" class="headerlink" title="隐式实例化"></a>隐式实例化</h3><p>这是最常使用的类模板实例化的方式，在<code>&lt;&gt;</code>中指出对象所需的类型，编译器使用通用模板提供的方式生成具体的类定义，编译器在程序需要对象之前不会隐式实例化生成类的具体定义的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ArrayTP&lt;<span class="keyword">int</span>, <span class="number">10</span>&gt; stuff;  <span class="comment">// 编译器使用参数int和10生成类定义然后生成对象并命名为stuff</span></div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="显式实例化"><a href="#显式实例化" class="headerlink" title="显式实例化"></a>显式实例化</h3><p>显式实例化还是针对的<strong>类定义的生成</strong>，相当于不要编译器决定生成什么类型的类而是由人强制让编译器给我生成一个类定义，使用方式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> <span class="keyword">class</span> ArrayTP&lt;<span class="built_in">string</span>, <span class="number">100</span>&gt;;  <span class="comment">// 生成一个ArrayTP&lt;string, 100&gt;类定义</span></div></pre></td></tr></table></figure></p>
<h3 id="显式具体化"><a href="#显式具体化" class="headerlink" title="显式具体化"></a>显式具体化</h3><p>我还是喜欢把它称为特殊化，他并不是个通用模板而是针对某一类型参数专门写的一个模板，因为特定的类型可能的处理方式（或者说行为）并不相同。以为还是一个模板一次还是需要<code>&lt;&gt;</code>符号的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">class</span> SortedArray&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其实我在想，这个直接定义一个<code>cosnt char *</code>类型的类有啥区别呢？</p>
<h3 id="部分具体化"><a href="#部分具体化" class="headerlink" title="部分具体化"></a>部分具体化</h3><p>C++还允许部分具体化(partial specialization)，及部分限制模板的通用性，例如，部分具体化可以给类型参数之一制定具体的类型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通用模板</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt; <span class="keyword">class</span> Pair &#123;...&#125;;</div><div class="line"><span class="comment">// 将类型T2进行部分具体化</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T1&gt; <span class="keyword">class</span> Pair&lt;T1, <span class="keyword">int</span>&gt; &#123;...&#125;;</div></pre></td></tr></table></figure></p>
<p>这里其实就相当于把要具体化的类型参数移到后面的尖括号中，若全部移过去就相当于第3条中的显式具体化了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">class</span> Pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &#123;...&#125;;  <span class="comment">// 这就是一个显式具体化了</span></div></pre></td></tr></table></figure></p>
<p>这样部分具体化出来的还是一个模板，因为他不是实例化。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++类继承中需要注意的那点东西(二)]]></title>
      <url>http://pytlab.github.io/2016/03/10/Cpp%E7%B1%BB%E7%BB%A7%E6%89%BF%E4%B8%AD%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%82%A3%E7%82%B9%E4%B8%9C%E8%A5%BF-%E4%BA%8C/</url>
      <content type="html"><![CDATA[<p>在C++中使用面向对象思想的类继承，我觉得最关键的还是要理解父类是如何把成员继承给派生类的。<br><div class="alert alert-info"><i class="fa fa-info"></i>  我的理解就是父类其实以一种独立的未命名的对象存在于派生类中，就好象包含关系一样。</div><br>只要理解了上面这点，在写派生类的各种方法（构造函数，赋值函数等）的时候把父类甚至是父类的父类当作独立的未命名的对象来处理关系就会非常的明确了。<br><a id="more"></a></p>
<h3 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h3><p>私有继承的作用和包含差不多都是<em>has-a</em>关系，但是在处理起来没有包含那么的直接。<br>例如如果要返回包含在派生类中父类的对象时，若是包含关系可以直接通过公有接口调用返回所包含对象即可。但是在私有继承中父类没有具体的名字也就不能直接返回父类对象了，<strong>唯一可以返回和使用的对象就是派生类本身<code>*this</code></strong>，所以通常情况下返回父类对象是通过将<code>*this</code>进行up-casting强制类型转换，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这是一共私有继承string类的一个派生类中</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)(*<span class="keyword">this</span>);</div></pre></td></tr></table></figure></p>
<p>对于私有继承中的方法，派生类继承的是父类方法的实现，并没有继承父类方法的接口。也就是说，<strong>与数据成员不同，私有继承的方法是可以在派生类内部通过作用域解析运算符来调用的，但是外部世界无法访问父类的任何数据和方法</strong></p>
<hr>
<h3 id="多重继承-MI"><a href="#多重继承-MI" class="headerlink" title="多重继承(MI)"></a>多重继承(MI)</h3><p>关于多重继承第一次看书的时候也是感觉里面的关系很绕，主要是要把代码进行重新整理以避免在多重继承中出现普通继承中不会出现的问题例如各种<strong>二义性</strong>。<br>对此要做出的调整我在这里总结下：</p>
<p>先写个简单的例子说明下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A:  <span class="comment">// 祖先类</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> a;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> B : <span class="keyword">virtual</span> <span class="keyword">public</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> b;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> C : <span class="keyword">virtual</span> <span class="keyword">public</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> c;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> D : <span class="keyword">public</span> C, <span class="keyword">public</span> B</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> E : <span class="keyword">public</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> e;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> F : <span class="keyword">public</span> E</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">   <span class="keyword">int</span> f;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用虚基类是避免出现派生类中出现两个祖先导致二义性的特性。通过使用虚基类本质上来说，第二代类对象<strong>共享一个</strong>第一代A对象，而不是各自引入自己的第一代A对象的副本。<br><br></p>
<h4 id="构造函数中"><a href="#构造函数中" class="headerlink" title="构造函数中"></a>构造函数中</h4><p>在构造函数中要注意，如果没有使用虚基类，则类继承中会有信息传递，即F的构造函数初始化父类E对象和数据成员f，初始化E对象的时候会初始化E的父类A对象和数据成员e。但是这种传递在多重继承时便会出现同时有两个祖先类的二义性。<br>所以使用虚基类的时候这种信息传递将不会起作用，即不会自动调用A的构造函数，然后通过A类的默认构造函数初始化公用的A对象。<br>如果不希望默认构造函数来构造虚基类对象，则要显式的调用所需的基类构造函数（我一般都这样显式调用，这样会比较清晰）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">D:D(<span class="keyword">const</span> A &amp; a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</div><div class="line">    : A(a), B(A, b), C(A, c)</div><div class="line">&#123;  <span class="comment">// 当然要在B,C中定义相应的构造函数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另外在写代码的时候也会遇到一种构造函数的情况：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">highfink::highfink(<span class="keyword">const</span> fink &amp; f, <span class="keyword">int</span> ico)</div><div class="line">    : abstr_emp(f), fink(f), manager((<span class="keyword">const</span> abstr_emp &amp;)f, ico)  <span class="comment">// ????</span></div><div class="line">&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里为了初始化manager，我先讲fink类强制转换类型成为基类然后使用转换后的基类和另一个成员数据初始化manager。这是我按照理解进行的处理，可以通过编译。如果以后遇到这种情况还有其他方法我在写上来。</p>
<h4 id="使用哪个方法？"><a href="#使用哪个方法？" class="headerlink" title="使用哪个方法？"></a>使用哪个方法？</h4><p>因为可能在两个父类中有名称相同的成员函数，那么在子类调用的时候是调用那个父类的成员方法呢？<br>这种避免二义性的方法是使用<strong>模块化方式</strong>。<br>即通过在父类中写几个模块化的函数并protected起来，然后通过使用作用域解析运算符来组合成子类的相应的成员方法。例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> SingerWaiter::Show() <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Category: singing waiter\n"</span>;</div><div class="line">    Worker::Data();</div><div class="line">    Data();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在祖先相同时，使用MI必须引入虚基类，并修改构造初始化列表的规则。同时如果编写这些类的时候没有考虑到MI，则还可能要重新编写他们。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[内联函数的位置]]></title>
      <url>http://pytlab.github.io/2016/03/09/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>我说上次为啥在实现文件中定义内联函数的时候，编译器说找不到函数定义。看来还是书没看仔细啊。<br>内联函数的<strong>链接性是内部</strong>的，这意味着：<strong>内联函数定义必须在使用函数的文件中</strong><br>因此将内联函数的定义放入头文件中，可以在使用函数的文件中包含头文件确保能找到内联函数的定义。</p>
<p>若想将函数定义放入实现文件中，对不起，请把<code>inline</code>关键字删掉吧，这样函数的链接性才是外部的。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C </tag>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python开发者微信公众号]]></title>
      <url>http://pytlab.github.io/2016/03/08/python%E5%BC%80%E5%8F%91%E8%80%85%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/</url>
      <content type="html"><![CDATA[<p><img src="/assets/images/blog_img/2016-03-08-python开发者微信公众号/pythondev.png" alt=""></p>
]]></content>
      
        
        <tags>
            
            <tag> python </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[static和const成员变量的初始化]]></title>
      <url>http://pytlab.github.io/2016/03/07/static%E5%92%8Cconst%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      <content type="html"><![CDATA[<h4 id="static成员变量"><a href="#static成员变量" class="headerlink" title="static成员变量"></a>static成员变量</h4><p>不能在类声明中初始化，要在方法文件中初始化，参考：<a href="../../../../2016/02/28/关于Cpp类的静态成员变量和函数/">关于C++类的静态成员变量</a></p>
<h4 id="const成员变量"><a href="#const成员变量" class="headerlink" title="const成员变量"></a>const成员变量</h4><p>由于是const类型一定要在创建的时候初始化，因此在成员初始化列表中进行初始化，参考：<a href="../../../../2016/03/04/Cpp类构造函数的特殊初始化成员函数的语法/">C++类构造函数的特殊初始化成员函数的语法</a></p>
<h4 id="const-static-成员变量"><a href="#const-static-成员变量" class="headerlink" title="const static 成员变量"></a>const static 成员变量</h4><p>负负得正，“干脆就在类声明中初始化了吧”C++编译器如是说。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++类继承中需要注意的那点东西(一)]]></title>
      <url>http://pytlab.github.io/2016/03/07/Cpp%E7%B1%BB%E7%BB%A7%E6%89%BF%E4%B8%AD%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%82%A3%E7%82%B9%E4%B8%9C%E8%A5%BF-%E4%B8%80/</url>
      <content type="html"><![CDATA[<p>关于C++中的派生类和基类的关系就总结下来就是：</p>
<ol>
<li>派生类继承了基类的部分方法</li>
<li>有些方法是不能被继承的，例如构造函数、析构函数、赋值运算符</li>
<li>基类的数据成员也会继承下来，但是<code>private</code>成员是不能够被派生类直接访问的，需要通过基类的共有方法来访问，<code>protected</code>数据是可以向public数据一样被派生类通过名称空间解析运算符<code>::</code>来访问。</li>
</ol>
<div class="alert alert-info"><i class="fa fa-info"></i>  我就把派生类想象成了一个包含基类的类，基类的小秘密不对外公开，想要改变小秘密的内容要使用基类自己的方法（比如基类的构造函数，基类的赋值运算符函数等），总之代码写下来感觉，其实基类在派生类中还是很<strong>独立的</strong>。
<br>
在派生类构造派生类之前先调用基类的构造函数初始化基类组件，在调用派生类析构函数时会在析构派生类对象之后调用基类的析构函数释放基类组件。顺序保持一致。</div>
<a id="more"></a>
<hr>
<p>下面总结下要注意（或者说我后面可能会忘记）的一些东西</p>
<h3 id="重新定义的赋值运算符"><a href="#重新定义的赋值运算符" class="headerlink" title="重新定义的赋值运算符"></a>重新定义的赋值运算符</h3><p>赋值运算符是不能够被继承的，原因很简单：赋值运算符的重载函数返回的是本对象的类型值的引用，派生类和基类的类型并不相同，也就没有什么继承的必要了。因此要重新定义赋值运算符。<br>在重载赋值运算符时要显式的调用基类的赋值运算符函数来给基类的私有成员赋值，例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">hasDMA &amp; hasDMA::<span class="keyword">operator</span>=(<span class="keyword">const</span> hasDMA &amp; hs)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;hs)</div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    ABC::<span class="keyword">operator</span>=(hs);</div><div class="line">    <span class="keyword">delete</span> [] style;</div><div class="line">    style = <span class="keyword">new</span> <span class="keyword">char</span> [<span class="built_in">std</span>::<span class="built_in">strlen</span>(hs.style) + <span class="number">1</span>];</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(style, hs.style);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="通过成员初始化列表初始化基类继承来的成员数据"><a href="#通过成员初始化列表初始化基类继承来的成员数据" class="headerlink" title="通过成员初始化列表初始化基类继承来的成员数据"></a>通过成员初始化列表初始化基类继承来的成员数据</h3><p>因为基类就好像是派生类内部的一个独立的个体，因此要给他里面的私有成员赋值还是要调用基类自己的构造函数来，例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">hasDMA::hasDMA(<span class="keyword">const</span> <span class="keyword">char</span> * s, <span class="keyword">const</span> <span class="keyword">char</span> * l, <span class="keyword">int</span> r)</div><div class="line">    : ABC(l, r)</div><div class="line">&#123;</div><div class="line">    style = <span class="keyword">new</span> <span class="keyword">char</span> [<span class="built_in">std</span>::<span class="built_in">strlen</span>(s) + <span class="number">1</span>];</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(style, s);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>若是复制构造函数，则直接使用派生类对象初始化基类成员变量，因为是可以把派生类赋值给基类的，例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">hasDMA::hasDMA(<span class="keyword">const</span> <span class="keyword">char</span> * s, <span class="keyword">const</span> ABC &amp; c)</div><div class="line">    : ABC(c)</div><div class="line">&#123;</div><div class="line">    style = <span class="keyword">new</span> <span class="keyword">char</span> [<span class="built_in">std</span>::<span class="built_in">strlen</span>(s) + <span class="number">1</span>];</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(style, s);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="是否要重新定义构造函数，复制运算符函数，析构函数这些不能被继承的成员方法？"><a href="#是否要重新定义构造函数，复制运算符函数，析构函数这些不能被继承的成员方法？" class="headerlink" title="是否要重新定义构造函数，复制运算符函数，析构函数这些不能被继承的成员方法？"></a>是否要重新定义构造函数，复制运算符函数，析构函数这些不能被继承的成员方法？</h3><ol>
<li><p>即使派生类没有添加任何数据成员，仍需要构造函数，可以为空但必须存在，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">baseDMA::baseDMA(<span class="keyword">const</span> <span class="keyword">char</span> * c, <span class="keyword">int</span> r) : ABC(l, r)</div><div class="line">&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>如果在派生类中没有重新定义赋值运算符函数和析构函数则会使用编译器自动生成的这些函数，<br>默认的赋值就是将数据成员简单的复制，即<strong>浅复制</strong><br><strong>若类中有其他对象作为数据成员，则会使用这些对象的赋值运算符函数来进行复制。</strong><br><strong>派生类中的基类组件会使用基类的赋值运算符函数将基类组件整个打包复制过去</strong><br>若派生类中新增了指针数据变量指向动态分配的内存，则请显式的重新定义赋值函数吧。<br>析构函数也是如此。</p>
</li>
</ol>
<hr>
<h3 id="关于友元函数"><a href="#关于友元函数" class="headerlink" title="关于友元函数"></a>关于友元函数</h3><p>由于友元函数并不是类的成员，因此他不能被继承。我一直理解为在派生类中也一定要重新定义相应的友元函数。但是在做练习时候我发现，即使不重新定义友元函数，派生类对象仍旧可以调用基类的友元函数（例如<code>&lt;&lt;</code>重载函数，就会调用基类的友元函数将基类的数据成员显式出来）<br>若派生类在基类的基础上添加了新的成员数据，那还是要重新定义友元函数了。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++类构造函数的特殊初始化成员函数的语法]]></title>
      <url>http://pytlab.github.io/2016/03/04/Cpp%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E6%AE%8A%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>先上个例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Quene &#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> items;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> qsize;  <span class="comment">// 私有数据成员是常量</span></div><div class="line">    ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 构造函数</span></div><div class="line">Quene::Quene(<span class="keyword">int</span> qs)</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    qsize = qs;  <span class="comment">// !! NOT ALLOWED !!</span></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>为什么不允许?</strong><br>首先类声明是不分配内存的,也就是说不能在类定义中进行变量初始化（静态常量除外,当然C++11已经支持在类声明中进行变量初始化了）。<br>程序接着执行，进行对象的创建：</p>
<ol>
<li>先分配内存创建对象，这个时候还没有执行构造函数函数体（也就是<code>{}</code>中的代码），还未对数据进行初始化</li>
<li>然后执行构造函数的函数体，这是执行到赋值qs的时候就会报错，因为这是个常量，创建以后是无法修改常量的值的。<a id="more"></a>
</li>
</ol>
<p><strong>那怎么办？</strong><br>C++提供的特殊初始化语法就用在这个时候，他是将初始化<strong>插</strong>在步骤1和步骤2之间，也就是在创建对象之后执行构造函数函数体之前进行初始化。<br>其语法如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Quene::Quene(<span class="keyword">int</span> qs) : qsize(qs), items(<span class="number">0</span>), ...</div><div class="line">&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>括号中只能是构造函数的参数和常量。<br>这种语法叫做<strong>成员初始化列表</strong></p>
<p>使用这种初始化方式的注意事项：</p>
<ol>
<li>这种格式只能用于构造函数</li>
<li>C++11之前必须使用这种方式初始化非静态的const数据成员</li>
<li>必须使用这种方式来初始化<strong>引用</strong>成员数据</li>
</ol>
<p><strong>为什么引用数据成员必须使用这种方式初始化？</strong><br>因为引用变量必须在创建的时候初始化，创建对象的时候要紧接着将其初始化成其他变量的一个引用，不能留到后面了。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于C++的返回对象]]></title>
      <url>http://pytlab.github.io/2016/03/04/%E5%85%B3%E4%BA%8EC-%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<p>这里主要总结两种: </p>
<ol>
<li>返回指向<code>const</code>/非<code>const</code>对象的引用</li>
<li>返回<code>const</code>/非<code>const</code>对象<a id="more"></a>
</li>
</ol>
<h3 id="返回对象的引用"><a href="#返回对象的引用" class="headerlink" title="返回对象的引用"></a>返回对象的引用</h3><h4 id="返回指向const对象的引用"><a href="#返回指向const对象的引用" class="headerlink" title="返回指向const对象的引用"></a>返回指向const对象的引用</h4><p>这种是常见的返回方式，相对于返回对象，这种方式能够<strong>提高效率</strong>。<br>如果函数返回传递给他的对象（不是函数内部的局部变量），则返回该对象的引用会提高效率。这是因为：<br><div class="alert alert-info"><i class="fa fa-info"></i>  返回对象要先创建一个<strong>临时对象</strong>，并将这个临时对象<strong>初始化为要返回的对象</strong>，这样就会调用类的<strong>复制构造函数</strong>，这样直接返回引用就不会有前面的一些附加操作，因此效率会高。</div></p>
<p>注意：若返回的对象本身在参数中就是<code>const</code>引用，则返回类型必须是<code>const</code>，这样才匹配。</p>
<h4 id="返回指向非const对象的引用"><a href="#返回指向非const对象的引用" class="headerlink" title="返回指向非const对象的引用"></a>返回指向非const对象的引用</h4><p>两种常见的返回非const对象的情况是：</p>
<ol>
<li>重载复制运算符，在这里之所以不返回指向const对象的引用是为了能够<strong>修改</strong>返回的对象。</li>
<li>与<code>cout</code>一起使用的<code>&lt;&lt;</code>运算符，这里是必须声明称<strong>非const</strong>的返回对象，例如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">cout</span>, s1);</div><div class="line">...</div><div class="line"><span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="string">" is coming"</span>;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>第一个<code>&lt;&lt;</code>返回用于显示s1内容的对象，第二个<code>&lt;&lt;</code>返回用于显示<code>&quot; is coming&quot;</code>的对象，每次都不一样，因此不能使用<code>const</code>关键字(个人理解)</p>
<p>另外，如果返回的对象<strong>没有公共的复制构造函数</strong>（如<code>cout</code>对象），则必须返回引用，不然你返回对象也找不到复制构造函数创建临时对象啊。</p>
<h3 id="返回对象"><a href="#返回对象" class="headerlink" title="返回对象"></a>返回对象</h3><h4 id="返回非const对象"><a href="#返回非const对象" class="headerlink" title="返回非const对象"></a>返回非const对象</h4><p>如果返回的对象是在函数内部生成的局部变量，就不能返回其引用了，因为当函数执行完毕后，该变量的就会销毁，所谓的指向其的引用也就没有任何意义了。<br>一般在重载<code>+</code>运算符的时候会返回对象，而不是对象本事，因为会创建一个新对象，这个对象是在函数体内生成的，具有局部作用域。</p>
<h4 id="返回const对象"><a href="#返回const对象" class="headerlink" title="返回const对象"></a>返回const对象</h4><p>其实一般在重载<code>+</code>运算符的时候返回的是const对象，这是为了避免某种错误。<br>之所以返回对象是为了能够如下使用<code>+</code>运算符：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">r = a + b;</div></pre></td></tr></table></figure></p>
<p>然而若不返回const对象则会造成，如下语句也是合理的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a + b = r;</div></pre></td></tr></table></figure></p>
<p>该语句之所以编译器不报错，是因为<code>a + b</code>会返回一个非const的临时对象，然后复制语句<code>= r</code>会将r赋值给这个临时对象，之后这个临时对象就会销毁掉了。其中并没有任何错误可报告的，毕竟返回的这个临时对象的内容是可以修改的嘛。<br>因此返回const对象就不允许修改返回的临时对象的内容，遇到这种语句自然就会报错了。因此<br><div class="alert alert-warning"><i class="fa fa-bell"></i>  在重构类似<code>+</code>，<code>-</code>等运算符时，要返回<code>const</code>对象。</div></p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于C++的定位new运算符]]></title>
      <url>http://pytlab.github.io/2016/03/02/%E5%85%B3%E4%BA%8E%E5%AE%9A%E4%BD%8Dnew%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      <content type="html"><![CDATA[<p><code>new</code>运算符负责在堆中(heap)中找到足以能够满足要求的内存块。<br>定位(placement)<code>new</code>运算符是<code>new</code>运算符的变体，能够指定要使用的位置。可以使用这种特性来设置其内存管理规程，处理需要通过特定地址访问的硬件或在特定位置创建对象。<br><a id="more"></a></p>
<h3 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h3><p>要使用定位运算符首先要包含头文件<code>#include &lt;new&gt;</code>。<br>使用方式是在<code>new</code>运算符后面括号中添加所需地址的参数，例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> buffer[<span class="number">50</span>];</div><div class="line"><span class="keyword">int</span> * p;</div><div class="line">p = <span class="keyword">new</span> (buffer) <span class="keyword">int</span>[<span class="number">20</span>];  <span class="comment">// int数组放在以buffer为起始位置的静态内存中</span></div></pre></td></tr></table></figure></p>
<p>定位<code>new</code>运算的本质其实就是把传递给他的地址强制转换成<code>void *</code>类型然后返回以便能够赋值给任何指针类型。<br>使用<code>new</code>运算符时候会触发<code>new()</code>函数，常规运算符的<code>new()</code>接受一个参数，定位运算符的<code>new()</code>接受两个参数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> * p1 = <span class="keyword">new</span> <span class="keyword">int</span>;  <span class="comment">// 触发 new(sizeof(int))</span></div><div class="line"><span class="keyword">int</span> * p2 = <span class="keyword">new</span> (buffer) <span class="keyword">int</span>;  <span class="comment">// 触发 new(sizeof(int), buffer)</span></div><div class="line"><span class="keyword">int</span> * p3 = <span class="keyword">new</span> (buffer) <span class="keyword">int</span>[<span class="number">30</span>];  <span class="comment">// 触发 new(30*sizeof(int), buffer)</span></div></pre></td></tr></table></figure></p>
<h3 id="与初始化结合"><a href="#与初始化结合" class="headerlink" title="与初始化结合"></a>与初始化结合</h3><p>定位<code>new</code>运算符的另一种用法是将其与初始化结合使用，<strong>从而将信息放在特定的硬件地址处</strong><br>调用方式是在最后面添加括号，在括号中添加参数，C++会调用相应的构造函数。例如<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String * pstr = <span class="keyword">new</span> String(str1);  <span class="comment">// 这将调用复制构造函数将对象str1复制并初始化</span></div><div class="line">JustTesting * p = <span class="keyword">new</span> (buffer) JustTesting(<span class="string">"Test"</span>, <span class="number">6</span>);  <span class="comment">// 调用构造函数在相应地址处放置JustTesting对象的数据</span></div></pre></td></tr></table></figure></p>
<h3 id="delete-和-new"><a href="#delete-和-new" class="headerlink" title="delete 和 new"></a>delete 和 new</h3><p><code>delete</code>和<code>new</code>绝对是分不开了，而且在定位运算符中这俩还是处理起来比较复杂，很容易出错。</p>
<ol>
<li><p>若是定位到由数组分配的空间，也就静态内存中，便不能使用<code>delete</code>来进行内存释放。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> buffer[<span class="number">50</span>];</div><div class="line"><span class="keyword">int</span> * p;</div><div class="line">p = <span class="keyword">new</span> (buffer) <span class="keyword">int</span>[<span class="number">20</span>];  <span class="comment">// int数组放在以buffer为起始位置的静态内存中</span></div></pre></td></tr></table></figure>
<p> buffer指定的就是静态内存，而<code>delete</code>只能用于这样的指针：<strong>指向常规new运算符分配的堆内存</strong>，也就是说buffer位于<code>delete</code>的管辖之外，所以只能坐等代码块结束自动释放掉了。</p>
</li>
<li><p>若是定位到由<code>new</code>分配的内存中，则要注意：</p>
 <div class="alert alert-warning"><i class="fa fa-bell"></i>  <code>delete</code>只能释放最初分配内存时候得到的内存，但是之后在这块内存上创建的对象是释放不掉的。</div>
<p> 例如我先分配了一块内存</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> * buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">30</span>];</div></pre></td></tr></table></figure>
<p> 然后我再上面使用定位<code>new</code>运算符初始化一个对象：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">JustTesting * p = <span class="keyword">new</span> (buffer) JustTesting(<span class="string">"Test"</span>, <span class="number">6</span>);</div></pre></td></tr></table></figure>
<p> 但是最后我使用<code>delete</code>释放掉buffer</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">delete</span> [] buffer;</div></pre></td></tr></table></figure>
<p> Ok，buffer指向的内存块释放掉了，但是创建的JustTesting对象没析构。<br> 也就是说<code>new</code>和<code>delete</code>只知道已经分配的30个字节但是定位<code>new</code>运算符在这30个字节上面做过什么<code>delete</code>和<code>new</code>可都是一无所知。所以要析构上面的对象要显式的调用其析构函数：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p-&gt;~JustTesing();</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="最后一点"><a href="#最后一点" class="headerlink" title="最后一点"></a>最后一点</h3><p>对于使用定位<code>new</code>运算符创建的对象，英语创建顺序相反的顺序进行删除。原因在于，晚创建的对象可能依赖于早创建的对象。另外仅当所有对象都被销毁后，才能释放用于存储这些对象的内存（在上面的例子中也就是buffer）。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[kMC中的Markov Chain(马尔可夫链)]]></title>
      <url>http://pytlab.github.io/2016/02/28/kMC%E4%B8%AD%E7%9A%84Markov-Chain-%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE/</url>
      <content type="html"><![CDATA[<p>在动力学蒙特卡洛kMC模拟中，因为组态变化的时间间隔很长，体系完成的连续两次演化是独立的，无记忆的，所以这个过程是一种典型的马尔可夫过程(Markov process)。<br>下面先定义下符号：<br><div class="alert alert-info"><i class="fa fa-info"></i>  <br>
configuration: $u, v, ... $
<br>
event: $ \alpha, \beta , ... $
<br>
transition rate($v \rightarrow u$) : $ \omega_{u v} $</div></p>
<h3 id="Master-Equation"><a href="#Master-Equation" class="headerlink" title="Master Equation"></a>Master Equation</h3><p>体系的时间演变通过<strong>Markov master equation</strong>来描述<br>$$ \bar{p}_{u}(t) = \sum_{v}^{}{\omega_{u v}p_{v}(t) - \omega_{v u}p_{u}(t)} $$<br>其中${p}_{u}(t)$是体系在时间$t$处在$u$的概率。<br><a id="more"></a></p>
<h3 id="Transition-Matrix"><a href="#Transition-Matrix" class="headerlink" title="Transition Matrix"></a>Transition Matrix</h3><p>类似统计力学中的Probability Vector， kMC中也应该有一个向量来表示体系的概率状态，在这里我用一个向量$\pi(t)$表示<br>$$<br>\pi(t) = \left[\begin{matrix}<br>         p_{u}(t)\\<br>         p_{v}(t)\\<br>         p_{o}(t)\\<br>         .\\<br>         .\\<br>         .\\<br>    \end{matrix} \right]<br>$$<br>其中向量中的entry中${p}_{u}(t)$表示体系在时间$t$处在$u$的概率<br>则整个kMC的体系的演化过程也就是这个状态向量的演变过程。有向量的演变，则必须有相应的转移矩阵的存在即所谓的markov矩阵，Transfer/Transition Matrix。<br>在这里transition matrix用$\omega$表示<br>$$<br>\omega =<br>    \left[\begin{matrix}<br>         k_{u \rightarrow u} &amp; k_{v \rightarrow u} &amp; k_{o \rightarrow u} &amp; …\\<br>         k_{u \rightarrow v} &amp; k_{v \rightarrow v} &amp; k_{o \rightarrow v} &amp; …\\<br>         k_{u \rightarrow o} &amp; k_{v \rightarrow o} &amp; k_{o \rightarrow o} &amp; …\\<br>         . &amp; . &amp; . &amp; …\\<br>         . &amp; . &amp; . &amp; …\\<br>         . &amp; . &amp; . &amp; …\\<br>    \end{matrix} \right]<br>$$<br>若模拟的网格的大小为$300 \times 300$，且每个位点可能的状态为$3$个（例如CO氧化反应），则方阵$\omega$的为$3^{n \times n}$阶方阵，总共有$3^{2n^{2}}$个元素，可见如果要模拟的体系很大的时候，这个矩阵式非常非常非常的大的（重要的事情重复三遍）！</p>
<p>矩阵中的每一列针对的是起始于同一种configuration，每一行针对的是同一种终态configuration。<br>例如transfer matrix中的第$u$列的列向量$V_{u}$就等于configuration为$u$时的事件的列表，<br>$$<br>V_{u} = \left[\begin{matrix}<br>         \alpha_{u \rightarrow u}\\<br>         \alpha_{u \rightarrow v}\\<br>         \alpha_{u \rightarrow o}\\<br>         .\\<br>         .\\<br>         .\\<br>    \end{matrix} \right]<br>    =<br>    \left[\begin{matrix}<br>         k_{u \rightarrow u}\\<br>         k_{u \rightarrow v}\\<br>         k_{u \rightarrow o}\\<br>         .\\<br>         .\\<br>         .\\<br>    \end{matrix} \right]<br>$$<br>其中不为0的entry为可发生事件的发生速率。</p>
<h3 id="Ensemble-Average"><a href="#Ensemble-Average" class="headerlink" title="Ensemble Average"></a>Ensemble Average</h3><p>通过多个trajectory可以得到多个体系的演化过程，大量的系综平均可以得到近似的$p_{u}(t)$值.<br>$$<br>traj(i): \pi_{1}^{i} \rightarrow \pi_{2}^{i} \rightarrow \pi_{2}^{i} \rightarrow … \\<br>traj(j): \pi_{1}^{j} \rightarrow \pi_{2}^{j} \rightarrow \pi_{2}^{j} \rightarrow … \\<br>traj(s): \pi_{1}^{s} \rightarrow \pi_{2}^{s} \rightarrow \pi_{2}^{s} \rightarrow … \\<br>.\\<br>.\\<br>.<br>$$  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>因此，通过状态向量和转移矩阵就可以构成kMC中的Markov链，当然这只是将kMC过程抽象出来的理论模型，由于转移矩阵过于庞大，只能用所谓的trajectory的方法来做系综平均的方法来进行kMC模拟。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Kynetix </tag>
            
            <tag> catalysis </tag>
            
            <tag> LinearAlgebra </tag>
            
            <tag> 学术 </tag>
            
            <tag> kMC </tag>
            
            <tag> Monte Carlo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于C++类的静态成员变量]]></title>
      <url>http://pytlab.github.io/2016/02/28/%E5%85%B3%E4%BA%8ECpp%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>静态成员是单独存储的，不是对象的组成部分。</p>
<h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h3><p>不能在类声明中初始化静态成员变量，这是因为声明描述了如何分配内存，但并不分配内存。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> StringBad</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num_strings;</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>静态成员变量是在方法文件中进行初始化，若刚在头文件中初始化会造成多个初始化语句引发错误。<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 类方法定义的文件中</span></div><div class="line">include <span class="string">"string_bad.h"</span></div><div class="line"><span class="comment">// 初始化静态成员函数</span></div><div class="line"><span class="keyword">int</span> StringBad::num_string = <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<p>初始化语句指出了<strong>变量类型</strong>，并使用了作用于运算符<code>::</code>，但没有使用关键字<code>static</code>。</p>
<h4 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h4><p>当静态成员变量是<code>const</code>整数类型或者<strong>枚举类型</strong>时，是可以在类声明中进行初始化的，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> StringBad </div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> LEN = <span class="number">10</span>;</div><div class="line">    <span class="keyword">enum</span> Mode &#123;UP, LOW&#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<div class="alert alert-info"><i class="fa fa-info"></i>  总结： 
<br>
<li>静态数据成员在类声明中声明，在包含类方法的文件中进行初始化。初始化的时候<strong>使用作用域运算符来指出静态成员所属的类</strong>。</li>
<li>但如果静态成员是<code>const</code>或是枚举类型，则可以在类声明中进行初始化。</li></div>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于C++特殊成员函数]]></title>
      <url>http://pytlab.github.io/2016/02/27/%E5%85%B3%E4%BA%8ECpp%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>C++编译器会自动生成几个成员函数，这里属于接触到的新东西，而且如果不了解C++编译器的这种机制，在很多时候会因为隐式的调用这几个特殊的成员函数而导致程序发生错误。</p>
<p><strong>特殊成员函数</strong></p>
<ul>
<li>默认构造函数</li>
<li>默认析构函数</li>
<li>复制构造函数</li>
<li>赋值运算符</li>
<li>地址运算符<a id="more"></a>
</li>
</ul>
<hr>
<h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><p>因为创建类对象的时候总<strong>需要调用构造函数</strong>，若在类定义时候没有提供任何构造函数，C++将创建默认的构造函数。例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Klunk::Klunk()</div><div class="line">&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>默认构造函数是Klunk类似于一个常规的自动变量，其中的值在初始化时是未知的。</p>
<hr>
<h3 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h3><div class="alert alert-warning"><i class="fa fa-bell"></i>  用于将一个对象复制到<strong>新创建</strong>的对象中。也就是说，他用于<strong>初始化</strong>过程中（包括在函数调用时按值传递参数，初始化形参的时候），而不是常规的赋值过程（赋值过程使用的是重载的赋值运算符）</div>
<p>原型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Class_name(<span class="keyword">const</span> Class_name &amp;);</div></pre></td></tr></table></figure></p>
<h4 id="复制构造函数何时调用"><a href="#复制构造函数何时调用" class="headerlink" title="复制构造函数何时调用"></a>复制构造函数何时调用</h4><ol>
<li><p><strong>在创建一个对象并且初始化为相同类型的对象的时候</strong>，复制函数都将被调用。例如下面这四种声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*创建StringBad对象ditto并初始化为motto的副本*/</span></div><div class="line"><span class="function">StringBad <span class="title">ditto</span><span class="params">(motto)</span></span>;</div><div class="line">StringBad ditto = motto;</div><div class="line">StringBad ditto = StringBad(motto);</div><div class="line">StringBad * pStringBad = <span class="keyword">new</span> StringBad(motto);</div></pre></td></tr></table></figure>
</li>
<li><p><strong>在函数中返回对象将调用对象的复制构造函数</strong><br>在函数返回对象（非引用）时，会调用对象的复制构造函数创建一个临时对象来表示返回值，后再使用这个临时对象（赋值，显示等等），在将其丢弃。</p>
</li>
<li><p><strong>按值将对象传给函数的时候</strong><br>按值传递函数相当于将形参初始化为实参的值。</p>
</li>
<li><p><strong>编译器生成临时对象</strong></p>
</li>
</ol>
<h4 id="复制构造函数的功能"><a href="#复制构造函数的功能" class="headerlink" title="复制构造函数的功能"></a>复制构造函数的功能</h4><p>复制构造函数将逐个复制对象的非静态成员到调用对象中，如果是指针变量只复制指针的值，即所谓的浅复制。用代码表示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">StringBad sailor = sports;</div></pre></td></tr></table></figure></p>
<p>等效于<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">StringBad sailor;</div><div class="line">sailor.str = sports.str;  <span class="comment">// char指针变量</span></div><div class="line">sailor.len = sports.len;</div></pre></td></tr></table></figure></p>
<p>当然不能在程序中这么写啦，<code>str</code>和<code>len</code>这些都是<code>sailor</code>的私有变量。</p>
<hr>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>C++通过自动重载赋值运算符来允许类对象赋值。</p>
<h4 id="赋值运算符重载何时使用"><a href="#赋值运算符重载何时使用" class="headerlink" title="赋值运算符重载何时使用"></a>赋值运算符重载何时使用</h4><p>将已有的对象赋给另一个对象的时候，将使用重载的赋值运算符。例如<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">StringBad a = StringBad(<span class="string">"shao"</span>);</div><div class="line">StringBad b;</div><div class="line">b = a;</div></pre></td></tr></table></figure></p>
<h4 id="赋值运算符的功能"><a href="#赋值运算符的功能" class="headerlink" title="赋值运算符的功能"></a>赋值运算符的功能</h4><p>也是类似复制构造函数，逐个将数据复制到调用对象中，<strong>静态变量不受影响</strong><br>但在自定义赋值运算符的时候除了赋值数据还要：</p>
<ul>
<li>由于目标对象可能引用了以前分配的数据，所以在赋值前要使用<code>delete</code>将其释放</li>
<li>避免将对象赋值给自身</li>
<li>函数返回一个指向调用对象的引用，即返回<code>*this</code></li>
</ul>
<h4 id="显式提供赋值运算符的步骤"><a href="#显式提供赋值运算符的步骤" class="headerlink" title="显式提供赋值运算符的步骤"></a>显式提供赋值运算符的步骤</h4><ol>
<li><p>判断是否是赋值给自身，例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == &amp;hs)</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>若是派生类的对象进行复制，先将基类的组件复制<br>主要是通过<strong>作用域解析运算符显式的调用赋值运算符重载函数形式</strong>来赋值基类组件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">baseDMA::<span class="keyword">operator</span>=(hs);</div></pre></td></tr></table></figure>
</li>
<li><p>删除就对象中的成员数据（通过<code>new</code>运算符动态分配的）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">delete</span> [] style;</div></pre></td></tr></table></figure>
</li>
<li><p>将新的数据复制到调用的对象中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">style = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">std</span>::len(hs.style) + <span class="number">1</span>];</div><div class="line"><span class="built_in">std</span>::<span class="built_in">strcpy</span>(style, hs.style);</div></pre></td></tr></table></figure>
</li>
<li><p>返回调用对象的引用（非const）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="地址运算符"><a href="#地址运算符" class="headerlink" title="地址运算符"></a>地址运算符</h3><p>隐式的地址运算符返回调用对象的地址（即<code>this</code>指针的值）</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于C++友元函数的访问权限]]></title>
      <url>http://pytlab.github.io/2016/02/26/%E5%85%B3%E4%BA%8E%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/</url>
      <content type="html"><![CDATA[<p>友元函数与普通的非成员函数不同，它可以访问类的私有成员。</p>
<ul>
<li>友元函数不是成员函数，因此不能使用成员运算符<code>.</code>来调用</li>
<li>但它与成员函数的访问权限相同</li>
</ul>
<p>看到上面第二条我天真的理解成了，在友元函数定义中也可以向成员函数那样直接使用类中的变量呢，结果编译器就啪啪啪的打了我的脸。<br>我在一个<code>&lt;&lt;</code>运算符重载友元函数中这样使用的类变量：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// friend functions</span></div><div class="line"><span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> Stonewt &amp; st)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(st.status == STN)</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; st.stone &lt;&lt; <span class="string">" stone, "</span> &lt;&lt; st.pds_left &lt;&lt; <span class="string">"pounds"</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(st.status == PDS)</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; st.pounds &lt;&lt; <span class="string">" pounds"</span>;     </div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Incorrect status"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>其中条件判断中那句<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(st.status == PDS)</div></pre></td></tr></table></figure></p>
<p>编译器表示找不到变量<code>PDS</code>的定义，于是我才意识到<br><div class="alert alert-warning"><i class="fa fa-bell"></i>  毕竟你友元函数不是成员函数，毕竟你的定义也没有使用类似<code>Time::</code>一类的限定符，你只是个朋友而已啦，不能随便用人家的东西，虽然你是朋友，而且原型写在人家那里。所以你的优惠就是可以通过你的朋友知道人家的隐私，比如使用朋友的成员运算符看人家隐私啦，能给你看就不错咯～还算当你是friend。</div><br>所以上面代码将<code>PDS</code>改成<code>Stonewt::PDS</code>就可以了。<br>还是朋友，还是要客气点。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于错误passing '...' as 'this' argument of '...' discard qualifiers]]></title>
      <url>http://pytlab.github.io/2016/02/25/%E5%85%B3%E4%BA%8E%E9%94%99%E8%AF%AFpassing-as-this-argument-of-discard-qualifiers/</url>
      <content type="html"><![CDATA[<p>今天又碰到了个新问题，先上代码：<br>vect.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="comment">// private methods</span></div><div class="line">    <span class="comment">// calculates magnitude from x and y</span></div><div class="line">    <span class="keyword">double</span> Vector::get_mag(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(a * a + b * b);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">double</span> Vector::get_ang(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (a == <span class="number">0.0</span> &amp;&amp; b == <span class="number">0.0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> <span class="built_in">atan2</span>(b, a);</div><div class="line">    &#125;</div><div class="line">...</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>vect.h<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// vect.h -- Vector class with &lt;&lt;, mode state</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> VECTOR_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> VECTOR_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">namespace</span> VECTOR</div><div class="line">&#123;</div><div class="line">    <span class="keyword">class</span> Vector</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">enum</span> Mode &#123;RECT, POL&#125;;</div><div class="line">    <span class="comment">// RECT for rectangular, POL for Polar modes</span></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="keyword">double</span> x;          <span class="comment">// horizontal value</span></div><div class="line">        <span class="keyword">double</span> y;          <span class="comment">// vertical value</span></div><div class="line">        Mode mode;         <span class="comment">// RECT or POL</span></div><div class="line">    <span class="comment">// private methods for setting values</span></div><div class="line">        <span class="function"><span class="keyword">double</span> <span class="title">get_mag</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">double</span> <span class="title">get_ang</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">double</span> <span class="title">get_x</span><span class="params">(<span class="keyword">double</span> mag, <span class="keyword">double</span> ang)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">double</span> <span class="title">get_y</span><span class="params">(<span class="keyword">double</span> mag, <span class="keyword">double</span> ang)</span></span>;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        Vector();</div><div class="line">        Vector(<span class="keyword">double</span> n1, <span class="keyword">double</span> n2, Mode form = RECT);</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">double</span> n1, <span class="keyword">double</span> n2, Mode form = RECT)</span></span>;</div><div class="line">        ~Vector();</div><div class="line">        <span class="function"><span class="keyword">double</span> <span class="title">xval</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;       <span class="comment">// report x value</span></div><div class="line">        <span class="function"><span class="keyword">double</span> <span class="title">yval</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> y;&#125;       <span class="comment">// report y value</span></div><div class="line">        <span class="function"><span class="keyword">double</span> <span class="title">magval</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> get_mag(x, y);&#125;   <span class="comment">// report magnitude</span></div><div class="line">        <span class="function"><span class="keyword">double</span> <span class="title">angval</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> get_ang(x, y);&#125;   <span class="comment">// report angle</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">polar_mode</span><span class="params">()</span></span>;                    <span class="comment">// set mode to POL</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">rect_mode</span><span class="params">()</span></span>;                     <span class="comment">// set mode to RECT</span></div><div class="line">    <span class="comment">// operator overloading</span></div><div class="line">        Vector <span class="keyword">operator</span>+(<span class="keyword">const</span> Vector &amp; b) <span class="keyword">const</span>;</div><div class="line">        Vector <span class="keyword">operator</span>-(<span class="keyword">const</span> Vector &amp; b) <span class="keyword">const</span>;</div><div class="line">        Vector <span class="keyword">operator</span>-() <span class="keyword">const</span>;</div><div class="line">        Vector <span class="keyword">operator</span>*(<span class="keyword">double</span> n) <span class="keyword">const</span>;</div><div class="line">    <span class="comment">// friends</span></div><div class="line">        <span class="keyword">friend</span> Vector <span class="keyword">operator</span>*(<span class="keyword">double</span> n, <span class="keyword">const</span> Vector &amp; a);</div><div class="line">        <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp; os, <span class="keyword">const</span> Vector &amp; v);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125;   <span class="comment">// end namespace VECTOR</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<hr>
<p>在与另外一个驱动程序一起编译的时候编译器总是报错：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">error: passing 'const VECTOR::Vector' as 'this' argument of 'double VECTOR::Vector::get_mag(double, double)' discards qualifiers [-fpermissive]</div></pre></td></tr></table></figure></p>
<p>弄得我真是头大，这error是哪里的问题？<br>可怜的我还是跑去爆栈上去找答案了，结果一搜就有，<br>传送：<a href="http://stackoverflow.com/questions/23553859/c-error-passing-const-as-this-argument" target="_blank" rel="external"><span class="fa fa-stack-overflow"></span> templates - C++ error: passing const as ‘this’ argument - Stack Overflow</a><br><div class="alert alert-warning"><i class="fa fa-bell"></i>  原来是因为被声明成`const`的成员函数，只能在其中调用其他的`const`成员函数，不能是没有`const`关键字的成员函数！</div></p>
<p>我把函数都加上了<code>const</code>关键字，终于，C++的编译器终于不傲娇了！</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于C++类构造函数的重载]]></title>
      <url>http://pytlab.github.io/2016/02/25/%E5%85%B3%E4%BA%8E%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD/</url>
      <content type="html"><![CDATA[<p>昨晚写《C++ Primer Plus》第十章第六题的时候遇到了一个熟悉又陌生的error<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">call of overloaded Move::Move() is ambiguous</div></pre></td></tr></table></figure></p>
<p>这个词应该是编译器发现在重载的时候程序中有<strong>二义性</strong>，我仔细看了下我写的程序，发现我在含有参数的构造函数的原型中添加了默认参数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Move::Move(<span class="keyword">double</span> a = <span class="number">0</span>, <span class="keyword">double</span> b = <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">    x = a;</div><div class="line">    y = b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Move::Move()</div><div class="line">&#123;</div><div class="line">    x = <span class="number">0.0</span>;</div><div class="line">    y = <span class="number">0.0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当调用<code>Move::Move()</code>的时候编译器会匹配最匹配的函数，因为默认参数的存在，使得函数原型<code>Move::Move(double a = 0, double b = 0)</code>和<code>Move::Move()</code>都可以匹配，因此编译器就报错了，因为有了二义性。<br><a id="more"></a><br>另外这个例子里面也可以知道，<br><div class="alert alert-info"><i class="fa fa-info"></i>  在类的成员函数中也可以调用其他的成员函数和使用构造函数创建本类的实例的。</div><br>该题目的代码传送门：<a href="https://github.com/PytLab/Cpp-Primer-Plus/tree/master/ch10/10_6" target="_blank" rel="external"><span class="fa fa-github"></span> Cpp-Primer-Plus/ch10/10_6 at master · PytLab/Cpp-Primer-Plus</a></p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kynetix支持KMC连续计算]]></title>
      <url>http://pytlab.github.io/2016/02/23/Kynetix%E6%94%AF%E6%8C%81KMC%E8%BF%9E%E7%BB%AD%E8%AE%A1%E7%AE%97/</url>
      <content type="html"><![CDATA[<p>关于连续计算这里其实是很早以前就加进来的功能，但是由于这里也算是一个比较重要而且比较复杂的更新，在这里记一下以免自己忘记。</p>
<p>这部分比较难处理的是关于连续作业的起始时间<code>start_time</code>和起始步数<code>start_step</code>的设定。然后再<code>KMCAnalysisPlugin</code>类（或者子类）中将新的KMC循环的time和step进行相应的<strong>“平移处理”</strong>。<br>这里我写了个装饰器来处理，对<code>KMCAnalysisPlugin</code>的<code>setup()</code>方法进行装饰，使其能够在进行on-the-fly分析的时候能够先把time和step处理完毕。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">reset_step_and_time</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    Decorator function to decorate analysis plugin methods.</div><div class="line">    '''</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped_func</span><span class="params">(self, step, time, configuration)</span>:</span></div><div class="line">        step = step + self.step_base</div><div class="line">        time = time + self.time_base</div><div class="line">        func(self, step, time, configuration)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> wrapped_func</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">KynetixPlugin</span><span class="params">(KMCAnalysisPlugin)</span>:</span></div><div class="line">    ...</div><div class="line"></div><div class="line"><span class="meta">    @reset_step_and_time</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span><span class="params">(self, step, time, configuration)</span>:</span></div><div class="line">        ...</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>关于如何获取起始的time和step，我是在<code>model.py</code>的<code>load()</code>函数来从文件中读取的，也就是说连续计算需要三个文件（均为程序自动生成，有<code>auto_</code>前缀）:</p>
<ul>
<li><code>auto_coverages.py</code>, 存储上次作业的体系时间列表和KMC步数列表，若只是进行TOFAnalysis，则不需要此文件</li>
<li><code>auto_TOFs.py</code>, 存储上次作业的KMC步数和相应的TOF</li>
<li><code>auto_last_types.py</code>, 上次作业的最后一次表面的configuration</li>
</ul>
<p>model.py中的读取部分代码不贴了，传送门：<a href="https://github.com/PytLab/Kynetix/blob/master/pynetics/model.py" target="_blank" rel="external"><span class="fa fa-github"></span> Kynetix/model.py at master · PytLab/Kynetix</a></p>
<hr>
<p>这里有两个变量容易混淆：<code>start_time</code>和<code>tof_start_time</code>，其中</p>
<ul>
<li><code>start_time</code>就是上次作业停止时候体系的时间（体系到模拟结束时候体系真实推进的时间）</li>
<li><code>tof_start_time</code>就是<strong>第一次</strong>作业进行TOF统计的<strong>时刻</strong>，需要这个变量是为了在后续作业统计TOF的时候是使用的同一个起点，不然这连续作业对于统计TOF也没有任何意义了。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> Kynetix </tag>
            
            <tag> catalysis </tag>
            
            <tag> 学术 </tag>
            
            <tag> kMC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kynetix可以直接使用相对能量进行微观动力学求解]]></title>
      <url>http://pytlab.github.io/2016/02/22/Kynetix%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%AF%B9%E8%83%BD%E9%87%8F%E8%BF%9B%E8%A1%8C%E5%BE%AE%E8%A7%82%E5%8A%A8%E5%8A%9B%E5%AD%A6%E6%B1%82%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>这算是Kynetix能量读取部分的第三次比较大的更新了，之前有提到过，模型已经兼容相对能量的输入文件（<a href="/2015/06/14/动力学模型已兼容相对能量的输入文件/"><span class="fa fa-file"></span> 详情</a>）。<br>虽然读取的是相对能量，但是程序内部我还是使用矩阵进行了线性方程组的求解来将求出每个物种相对于参考态的能量来作为generalized formation energy。<br>可是这就遇到了一个问题，<br><div class="alert alert-danger"><i class="fa fa-bug"></i>  有很多情况，程序根据用户自定义的参考态物种获取的参数矩阵很多情况是奇异矩阵，一旦矩阵奇异，就无法求出解，也就无法将模型的求解进行下去。</div><br>这个问题一直困扰我很久了，但是我一直没有花时间去解决。<br>现在想想其实我通过矩阵获取generalized formation energy的目的是什么？<br>其实作用也不过是在进行初始猜测的时候按照formation energy来进行Boltzmann分布而已。为了这个而无法将整个求解过程继续下去真的是得不偿失啊。<br><a id="more"></a><br>于是我就将parser进行了修改，是整个模型能够直接读取相对能量来进行计算，当然如果想进行formation energy的求解也是可以的。<br>具体的修改细节请参考这个<code>commit:</code> <a href="https://github.com/PytLab/Kynetix/commit/4ab1de88a53be75acf352df06da5fd3faac4b554" target="_blank" rel="external"><span class="fa fa-github"></span> could use relative energy to solve model · PytLab/Kynetix@4ab1de8</a></p>
<p>运行脚本也进行了相应的修改：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">relative = <span class="keyword">True</span> <span class="keyword">if</span> <span class="string">'--relative'</span> <span class="keyword">in</span> sys.argv <span class="keyword">else</span> <span class="keyword">False</span></div><div class="line">solve_ode = <span class="keyword">True</span> <span class="keyword">if</span> <span class="string">'--ode'</span> <span class="keyword">in</span> sys.argv <span class="keyword">else</span> <span class="keyword">False</span></div><div class="line">m.run_mkm(init_cvgs=init_cvgs, relative=relative,</div><div class="line">          correct_energy=correct_energy, solve_ode=solve_ode)</div></pre></td></tr></table></figure></p>
<p><code>solver</code>的<code>run_mkm()</code>函数通过<code>relative</code>参数，<code>run_relative.py</code>脚本通过<code>--relative</code>来控制是否使用相对能量进行计算。</p>
]]></content>
      
        <categories>
            
            <category> 学术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> Kynetix </tag>
            
            <tag> catalysis </tag>
            
            <tag> chemistry </tag>
            
            <tag> 学术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解决hexo中tag和category中文章由于分页显示不全的方法]]></title>
      <url>http://pytlab.github.io/2016/02/21/%E8%A7%A3%E5%86%B3hexo%E4%B8%ADtag%E5%92%8Ccategory%E4%B8%AD%E6%96%87%E7%AB%A0%E7%94%B1%E4%BA%8E%E5%88%86%E9%A1%B5%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%85%A8%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>今天忽然发现博客的标签(tag)以及目录(category)涉及到分页的话会显示不全，我发现之所以显示不全是和hexo中的<code>_config.yml</code>文件中的<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">per_page:</span> <span class="number">6</span></div></pre></td></tr></table></figure></p>
<p>参数有关，<code>per_page</code>设成多少就只显示多少个post。</p>
<a id="more"></a>
<p>于是我看到在全局配置文件中还有几个参数我这边没有设：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="attr">index_generator:</span></div><div class="line"><span class="attr">  per_page:</span> <span class="number">10</span> <span class="comment">##首頁默認10篇文章標題 如果值爲0不分頁</span></div><div class="line"></div><div class="line"><span class="attr">archive_generator:</span></div><div class="line"><span class="attr">  per_page:</span> <span class="number">10</span> <span class="comment">##歸檔頁面默認10篇文章標題</span></div><div class="line"><span class="attr">  yearly:</span> <span class="literal">true</span>  <span class="comment">##生成年視圖</span></div><div class="line"><span class="attr">  monthly:</span> <span class="literal">true</span> <span class="comment">##生成月視圖</span></div><div class="line"></div><div class="line"><span class="attr">tag_generator:</span></div><div class="line"><span class="attr">  per_page:</span> <span class="number">10</span> <span class="comment">##標籤分類頁面默認10篇文章</span></div><div class="line"></div><div class="line"><span class="attr">category_generator:</span></div><div class="line"><span class="attr">   per_page:</span> <span class="number">10</span> <span class="comment">###分類頁面默認10篇文章</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="attr">feed:</span></div><div class="line"><span class="attr">  type:</span> <span class="string">atom</span> <span class="comment">##feed類型 atom或者rss2</span></div><div class="line"><span class="attr">  path:</span> <span class="string">atom.xml</span> <span class="comment">##feed路徑</span></div><div class="line"><span class="attr">  limit:</span> <span class="number">20</span>  <span class="comment">##feed文章最小數量</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="attr">deploy:</span></div><div class="line"><span class="attr">  type:</span> <span class="string">git</span> <span class="comment">##部署類型 其他類型自行google之</span></div><div class="line"><span class="attr">  repo:</span> <span class="string">&lt;repository</span> <span class="string">url&gt;</span> <span class="comment">##git倉庫地址</span></div><div class="line"><span class="attr">  branch:</span> <span class="string">[branch]</span> <span class="comment">##git 頁面分支</span></div><div class="line"><span class="attr">  message:</span> <span class="string">[message]</span> <span class="comment">##git message建議默認字段update 可以自定義</span></div></pre></td></tr></table></figure></p>
<p>我就尝试把<code>tag_generator</code>和<code>category_generator</code>中的<code>per_page</code>设成了0：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">tag_generator:</span></div><div class="line"><span class="symbol">    per_page:</span> <span class="number">0</span></div><div class="line"><span class="symbol"></span></div><div class="line">category_generator:</div><div class="line"><span class="symbol">    per_page:</span> <span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>重新部署网站之后，OK! 问题解决！</p>
]]></content>
      
        <categories>
            
            <category> 教程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用C语言编写extension为Kynetix大幅提速]]></title>
      <url>http://pytlab.github.io/2016/02/19/%E4%BD%BF%E7%94%A8C%E6%89%A9%E5%B1%95%E4%B8%BAKynetix%E6%8F%90%E9%80%9F/</url>
      <content type="html"><![CDATA[<p>之前Kynetix代码几乎全部是使用Python写的，使用了KMCLib(Python + C++)之后，在进行主体KMC循环的时候效率得到了明显的提升，但是在刚刚完成on-the-fly分析部分代码以后开始跑程序，明显感觉程序异常的慢，因为kmc写到现在真心感受到kMC程序真心是个compute intense的活，其中没有用到矩阵运算，没有用到什么传统的优化算法，<br><div class="alert alert-danger"><i class="fa fa-bug"></i>  所以尝试只用一种解释性语言如matlab和python去完成整个kMC程序的最终肯定会使程序慢得一塌糊涂！跑蒙特卡洛程序慢成狗，那这程序也几乎没啥用了感觉。</div><br>于是我也想学习KMCLib那样使用静态语言为我的python程序编写扩展模块，虽然我也知道针对Fortran有<a href="https://sysbio.ioc.ee/projects/f2py2e/" target="_blank" rel="external"><strong>f2py</strong></a>这种工具存在，但是由于我个人的喜好，不是历史原因必须使用fortran的话，我还是选择C或者C++。<br>至于python的C扩展，我选择使用<a href="http://www.swig.org/" target="_blank" rel="external"><strong>SWIG</strong></a>。<br><a id="more"></a></p>
<h3 id="需要使用C重写的几个核心统计函数"><a href="#需要使用C重写的几个核心统计函数" class="headerlink" title="需要使用C重写的几个核心统计函数"></a>需要使用C重写的几个核心统计函数</h3><p>在<code>kmc_functions.py</code>中有三个函数用于在KMC主循环运行当中对表面的configuration进行on-the-fly统计:</p>
<ul>
<li><code>collect_coverge()</code>, 扫描整个网格，统计每个可能的中间物种的覆盖度。</li>
<li><code>match_elements()</code>, 扫描整个网格，针对某一特定的局部configuration进行匹配并统计，其目的就是为了统计在当前网格中有多少局部的构型能够发生某一特定的反应。</li>
<li><code>match_elements_list()</code>, 针对一系列的局部构型列表，循环调用<code>match_elements()</code>，统计能够匹配列表中所有构型的总数。</li>
</ul>
<p>这里由于针对NxN的网格，匹配单独一个local configuration的复杂度在$\mathcal{O}(N^{2})$， 匹配一列表的复杂度同扫面一次网格遍历所有构型的复杂度是相同的, 都是$\mathcal{O}(MN^{2})$</p>
<h3 id="编写C扩展"><a href="#编写C扩展" class="headerlink" title="编写C扩展"></a>编写C扩展</h3><p>单纯使用C语言写功能相同的函数还是比较简单的，最麻烦的是将其封装成python的接口，并实现C语言的数据类型同python内置的数据类型以及numpy的数组等数据类型之间进行转换，使得C语言编写的函数能够让python调用（下一部分进行简单介绍）。<br>C扩展的源代码在<code>pynetics/extension/src/kmc_function.c</code>中，我针对<code>kmc_functions.py</code>中的函数编写了相应的C语言版本，参数类型有所区别，主要是针对矩阵和C数组形状的参数传递，此问题在编写swig接口文件中进行了统一解决。<br>代码就不贴上来了，有兴趣的可以直接到项目的GitHub主页去看，传送 $\rightarrow$ <a href="https://github.com/PytLab/Kynetix/blob/master/extensions/src/kmc_functions.c" target="_blank" rel="external">kmc_functions.c</a></p>
<h3 id="SWIG接口文件"><a href="#SWIG接口文件" class="headerlink" title="SWIG接口文件"></a>SWIG接口文件</h3><p>这一部分是写C扩展让我最费劲的地方，因为涉及到数据类型的转换(自定义的类型映射customized typemap)，例如python的<code>string</code> <code>list</code>和C语言的<code>char *</code> 数组(或者<code>char **</code>)的转换等。为了这个看了不少stackoverflow和SWIG的文档，最后还是在官方文档里面找到了解决办法。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* tell SWIG to treat char ** as a list of strings */</span></div><div class="line">%typemap(in) <span class="keyword">char</span> ** &#123;</div><div class="line">    <span class="comment">// check if is a list</span></div><div class="line">    <span class="keyword">if</span>(PyList_Check($input))</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> size = PyList_Size($input);</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        $<span class="number">1</span> = (<span class="keyword">char</span> **)<span class="built_in">malloc</span>((size + <span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span> *));</div><div class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size; ++i)</div><div class="line">        &#123;</div><div class="line">            PyObject * o = PyList_GetItem($input, i);</div><div class="line">            <span class="keyword">if</span>(PyString_Check(o))</div><div class="line">                $<span class="number">1</span>[i] = PyString_AsString(o);</div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                PyErr_SetString(PyExc_TypeError, <span class="string">"list must contain strings"</span>);</div><div class="line">                <span class="built_in">free</span>($<span class="number">1</span>);</div><div class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        PyErr_SetString(PyExc_TypeError, <span class="string">"not a list"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>大致原理就是根据输入的类型判断是否是python的<code>list</code>类型，并动态分配内存，生成相应的<code>char **</code>数组，这样完成了<code>list</code> -&gt; <code>char **</code>的映射。</p>
<p>我在<code>pynetics/extensions/wrap/</code>中包含了<code>numpy.i</code>，此文件是numpy的swig接口文件，主要是利用里面关于numpy array的类型映射，来映射numpy的N维数组到C语言的N维数组：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">match_elements</span><span class="params">(<span class="keyword">char</span> ** types, <span class="keyword">char</span> ** elements,</span></span></div><div class="line">                   <span class="keyword">int</span> DIM1, <span class="keyword">int</span> DIM2, <span class="keyword">double</span> * IN_ARRAY2,</div><div class="line">                   <span class="keyword">const</span> <span class="keyword">int</span> grid_shape[<span class="number">2</span>]);</div></pre></td></tr></table></figure></p>
<p>另外关于python中的<code>string</code>二维<code>list</code>，至今我是没找到如何映射到C语言相应的数组，囧（如果看到这篇博文的大神知道映射方法，请务必告诉我，小的感激不尽。<br>于是我想到了另外一种方法：<br>就是在python代码中将二维<code>string</code>数组转换成相应的一维数组将其降维，类似numpy中的<code>reshape</code>函数的功能，然后再用上文得到的<code>string</code>一维数组的方法将其映射。</p>
<p>另外我还编写了一份Makefile来编译并使用SWIG封装扩展，内容如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">CC = gcc</div><div class="line">SWIG = swig</div><div class="line">SWIGFLAGS = -python </div><div class="line">CCFLAGS = -O3 -fPIC -c </div><div class="line">OMPFLAG = # -fopenmp</div><div class="line">INC = # -I /usr/local/lib/python2.7/site-packages/numpy/core/include </div><div class="line">LDFLAGS = -shared</div><div class="line">EXTNAME = kmc_functions</div><div class="line">EXTDIR = ../pynetics/solvers/plugin_backends</div><div class="line"></div><div class="line">_kmc_functions.so: build/kmc_functions.o build/kmc_functions_wrap.o</div><div class="line">	<span class="variable">$(CC)</span> <span class="variable">$(OMPFLAG)</span> <span class="variable">$(LDFLAGS)</span> $^ -o $@</div><div class="line"></div><div class="line">build/kmc_functions.o: src/kmc_functions.c</div><div class="line">	<span class="variable">$(CC)</span> <span class="variable">$(OMPFLAG)</span> <span class="variable">$(CCFLAGS)</span> <span class="variable">$(INC)</span> -I include $&lt; -o $@</div><div class="line"></div><div class="line">build/kmc_functions_wrap.o: wrap/kmc_functions_wrap.c</div><div class="line">	<span class="variable">$(CC)</span> <span class="variable">$(OMPFLAG)</span> <span class="variable">$(CCFLAGS)</span> <span class="variable">$(INC)</span> -I include $&lt; -o $@</div><div class="line"></div><div class="line">wrap/kmc_functions_wrap.c: wrap/kmc_functions.i</div><div class="line">	<span class="variable">$(SWIG)</span> <span class="variable">$(SWIGFLAGS)</span> $^</div><div class="line">	mv wrap/*py ./</div><div class="line"></div><div class="line"><span class="section">install:</span></div><div class="line">	cp _<span class="variable">$(EXTNAME)</span>.so <span class="variable">$(EXTNAME)</span>.py <span class="variable">$(EXTDIR)</span></div><div class="line"></div><div class="line"><span class="section">clean:</span></div><div class="line">	rm -rf build/* wrap/<span class="variable">$(EXTNAME)</span>_wrap.c <span class="variable">$(EXTNAME)</span>.py *.so</div><div class="line"></div><div class="line"><span class="section">uninstall:</span></div><div class="line">	rm -f <span class="variable">$(EXTDIR)</span>/<span class="variable">$(EXTNAME)</span>.py <span class="variable">$(EXTDIR)</span>/_<span class="variable">$(EXTNAME)</span>.so</div></pre></td></tr></table></figure></p>
<hr>
<p>通过调用封装好的C扩展模块进行相同的计算，我在我的CentOS虚拟机中相同的环境下跑相同的输入参数，比纯python快了<strong>20倍！</strong></p>
<p>如果算上使用KMCLib的C++提速，保守估计，比纯解释性语言写的KMC程序要快<strong>50~60倍！</strong></p>
]]></content>
      
        <categories>
            
            <category> 学术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> Kynetix </tag>
            
            <tag> chemistry </tag>
            
            <tag> C </tag>
            
            <tag> 学术 </tag>
            
            <tag> swig </tag>
            
            <tag> calalysis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kynetix的kmc_plotter]]></title>
      <url>http://pytlab.github.io/2016/02/18/Kynetix%E7%9A%84kMC-plotter/</url>
      <content type="html"><![CDATA[<p>为了显示kMC模拟的表面动态演化过程,给Kynetix的plotters中新增了</p>
<ul>
<li><code>kmc_plotter.py</code>, 其中的KMCPlotter是ModelShell的子类，实例化model对象的绘制工具。</li>
<li><code>grid_plot.py</code>， 提供绘制网格和圆圈的函数（适合小型网格，例如10x10、5x5）</li>
<li><code>scatter_plot.py</code>， 提供使用绘制散点图的方式绘制网格（适合大型的网格，例如200x200）</li>
<li><code>images2gif.py</code>， 负责将多个图片合并成动态gif的模块。</li>
</ul>
<a id="more"></a>
<hr>
<p><code>kmc_plotter.py</code>中的<code>KMCPlotter</code>类中的<code>plot_traj</code>方法，是通过读取Kynetix运行自动生成的<code>auto_trajectory.py</code>文件的数据并使用网格或者散点的方式生成一系列的静态图片，也就是相应的轨迹图。</p>
<hr>
<p>关于<code>images2gif.py</code>这个模块，是直接使用的现成的别人写好的模块(<a href="https://pypi.python.org/pypi/images2gif" target="_blank" rel="external">https://pypi.python.org/pypi/images2gif</a>),但是一开始用的时候不知道为什么总是在合并的时候报错，去stackoverflow上面求助才知道新版本本来就会有这个问题，某个人提供的某个版本是可以的，于是我也就将这个版本直接复制过来放到了Kynetix中，以便能够稳定的绘图。</p>
<p>贴上绘制的效果(240x240):<br><img src="assets/images/blog_img/2016-02-18-Kynetix的kMC-plotter/traj_movie.gif" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 学术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> Kynetix </tag>
            
            <tag> catalysis </tag>
            
            <tag> chemistry </tag>
            
            <tag> 学术 </tag>
            
            <tag> kMC </tag>
            
            <tag> Monte Carlo </tag>
            
            <tag> matplotlib </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kynetix新增动力学蒙特卡洛(kMC)计算模块]]></title>
      <url>http://pytlab.github.io/2016/02/18/Kynetix%E6%96%B0%E5%A2%9E%E5%8A%A8%E5%8A%9B%E5%AD%A6%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B-kMC-%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<p>目前<a href="https://github.com/PytLab/Kynetix" target="_blank" rel="external"><strong>Kynetix</strong></a>已经可以进行动力学蒙特卡洛(kMC)模拟，其中kMC核心计算部分我将<a href="https://github.com/leetmaa/KMCLib" target="_blank" rel="external"><strong>KMCLib</strong></a>整合到其中(若要使用Kynetix，请根据KMCLib的文档自行编译KMCLib)，这次更新的内容比较多，主要在以下几个地方进行了更新：</p>
<ul>
<li><code>kMC Parser</code>, 负责将输入文件中的能量以及化学方程式进行解析</li>
<li><code>kMC Solver</code>, 这里是kMC模拟的核心，主要负责调用KMCLib的接口进行动力学蒙特卡洛计算，并对模拟进行On-the-fly分析（覆盖度，TOF等）</li>
<li><code>kMC Plotter</code>, 绘制表面形态的演化过程（可生成多图以及GIF动图）<a id="more"></a>
</li>
</ul>
<hr>
<p>下面简单介绍下kMC Solver。<br><code>pynetics/solvers/kmc_solver.py</code>中包含两个类：</p>
<ol>
<li><code>KMCSolver</code>, 提供了根据提供的基元反应方程式和能量数据，使用过渡态理论以及碰撞理论等计算基元反应的反应速率等信息的接口。</li>
<li><code>KMCLibSolver</code>, <code>KMCSolver</code>的子类，主要是使用KMCLib的接口生成相应KMCLib的对象和使用KMCLib进行计算。</li>
</ol>
<hr>
<p><code>pynetics/solvers/kmc_plugins.py</code>中包含4个类：</p>
<ol>
<li><code>KynetixPlugin</code>, 是其他分析类的基类</li>
<li><code>CoveragesAnalysis</code>, <code>KynetixPlugin</code>的子类，用于在蒙特卡洛循环中进行表面覆盖度的统计，可以进行<strong>继续计算</strong>.</li>
<li><code>TOFAnalysis</code>, <code>KynetixPlugin</code>的子类，用于在蒙特卡洛循环中进行TOF统计计算, 可以进行<strong>继续计算</strong>。</li>
<li><code>TOFCoveragesAnalysis</code>, <code>KynetixPlugin</code>的子类，同时进行覆盖度和TOF的统计，不支持<strong>继续计算</strong> </li>
</ol>
<hr>
<p><code>pynetics/solvers/kmc_functions.py</code>中包含分析的主要函数，独立出的原因是避免因为用户没有对该模块的C扩展进行编译而导致程序无法执行。</p>
]]></content>
      
        <categories>
            
            <category> 学术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> kinetic model </tag>
            
            <tag> kinetics </tag>
            
            <tag> Kynetix </tag>
            
            <tag> catalysis </tag>
            
            <tag> 学术 </tag>
            
            <tag> kMC </tag>
            
            <tag> Monte Carlo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[动力学蒙特卡洛(kinetic Mont Carlo)基本原理小结]]></title>
      <url>http://pytlab.github.io/2016/02/18/%E5%8A%A8%E5%8A%9B%E5%AD%A6%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B-kinetic-Mont-Carlo%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<h4 id="克服模拟的时间尺度的局限"><a href="#克服模拟的时间尺度的局限" class="headerlink" title="克服模拟的时间尺度的局限"></a>克服模拟的时间尺度的局限</h4><p>由于许多动态的过程(dynamic evolution)，例如表面的生长或者材料的老化，时间的跨度都在s以上，超出了分子动力学模拟的范围，动力学蒙特卡洛模拟便是针对这种长时间尺度的动态模拟的。</p>
<blockquote>
<p>Kinetic Monte Carlo attempts to overcome this limitation by exploiting the fact that the long-time dynamics of this kind of system typically consists of diffusive jumps from state to state. Rather than following the trajectory through every vibrational period, these state-to-state transitions are treated directly</p>
</blockquote>
<p><img src="/assets/images/blog_img/2016-02-18-动力学蒙特卡洛-kinetic-Mont-Carlo基本原理小结/PES.png" alt=""><br><a id="more"></a><br>kMC从某种程度上就是对MD的一种粗化，将关注点从<strong>原子</strong>粗化到<strong>体系</strong>，将<strong>原子轨迹</strong>粗化到<strong>体系组态的跃迁</strong>，那么模拟的时间跨度就将从原子振动的尺度提高到组态跃迁的尺度，这是因为这种处理方法摈弃了与体系穿越势垒无关的微小振动，而只着眼于体系的组态变化。因此，虽然不能描绘原子的运动轨迹，但是作为<strong>体系演化</strong>，其“组态轨迹”仍然是<strong>正确</strong>的。<br>此外，因为组态变化的时间间隔很长，体系完成的连续两次演化是独立的，无记忆的，所以这个过程是一种典型的<strong>马尔可夫过程(Markov process)</strong>，及从组态 $i$ 跃迁到组态 $j$ ，这一过程只与跃迁速率 $k_{ij}$ 有关。</p>
<div class="alert alert-info"><i class="fa fa-info"></i>  这里的跃迁速率可以理解为跃迁频率，或者说单位时间内发生组态跃迁的次数，能够衡量过程发生的难以程度。放在化学反应上就是反应速率常数 $k$ (跃迁次数/s)，有些文献上是用反应速率 $R$ 表示的。</div>
<blockquote>
<p>for each possible escape pathway to an adjacent basin, there is a <em>rate constant</em> $k_{ij}$ that characterizes the probability, per unit time, that it escapes to that state $j$</p>
</blockquote>
<p>如果精确地知道 $k_{ij}$，我们便可以构造一个随机过程，使得体系按照正确的轨迹演化。这里<strong>正确</strong>的意思是某条给定演化轨迹出现的几率与MD模拟结果完全一致(假设我们进行了大量的MD模拟，每次模拟中每个原子的初始动量随机给定)。这种通过构造随机过程研究体系演化的方法即为<strong>动力学蒙特卡洛方法(kinetic Monte Carlo, KMC)</strong></p>
<hr>
<h4 id="kMC的时间步长"><a href="#kMC的时间步长" class="headerlink" title="kMC的时间步长"></a>kMC的时间步长</h4><p>这里算是kMC中比较重要的一点。<br>$k_{ij}$ 代表体系从组态 $i$ 逃逸到 $j$ 的速率，则发生跃迁的概率为 $k_{tot} = \sum_{j}^{}{k_{ij}}$<br>Gillespie给出的假设：</p>
<blockquote>
<p>Suppose that the system is in configuration $c$. The probability that a particular enabled reaction $c \rightarrow c^{‘}$ occurs in an infinitesimal period $\delta t$ is given by $k_{c \rightarrow c^{‘}}*\delta t$.</p>
</blockquote>
<p>则体系处在某一状态且经过$\delta t$之后体系状态未改变的概率为<br>$$P(T&gt;= t + \delta t) = P(T&gt;= t)(1 - k_{tot}\delta t)$$<br>将等式写成：<br>$$\frac{P(T&gt;= t + \delta t) - P(T&gt;= t)}{\delta t} = -k_{tot}P(T&gt;= t)$$<br>积分后得到<strong>体系不发生跃迁的概率</strong><br>$$P(T&gt;= t) = exp(-k_{tot}t)$$<br>即，<br>$$p_{survive} = exp(-k_{tot}t)$$<br>则在时间t内体系发生跃迁的概率为<br>$$p_{transition} = 1 - p_{survive} = 1 - exp(-k_{tot}t)$$</p>
<div class="alert alert-warning"><i class="fa fa-bell"></i>  对时间$t$求导可得到体系发生跃迁的概率分布函数：
$$p(t) = k_{tot} exp(-k_{tot}t)$$</div>
<p>可以看到逃逸概率呈指数分布，求其期望值便可得到逃逸所需的平均时间 $\tau$<br>$$\tau = \int_{0}^{\infty} tp(t)=\frac{1}{k_{tot}}$$</p>
<p>以上就是kMC中关于时间步长的推导了，也是kMC模拟程序中按照指数分布抽取随机数的原理。<br><div class="alert alert-warning"><i class="fa fa-bell"></i>  $$t\_{draw} = -\frac{ln(\rho)}{k}$$</div></p>
<hr>
<h4 id="步长的另一种推导方法"><a href="#步长的另一种推导方法" class="headerlink" title="步长的另一种推导方法"></a>步长的另一种推导方法</h4><p>今天在kmos的那篇文章中有看到了使用Poission分布来推导体系时间推进公式的方法。<br>一般在不相关的两次事件的时间间隔是服从Possion分布的，也就意味着针对一个时间的发生速率$k$，则在时间间隔$\Delta t$内事件发生$n$次的概率为$p_{n}(k, \Delta t)$<br>$$p_{n}(k, \Delta t) = (k\Delta t)^{n}e^{-k\Delta t}/n!$$<br>则两次事件的间隔时间就为没有事件发生的间隔（也就是上文的$p_{survive}$）, 就是$n=0$时的$\Delta t$<br>$$p_{0}(k, \Delta t) = e^{-k\Delta t}$$<br>按照上文的方法可以得到kMC模拟中的时间步长<br>$$\Delta t = \frac{-ln(r)}{k}$$</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Kynetix </tag>
            
            <tag> catalysis </tag>
            
            <tag> chemistry </tag>
            
            <tag> 学术 </tag>
            
            <tag> kMC </tag>
            
            <tag> Monte Carlo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[动力学模拟程序更名为Kynetix]]></title>
      <url>http://pytlab.github.io/2016/02/18/%E5%8A%A8%E5%8A%9B%E5%AD%A6%E6%A8%A1%E6%8B%9F%E7%A8%8B%E5%BA%8F%E6%9B%B4%E5%90%8D%E4%B8%BAKynetix/</url>
      <content type="html"><![CDATA[<p>决定把催化动力学模拟程序名称更改为<strong>Kynetix</strong><br>项目GitHub地址: <a href="https://github.com/PytLab/Kynetix" target="_blank" rel="external">https://github.com/PytLab/Kynetix</a><br><img src="/assets/images/blog_img/2016-02-18-动力学模拟程序更名为Kynetix/kynetix.png" alt=""><br><img src="/assets/images/blog_img/2016-02-18-动力学模拟程序更名为Kynetix/kynetix_lang.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 代码作品 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> kinetic model </tag>
            
            <tag> kinetics </tag>
            
            <tag> Kynetix </tag>
            
            <tag> catalysis </tag>
            
            <tag> chemistry </tag>
            
            <tag> C </tag>
            
            <tag> 随笔 </tag>
            
            <tag> Cpp </tag>
            
            <tag> Monte Carlo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++各大有名科学计算库]]></title>
      <url>http://pytlab.github.io/2016/02/17/Cpp%E5%90%84%E5%A4%A7%E6%9C%89%E5%90%8D%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E5%BA%93-%E8%BD%AC/</url>
      <content type="html"><![CDATA[<p>在 C++中，库的地位是非常高的。C++之父 Bjarne Stroustrup先生多次表示了设计库来扩充功能要好过设计更多的语法的言论。现实中，C++的库门类繁多，解决的问题也是极其广泛，库从轻量级到重量级的都有。不少都是让人眼界大开，亦或是望而生叹的思维杰作。由于库的数量非常庞大，而且限于笔者水平，其中很多并不了解。所以文中所提的一些库都是比较著名的大型库。 </p>
<a id="more"></a>
<h3 id="C-各大有名科学计算库的介绍"><a href="#C-各大有名科学计算库的介绍" class="headerlink" title="C++各大有名科学计算库的介绍"></a>C++各大有名科学计算库的介绍</h3><hr>
<h4 id="Blitz-http-www-oonumerics-org-blitz"><a href="#Blitz-http-www-oonumerics-org-blitz" class="headerlink" title="Blitz++ (http://www.oonumerics.org/blitz)"></a>Blitz++ (<a href="http://www.oonumerics.org/blitz" target="_blank" rel="external">http://www.oonumerics.org/blitz</a>)</h4><div class="alert alert-info"><i class="fa fa-info"></i>  Blitz++ 是一个高效率的数值计算函数库，它的设计目的是希望建立一套既具像C++ 一样方便，同时又比Fortran速度更快的数值计算环境。通常，用C++所写出的数值程序，比 Fortran慢20%左右，因此Blitz++正是要改掉这个缺点。方法是利用C++的template技术，程序执行甚至可以比Fortran更快。
<br>
Blitz++目前仍在发展中，对于常见的SVD，FFTs，QMRES等常见的线性代数方法并不提供，不过使用者可以很容易地利用Blitz++所提供的函数来构建。</div>
<h4 id="POOMA-http-www-codesourcery-com-pooma-pooma"><a href="#POOMA-http-www-codesourcery-com-pooma-pooma" class="headerlink" title="POOMA (http://www.codesourcery.com/pooma/pooma)"></a>POOMA (<a href="http://www.codesourcery.com/pooma/pooma" target="_blank" rel="external">http://www.codesourcery.com/pooma/pooma</a>)</h4><div class="alert alert-info"><i class="fa fa-info"></i>  POOMA是一个免费的高性能的C++库，用于处理并行式科学计算。POOMA的面向对象设计方便了快速的程序开发，对并行机器进行了优化以达到最高的效率，方便在工业和研究环境中使用。</div>
<h4 id="MTL-http-www-osl-iu-edu-research-mtl"><a href="#MTL-http-www-osl-iu-edu-research-mtl" class="headerlink" title="MTL (http://www.osl.iu.edu/research/mtl)"></a>MTL (<a href="http://www.osl.iu.edu/research/mtl" target="_blank" rel="external">http://www.osl.iu.edu/research/mtl</a>)</h4><div class="alert alert-info"><i class="fa fa-info"></i>  Matrix Template Library(MTL)是一个高性能的泛型组件库，提供了各种格式矩阵的大量线性代数方面的功能。在某些应用使用高性能编译器的情况下，比如Intel的编译器，从产生的汇编代码可以看出其与手写几乎没有两样的效能。</div>
<h4 id="CGAL-http-www-cgal-org"><a href="#CGAL-http-www-cgal-org" class="headerlink" title="CGAL (http://www.cgal.org/)"></a>CGAL (<a href="http://www.cgal.org/" target="_blank" rel="external">http://www.cgal.org/</a>)</h4><div class="alert alert-info"><i class="fa fa-info"></i>  Computational Geometry Algorithms Library的目的是把在计算几何方面的大部分重要的解决方案和方法以C++库的形式提供给工业和学术界的用户。</div>
<h4 id="Intel-Math-Kernel-Library"><a href="#Intel-Math-Kernel-Library" class="headerlink" title="Intel Math Kernel Library"></a>Intel Math Kernel Library</h4><div class="alert alert-info"><i class="fa fa-info"></i>  <li>基本线形代数运算(BLAS) 向量与向量、向量与矩阵、矩阵与矩阵的运算</li>
<li>稀疏线形代数运算</li>
<li>快速傅立叶变换(单精度/双精度)(fftw)</li>
<li>LAPACK(求解线形方程组、最小方差、特征值、Sylvester方程等)</li>
<li>向量数学库(VML)</li>
<li>向量统计学库(VSL)</li>
<li>高级离散傅立叶变换</li></div>
<h4 id="IMSL-http-www-vni-com"><a href="#IMSL-http-www-vni-com" class="headerlink" title="IMSL (http://www.vni.com/ )"></a>IMSL (<a href="http://www.vni.com/" target="_blank" rel="external">http://www.vni.com/</a> )</h4><div class="alert alert-info"><i class="fa fa-info"></i>  软件名称 IMSL C Numerical Library(不兼容vc6编译器)
<br>
程序设计语言 C, Forton, C#, Java
<br>
功能概述 分为统计库和数学库两部分. 数学库包含应用数学和特殊函数.IMSL 程序库 - 已成为数值分析解决方案的工业标准。 IMSL 程序库提供最完整与最值得信赖的函数库。 IMSL 数值程序库提供目前世界上最广泛被使用的 IMSL 算法，有超过 370 验证过、最正确与 thread-safe 的数学与统计程序。 IMSL FORTRAN 程序库提供新一代以 FORTRAN 90 为程序库基础的程序，能展现出最佳化的演算法能力应用于多处理器与其它高效能运算系统。</div>
<h4 id="lapack-http-www-netlib-org-lapack"><a href="#lapack-http-www-netlib-org-lapack" class="headerlink" title="lapack (http://www.netlib.org/lapack )"></a>lapack (<a href="http://www.netlib.org/lapack" target="_blank" rel="external">http://www.netlib.org/lapack</a> )</h4><div class="alert alert-info"><i class="fa fa-info"></i>  软件名称 Linear Algebra Package 
<br>
程序设计语言 Fortran 77 
<br>
功能概述 线性代数计算子程序包</div>
<h4 id="lapack-http-math-nist-gov-lapack"><a href="#lapack-http-math-nist-gov-lapack" class="headerlink" title="lapack++ (http://math.nist.gov/lapack++/ )"></a>lapack++ (<a href="http://math.nist.gov/lapack++/" target="_blank" rel="external">http://math.nist.gov/lapack++/</a> )</h4><div class="alert alert-info"><i class="fa fa-info"></i>  软件名称 Linear Algebra Package in c++ 
<br>
程序设计语言 c++ 
<br>
功能概述 c++版的线性代数计算子程序包</div>
<h4 id="BLAS-http-www-netlib-org-blas"><a href="#BLAS-http-www-netlib-org-blas" class="headerlink" title="BLAS (http://www.netlib.org/blas )"></a>BLAS (<a href="http://www.netlib.org/blas" target="_blank" rel="external">http://www.netlib.org/blas</a> )</h4><div class="alert alert-info"><i class="fa fa-info"></i>  软件名称 Basic Linear Algebra Subroutines 
<br>
程序设计语言 Fortran 77 
<br>
主要开发者 Kagstrom B. ，Ling P. ，Van Loan C. 
<br>
功能概述 Blas是执行向量和矩阵运算的子程序集合。</div>
<h4 id="uBLAS"><a href="#uBLAS" class="headerlink" title="uBLAS"></a>uBLAS</h4><div class="alert alert-info"><i class="fa fa-info"></i>  BLAS in C++ with expression templates. 表达式模版形式的 C++中的BLAS ，</div>
<h4 id="gsl-http-www-gnu-org-software-gsl"><a href="#gsl-http-www-gnu-org-software-gsl" class="headerlink" title="gsl (http://www.gnu.org/software/gsl/)"></a>gsl (<a href="http://www.gnu.org/software/gsl/" target="_blank" rel="external">http://www.gnu.org/software/gsl/</a>)</h4><div class="alert alert-info"><i class="fa fa-info"></i>  软件名称 GNU Scientific Library (linux)
<br>
程序设计语言 C , C++ compable 
<br>
功能概述 范围广泛, 包括数值分析的常见内</div>
<h4 id="Blitz-http-sourceforge-net-project-showfiles-php-group-id-63961"><a href="#Blitz-http-sourceforge-net-project-showfiles-php-group-id-63961" class="headerlink" title="Blitz++ (http://sourceforge.net/project/showfiles.php?group_id=63961)"></a>Blitz++ (<a href="http://sourceforge.net/project/showfiles.php?group_id=63961" target="_blank" rel="external">http://sourceforge.net/project/showfiles.php?group_id=63961</a>)</h4><div class="alert alert-info"><i class="fa fa-info"></i>  软件名称　Blitz++ (不兼容vc6编译器)
<br>
功能概述　The current versions provide dense arrays and vectors, random number generators, and small vectors and matrices.是一个高效率的数值计算函数库，它的设计目的是希望建立一套既具像 C++ 一样方便，同时又比 Fortran 速度更快的数值计算环境。通常，用 C++ 所写出的数值程序，比 Fortran 慢 20% 左右，因此Blitz++ 正是要改掉这个缺点。方法是利用 C++ 的 template 技术，程序执行甚至可以比 Fortran 更快。</div>
<h4 id="MTL-http-www-osl-iu-edu-research-mtl-1"><a href="#MTL-http-www-osl-iu-edu-research-mtl-1" class="headerlink" title="MTL (http://www.osl.iu.edu/research/mtl/)"></a>MTL (<a href="http://www.osl.iu.edu/research/mtl/" target="_blank" rel="external">http://www.osl.iu.edu/research/mtl/</a>)</h4><div class="alert alert-info"><i class="fa fa-info"></i>  软件名称　Matrix Template Library(兼容vc6编译器)
<br>
功能概述　The Matrix Template Library (MTL) is a high-performance generic component library that provides comprehensive linear algebra functionality for a wide variety of matrix formats. MTL专注于线性代数相关的计算任务，如各种形式矩阵的生成(对角，共轭，稀疏，对称等)，相关的计算，变换，以及与一维向量的运算。</div>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C </tag>
            
            <tag> Fortran </tag>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于翻译单元（编译单元）]]></title>
      <url>http://pytlab.github.io/2016/02/17/%E5%85%B3%E4%BA%8E%E7%BF%BB%E8%AF%91%E5%8D%95%E5%85%83%EF%BC%88%E7%BC%96%E8%AF%91%E5%8D%95%E5%85%83%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>我的理解，翻译单元(translation unit)就是一个源代码文件，或者说是经过预处理器宏展开后得到的源码文件。在别人的博客中看到过</p>
<blockquote>
<p>translation unit（翻译单元）也可称为compilation unit(编译单元），translation unit是C预处理后的输出，即一个源文件经过预处理后.<br>经过translation unit后产生一个目标文件（比如.c通过编译产生.o文件）</p>
</blockquote>
<p>我个人的理解，一个翻译单元，至少是能够用编译器单独编译成<code>.o</code>文件的，因此有时候把函数定义或者类成员函数的定义放在单独的代码文件中时候，时候包含头文件与否要看是否能够单独将文件编译通过。例如类成员方法的文件中就应该要包含类定义的头文件，不然单独编译这些成员函数的时候，所操作的成员变量以及类名称都没告诉编译器，怎么让编译器给你编译？<br>但是有些时候例如使用关键字<code>extern</code>声明的引用声明，是可以进行编译的，我的理解就是编译器看到类似声明的变量或者函数的时候，应该会认为这个变量虽然在本单元中没有提供，但是链接器会把这个变量从其他的地方找到，因此就不报错了。估计调用在其他地方定义的函数也是类似的原因，反正有函数原型了，能不能执行函数就看连接器的了，我编译器就不管了（纯属个人意淫。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C </tag>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[函数定义可无需提供原型单独编译]]></title>
      <url>http://pytlab.github.io/2016/02/16/%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E5%8F%AF%E6%97%A0%E9%9C%80%E6%8F%90%E4%BE%9B%E5%8E%9F%E5%9E%8B%E5%8D%95%E7%8B%AC%E7%BC%96%E8%AF%91/</url>
      <content type="html"><![CDATA[<p>在多文件程序中一般我们会把结构相关的函数定义放在一个文件中以供调用，但是之前我一直不知道在这个文件中还需不需要这些函数的原型，正好在写练习的时候碰到了，就把原型删掉单独编译函数文件，编译通过。<br>这就说明了函数定义可以无需提供原型单独编译，原型仅是提供给调用函数的地方让编译器进行检查调用是否合法的。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C </tag>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[变量的静态初始化和动态初始化]]></title>
      <url>http://pytlab.github.io/2016/02/14/%E5%8F%98%E9%87%8F%E7%9A%84%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>零初始化和常量表达式初始化统称为<strong>静态初始化</strong>，这意味着编译器处理文件时就初始化了变量。<br>动态初始化意味着变量将在编译后初始化（先分配内存空间）。</p>
<p>使用常量表达式初始化变量，编译器根据文件内容对常量表达式进行简单的计算。但是编译器有没有那么的智能，它也只是能进行<strong>简单的计算</strong>，如果没有足够的信息，变量将被动态初始化。<br>但是，有一个比较特别的常量表达式，它没有使用字面常量。他就是<code>sizeof</code>运算符。<br>以下初始化表达式都是<strong>静态初始化</strong>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> x;                 <span class="comment">// 零初始化</span></div><div class="line"><span class="keyword">int</span> y = <span class="number">5</span>;             <span class="comment">// 常量表达式初始化</span></div><div class="line"><span class="keyword">long</span> z = <span class="number">13</span> * <span class="number">13</span>;      <span class="comment">// 常量表达式初始化</span></div><div class="line"><span class="keyword">int</span> e = <span class="keyword">sizeof</span>(<span class="keyword">long</span>);  <span class="comment">// 常量表达式初始化</span></div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p><br><br><strong>动态初始化</strong>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">4.0</span> * <span class="built_in">atan</span>(<span class="number">1.0</span>);</div></pre></td></tr></table></figure></p>
<p>编译器无法进行此计算，他不是常量表达式，必须调用<code>atan()</code>函数，这需要等到该函数被连接且程序执行时才能够被初始化。<br>因此我用gcc进行编译的时候会如下报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">warning: initializer element is not a constant expression [enabled by default]</div></pre></td></tr></table></figure>
<p>虽然会有warning但是编译翻译单元并不会报错，程序进行链接后会调用相应的函数对变量进行动态初始化，最终的可执行程序会顺利执行。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C </tag>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于C/C++的单定义规则]]></title>
      <url>http://pytlab.github.io/2016/02/13/%E5%85%B3%E4%BA%8EC-Cpp%E7%9A%84%E5%8D%95%E5%AE%9A%E4%B9%89%E8%A7%84%E5%88%99/</url>
      <content type="html"><![CDATA[<p>我们知道一般头文件包含的内容有：</p>
<ul>
<li>函数原型</li>
<li>使用<code>#define</code>或<code>const</code>(仅对于C++而言)定义的符号常量</li>
<li>结构声明</li>
<li>类声明</li>
<li>模板声明</li>
<li>内联函数</li>
</ul>
<p>正常在头文件中的内容是不进行内存分配的，例如若是变量则同一个变量会被重复定义声明，同理函数定义也是。所以也不能使用<code>#include</code>来包含源代码文件，也会导致<strong>多重声明</strong>。</p>
<h3 id="单定义规则（One-Definition-Rule-ODR）"><a href="#单定义规则（One-Definition-Rule-ODR）" class="headerlink" title="单定义规则（One Definition Rule, ODR）"></a>单定义规则（One Definition Rule, ODR）</h3><div class="alert alert-info"><i class="fa fa-info"></i>  单定义规则（One Definition Rule, ODR）：变量只能有一次定义。</div>
<a id="more"></a>
<p>什么是定义？<br>C++提供了两种变量声明：</p>
<ol>
<li><strong>定义</strong>声明（defining declaration）或简称<strong>定义</strong>（definition）:给变量分配存储空间。</li>
<li>引用<strong>声明</strong>（referencing declaration）或简称为<strong>声明</strong>（declaration）:它不给变量分配存储空间，因为它引用已有的变量。</li>
</ol>
<hr>
<p>下面来简单测试下C语言和C++的单定义规则<br>共三个文件：</p>
<ol>
<li><p>test.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义两个常规变量</span></div><div class="line"><span class="keyword">int</span> var1 = <span class="number">1</span>;</div><div class="line"><span class="keyword">double</span> var2 = <span class="number">2</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>file1.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, var1);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%f"</span>, var2);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>file2.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, var1);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%f"</span>, var2);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>按照翻译单元（文件）单独编译每个文件时编译并不会出问题。但将目标文件链接时便有multiple definition的报错<br><img src="2016/02/13/关于C-Cpp的单定义规则/multiple_definition.png" alt=""> (使用g++也会出现同样的错误)<br><strong>因此C语言和C++都会受到单定义规则的约束。</strong></p>
<h3 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h3><p>先上例子吧，在test.h中的变量前全部添加<code>const</code>限定符，分别使用gcc和g++对相应的C和C++翻译单元进行编译。<br>test.h<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> var1 = <span class="number">1</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> var2 = <span class="number">2</span>;</div></pre></td></tr></table></figure></p>
<p>若用gcc进行编译链接后仍会报错multiple definition<br><img src="2016/02/13/关于C-Cpp的单定义规则/gcc_multiple_definition.png" alt=""><br>但是用g++编译则没有报错<br><img src="2016/02/13/关于C-Cpp的单定义规则/gpp_multiple_definition.png" alt=""><br>这里就可以看出：<br><div class="alert alert-info"><i class="fa fa-info"></i>  和C语言不同，C++中，const限定符对默认的存储类型稍有影响。在默认情况下全局变量的链接性为外部的，但是用了const限定符使得全局变量的链接性为内部。也就是说在C++看来，全局const定义就像使用了static说明符一样。</div><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> fingers = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>相当于<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> fingers = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样把<code>const</code>常量放在头文件中，然后每个文件包含头文件也只是相当于增加了文件内部链接的常量，链接成一个程序并不会出现违背单定义规则的双重定义的情况出现。</p>
<div class="alert alert-warning"><i class="fa fa-bell"></i>  如果处于某种原因，希望某个常量的链接性为外部的，则可以使用extern关键字来覆盖默认的内部链接性。</div>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> states = <span class="number">50</span>;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>C和C++中变量定义都有<strong>单定义规则</strong>的约束。</li>
<li>C++中<code>const</code>限定符和<code>static</code>功能类似，C语言中则不是。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C </tag>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vim-双剑合璧，天下无敌]]></title>
      <url>http://pytlab.github.io/2016/02/09/Vim-%E5%8F%8C%E5%89%91%E5%90%88%E7%92%A7%EF%BC%8C%E5%A4%A9%E4%B8%8B%E6%97%A0%E6%95%8C/</url>
      <content type="html"><![CDATA[<p>这里的操作其实就是Vim命令的语言的语法了.<br>在Vim里面请用Vim语，哈哈。<br><code>daw</code>可以分解成三个部分：<code>d</code>, <code>a</code>, <code>w</code></p>
<ul>
<li><code>d</code>是操作符，也就是谓语（做什么）</li>
<li><code>a</code>类似数词，代指一个</li>
<li><code>w</code>是动作命令，也就是宾语（对谁做）</li>
</ul>
<hr>
<p><strong>Vim的操作符命令</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">Vim语</th>
<th style="text-align:left">人类语</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>c</code></td>
<td style="text-align:left">修改(change)</td>
</tr>
<tr>
<td style="text-align:left"><code>d</code></td>
<td style="text-align:left">删除(delete)</td>
</tr>
<tr>
<td style="text-align:left"><code>y</code></td>
<td style="text-align:left">复制到寄存器(yank)</td>
</tr>
<tr>
<td style="text-align:left"><code>g~</code></td>
<td style="text-align:left">转换大小写(swap)</td>
</tr>
<tr>
<td style="text-align:left"><code>gU</code></td>
<td style="text-align:left">转换大写</td>
</tr>
<tr>
<td style="text-align:left"><code>gu</code></td>
<td style="text-align:left">转换小写</td>
</tr>
<tr>
<td style="text-align:left"><code>&gt;</code></td>
<td style="text-align:left">增加缩进</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;</code></td>
<td style="text-align:left">减小缩进</td>
</tr>
<tr>
<td style="text-align:left"><code>=</code></td>
<td style="text-align:left">自动缩进</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<hr>
<p><strong>动作命令</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">Vim语</th>
<th style="text-align:left">人类语</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>l</code></td>
<td style="text-align:left">字母(letter)</td>
</tr>
<tr>
<td style="text-align:left"><code>w</code></td>
<td style="text-align:left">单词(word)</td>
</tr>
<tr>
<td style="text-align:left"><code>s</code></td>
<td style="text-align:left">句子(sentence)</td>
</tr>
<tr>
<td style="text-align:left"><code>p</code></td>
<td style="text-align:left">段落(paragraph)</td>
</tr>
</tbody>
</table>
<hr>
<p>Vim有一个额外的规则：<br><div class="alert alert-warning"><i class="fa fa-bell"></i>  当一个操作符被连续调用两次时，他会作用于当前行。</div><br>例如：<br><code>dd</code>就是删除光标所在的当前行<br><code>yy</code>复制当前行<br>…</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vim的'.'范式]]></title>
      <url>http://pytlab.github.io/2016/02/07/Vim-%E8%8C%83%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>虽然平时在服务器上使用的就是Vim，但是真的只是Vim的皮毛中的皮毛，决定好好学学Vim争取早日成为一个Vimer，哈哈。 上个学期就买了《Practical Vim–Edit Text at the Speed of Thought》,一直没集中时间看，趁着寒假集中看看吧。</p>
<hr>
<p>‘<code>.</code>范式’是我最开始接触Vim印象最深的了。</p>
<p><code>.</code>命令是重复命令，配合上一个操作以及光标移动快捷键就可以迅速完成重复的工作<br>例如在每行行尾添加<code>;</code>就可以通过<br><code>A</code> + <code>;</code> + <code>&lt;Esc&gt;</code>命令在第一行尾添加一个<code>;</code>，如果可以重复添加的话就可以使用<code>j</code> + <code>.</code>以上一个操作为单位进行重复操作。<br><a id="more"></a><br>因此<strong>理想模式</strong>就是<br><div class="alert alert-info"><i class="fa fa-info"></i>  用一键移动，另一键执行</div></p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++函数模板小结]]></title>
      <url>http://pytlab.github.io/2016/02/05/Cpp%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>函数重载比较简单，主要就是掌握函数特征标(function signature)–函数的参数列表<br><strong>是特征标，而不是函数类型使得函数进行重载的。</strong></p>
<p>C++编译器也是通过<strong>名称修饰(name decoration)</strong>来跟踪每一个重载函数的。</p>
<blockquote>
<p>名称修饰或者名称矫正， 是C++编译器根据函数原型中指定的形参类型对每一个函<strong>数名</strong>进行加密。</p>
</blockquote>
<div class="alert alert-info"><i class="fa fa-info"></i>  C++标准允许每个编译器设计人员以他们认为合适的方式实现名称修饰，因此由不同编译器创建的二进制模块（对象代码文件）很可无法正确的链接。也就是说，两个编译器将为同一个函数生成不同的修饰名称。名称的不同将使连接器无法将一个编译器生成的函数调用与另一个编译器生成的函数定义相匹配。在链接编译模块时，请确保所有对象文件或者库都是用同一个编译器生成的。如果有源代码，通常可以用自己的编译器重新编译源代码来相处链接错误。</div>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>函数模板就是使用泛型来定义函数，通过类型作为参数传给函数模板，编译器随后会生成相应类型版本的函数定义，供其他函数调用。<br>函数模板并<strong>不创建任何函数</strong>，而是告诉编译器如何定义函数。编译器检查所使用的参数类型，并生成相应的函数。最终的代码不包含任何模板，只包含了为程序生成的实际函数。<br><a id="more"></a><br>下面就来整理下函数模板的具体化。</p>
<h3 id="模板函数具体化"><a href="#模板函数具体化" class="headerlink" title="模板函数具体化"></a>模板函数具体化</h3><p>隐式实例化、显式实例化和显式具体化统称为具体化(specialization)， 他们表示的都是使用的<strong>具体类型的函数定义，而不是通用描述</strong>。<br><br></p>
<h4 id="隐式实例化"><a href="#隐式实例化" class="headerlink" title="隐式实例化"></a>隐式实例化</h4><p>就是编译器根据提供的函数参数类型自动根据函数模板生成某种类型的函数定义，便是隐式实例化，不做特殊处理的模板函数的应用应该都是隐式实例化。<br><br></p>
<h4 id="显式实例化"><a href="#显式实例化" class="headerlink" title="显式实例化"></a>显式实例化</h4><p>是直接命令编译器创建某一类型的函数实例，其语法是：生命所需的种类–用<code>&lt;&gt;</code>符号指示类型，并在声明前加上关键字<code>template</code>。<br>显式实例化使用时相当于一个声明，可以在函数中使用，例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> <span class="keyword">void</span> swap &lt;<span class="keyword">char</span>&gt;(<span class="keyword">char</span> &amp;, <span class="keyword">char</span> &amp;);  <span class="comment">// 显式实例化</span></div></pre></td></tr></table></figure></p>
<p>上面这句就相当于告诉编译器：<strong>“给我用<code>swap()</code>模板生成一个char型的函数定义”</strong><br>其他没有显式实例化声明的函数就是通过隐式实例化根据实际调用时候的参数类型生成相应版本函数定义。</p>
<p>另外，可以直接在调用函数的时候进行显式实例化，引导编译器实例化出本人希望的函数定义，例如,<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cout</span> &lt;&lt; Add&lt;<span class="keyword">double</span>&gt;(x, m) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 强制为double类型实例化</span></div></pre></td></tr></table></figure></p>
<p><br></p>
<h4 id="显式具体化"><a href="#显式具体化" class="headerlink" title="显式具体化"></a>显式具体化</h4><p>我个人喜欢把具体化翻译成特殊化，其实就是单独再定义一个新的模板，模板函数的名称和之前的通用模板是相同的，但是内容不同，是个特殊的函数模板。原型语法如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">void</span> swap&lt;<span class="keyword">char</span>&gt;(<span class="keyword">char</span> &amp;, <span class="keyword">char</span> &amp;);</div><div class="line"><span class="keyword">template</span> &lt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> &amp;, <span class="keyword">char</span> &amp;)</span></span>;</div></pre></td></tr></table></figure></p>
<p>上面这句就相当于告诉编译器：<strong>“不要用<code>swap</code>的通用模板来生成函数定义，使用专门为<code>char</code>类型的模板生成函数定义”</strong></p>
<p><br><br>关于上面这些概念《C++ Primer Plus》上用了一段代码进行了总结，我觉得挺好的，就贴上来：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span> <span class="params">(T &amp;, T &amp;)</span></span>;  <span class="comment">// 模板原型</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">void</span> swap&lt;job&gt;(job &amp;, job &amp;);  <span class="comment">// job结构的显式具体化</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">template</span> <span class="keyword">void</span> swap&lt;<span class="keyword">char</span>&gt; (<span class="keyword">char</span> &amp;, <span class="keyword">char</span> &amp;);  <span class="comment">// 针对char类型的显式实例化</span></div><div class="line">    <span class="keyword">short</span> a, b;</div><div class="line">    ...</div><div class="line">    swap(a, b);  <span class="comment">// 编译器自己决定的将模板swap隐式实例化</span></div><div class="line"></div><div class="line">    job n, m;</div><div class="line">    ...</div><div class="line">    swap(m, n);  <span class="comment">// 使用显式具体化的模板进行实例化</span></div><div class="line"></div><div class="line">    <span class="keyword">char</span> g, h;</div><div class="line">    ...</div><div class="line">    swap(g, h);  <span class="comment">// 对swap模板进行显式实例化</span></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="重载解析寻找最匹配函数优先级"><a href="#重载解析寻找最匹配函数优先级" class="headerlink" title="重载解析寻找最匹配函数优先级"></a>重载解析寻找最匹配函数优先级</h3><p>如果只存在一个这样的函数，选择之。<br>如果存在多个的话，且都为模板函数，选择<strong>最具体</strong>的模板函数</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[决定练习盲打]]></title>
      <url>http://pytlab.github.io/2016/02/04/%E5%86%B3%E5%AE%9A%E7%BB%83%E4%B9%A0%E7%9B%B2%E6%89%93/</url>
      <content type="html"><![CDATA[<p>决定联系盲打，以最大限度结合vim提高自己编辑文本(码代码)的效率！就像书上说的那样：</p>
<blockquote>
<p>以思维的速度编辑文本</p>
</blockquote>
<p>虽然现在打中文都很痛苦，但是我相信人类的手指是神奇的东西，几天之后我会慢慢熟悉的！<br>这种感觉就好象是高中练书法的时候是一样的，痛苦是短暂的，收获是永远的！<br>来吧！接受挑战！</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接受挑战！<br>　　　パ..パ・゜<br>　　（ ° Д ° ）<br>＿＿（＿っ /￣￣￣￣￣/＿<br>　　　　＼/＿＿＿＿＿/      </p>
]]></content>
      
        
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> Typing Master </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用CSS和font-awesome给博客添加时间线]]></title>
      <url>http://pytlab.github.io/2016/02/02/%E5%8D%9A%E5%AE%A2%E6%96%B0%E5%A2%9E%E6%97%B6%E9%97%B4%E7%BA%BF/</url>
      <content type="html"><![CDATA[<p>想给自己的about页面修饰一下，于是就想添加个个人时间线功能希望能通过时间线功能把自己的故事展现给别人面前，于是就参考网上别人的方法使用CSS + font-awesome实现了简单的时间线功能，效果如下图（也可以直接访问我的<a href="../../../about/">about页面</a><br><img src="assets/images/blog_img/2016-02-02-博客新增时间线/timeline.png" alt=""><br><a id="more"></a></p>
<hr>
<ol>
<li><p>首先下载<a href="http://getbootstrap.com/" target="_blank" rel="external">boostrap</a>和<a href="https://fortawesome.github.io/Font-Awesome/" target="_blank" rel="external">font-awesome</a><br>在这里我也顺带更新了Freemind中的font-awesome的版本到4.5.0</p>
</li>
<li><p>主要还是通过div结合CSS的伪类来实现</p>
<p> <strong>HTML部分</strong>如下(只包含第一部分)，</p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"line-warp"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"timeline-header"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"badge"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"fa fa-clock-o"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>My Timeline<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"line-item"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"line-icon-warp "</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"fa-stack fa-lg"</span> &gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-circle fa-stack-2x"</span> <span class="attr">style</span>=<span class="string">"color: #FFC125"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-lightbulb-o fa-stack-1x"</span> <span class="attr">style</span>=<span class="string">"color: #ffffff"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></div><div class="line">           <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"badge"</span>&gt;</span> &amp;nbsp;&amp;nbsp;Just Now&amp;nbsp;&amp;nbsp; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"line-content-box"</span>&gt;</span></div><div class="line">            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;</div><div class="line">            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;</div><div class="line">            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;</div><div class="line">            Talk is cheap, show me the code...<span class="tag">&lt;<span class="name">br</span>&gt;</span></div><div class="line">            　　　パ..パ・゜<span class="tag">&lt;<span class="name">br</span>&gt;</span> </div><div class="line">            　　（ ° Д ° ）<span class="tag">&lt;<span class="name">br</span>&gt;</span> </div><div class="line">            ＿＿（＿っ /￣￣￣￣￣/＿   &amp;nbsp;&amp;nbsp;Inputing...<span class="tag">&lt;<span class="name">br</span>&gt;</span> </div><div class="line">            　　　　＼/＿＿＿＿＿/      &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;正在输入...<span class="tag">&lt;<span class="name">br</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p> <strong>CSS部分</strong><br> 这里的实现主要是通过before和first-child伪类实现在气泡前方添加时间线和图标（图标是使用的font-awesome通过字体大小控制图标大小），贴上代码：</p>
 <figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*Time line*/</span></div><div class="line"> <span class="comment">/*时间轴大容器*/</span></div><div class="line"><span class="selector-class">.line-warp</span>&#123;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">width</span>: <span class="number">80%</span>;</div><div class="line">    <span class="attribute">min-width</span>: <span class="number">200px</span>;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">    <span class="attribute">margin-top</span>: <span class="number">50px</span>;</div><div class="line">    <span class="attribute">margin-bottom</span>: <span class="number">30px</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*timeline*/</span></div><div class="line"><span class="selector-class">.line-warp</span><span class="selector-pseudo">:before</span>&#123;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</div><div class="line">    <span class="attribute">left</span>:<span class="number">21px</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">2px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">    <span class="attribute">margin-top</span>: <span class="number">10px</span>;</div><div class="line">    <span class="attribute">margin-bottom</span>: <span class="number">15px</span>;</div><div class="line">    <span class="attribute">background</span>: <span class="number">#adadad</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line">    <span class="comment">/* 每一行*/</span></div><div class="line"><span class="selector-class">.line-item</span>&#123;</div><div class="line"></div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">margin-top</span>: <span class="number">30px</span>;</div><div class="line">&#125;</div><div class="line">   <span class="comment">/* 左边的图标 容器*/</span></div><div class="line"><span class="selector-class">.line-icon-warp</span>&#123;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">/*   通过修改font-size来控制图标大小*/</span></div><div class="line"><span class="selector-class">.line-icon-warp</span> <span class="selector-tag">span</span><span class="selector-pseudo">:first-child</span>&#123;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">22px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.line-icon-warp</span> <span class="selector-class">.badge</span>&#123;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">13px</span>;</div><div class="line">&#125;</div><div class="line"> <span class="comment">/*右边 内容*/</span></div><div class="line"><span class="selector-class">.line-content-box</span>&#123;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">margin-left</span>: <span class="number">155px</span>;</div><div class="line">    <span class="attribute">background</span>: <span class="number">#e5e5e5</span>;</div><div class="line">    <span class="attribute">border-radius</span>: .<span class="number">25em</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">1em</span>;</div><div class="line">    <span class="attribute">color</span>: <span class="number">#000</span>;</div><div class="line">    <span class="attribute">font-family</span>: <span class="string">"Calibri"</span>, <span class="string">"Arial"</span>, <span class="string">"Microsoft YaHei"</span>, <span class="string">"黑体"</span>;</div><div class="line">    <span class="attribute">-webkit-transition</span>: all .<span class="number">2s</span> linear;</div><div class="line">    <span class="attribute">-moz-transition</span>: all .<span class="number">2s</span> linear;</div><div class="line">    <span class="attribute">transition</span>: all .<span class="number">2s</span> linear;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 用来画内容框左边的小箭头*/</span></div><div class="line"><span class="selector-class">.line-content-box</span><span class="selector-pseudo">:before</span>&#123;</div><div class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">top</span>: <span class="number">14px</span>;</div><div class="line">    <span class="attribute">left</span>: -<span class="number">14px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">border</span>: <span class="number">7px</span> solid transparent;</div><div class="line">    <span class="attribute">border-right</span>: <span class="number">7px</span> solid <span class="number">#e5e5e5</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在这里有一个问题就是如何实现时间线中的绘画气泡样式，我借鉴了别人使用的纯CSS截取div边框的方式实现箭头。 详细方法可以参照<a href="http://www.admin10000.com/document/4089.html" target="_blank" rel="external">这里</a>或者<a href="http://yuiblog.com/blog/2010/11/22/css-quick-tip-css-arrows-and-shapes-without-markup/" target="_blank" rel="external">这里</a></p>
</li>
<li><p>最终使用boostrap的panel把时间线框起来。</p>
</li>
</ol>
<hr>
<p>有兴趣的可以直接去我主题的<a href="https://github.com/PytLab/hexo-theme-freemind" target="_blank" rel="external">github页面</a>参考<a href="https://github.com/PytLab/hexo-theme-freemind/blob/master/source/css/style.css" target="_blank" rel="external">css/style.css</a>和<a href="https://github.com/PytLab/pytlab.github.io" target="_blank" rel="external">博客源代码中</a>的about页面<a href="https://github.com/PytLab/pytlab.github.io/blob/hexo/source/about/index.html" target="_blank" rel="external">about/index.html</a>的代码，其中也包括了简介部分。</p>
<hr>
]]></content>
      
        <categories>
            
            <category> 教程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Freemind </tag>
            
            <tag> CSS </tag>
            
            <tag> HTML </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[纪念下github上的第一个merge]]></title>
      <url>http://pytlab.github.io/2016/02/02/%E7%BA%AA%E5%BF%B5%E4%B8%8B%E8%BD%BDgithub%E4%B8%8A%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAmerge/</url>
      <content type="html"><![CDATA[<p>终于在别人的项目里贡献了自己的代码。<br>使用<a href="http://www.jiathis.com/" target="_blank" rel="external">Jiathis</a>和<a href="http://share.baidu.com/" target="_blank" rel="external">baidu share</a>给Freemind主题中添加了文章分享功能.我自己的模板也是默认使用的bdshare插件。项目的主人wzpan merge了我的pull request，在此对他表达感谢。<br><a id="more"></a><br><img src="assets/images/blog_img/2016-02-02-纪念下载github上的第一个merge/page.png" alt=""><br><img src="assets/images/blog_img/2016-02-02-纪念下载github上的第一个merge/chat.png" alt=""><br>在这里纪念下，希望能鼓励自己不断学习不断在开源项目中留下自己的印记。</p>
]]></content>
      
        
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> 随笔 </tag>
            
            <tag> Hexo </tag>
            
            <tag> Freemind </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于指向数组的指针]]></title>
      <url>http://pytlab.github.io/2016/01/28/%E5%85%B3%E4%BA%8E%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88/</url>
      <content type="html"><![CDATA[<p>这次看《C++ Primer Plus》发现对于只想数组的指针这里还有一点之前没有注意，就是：</p>
<blockquote>
<p>将地址运算符<code>&amp;</code>用于数组名时，将返回整个数组的地址，例如<code>&amp;cookies</code>将返回一个32字节的内存块地址。<br>上面的<code>cookies</code>是书上的一个例子，不过所谓一个32字节的内存地址，就是一个含有8个<code>int</code>(如果<code>int</code>长4字节)的数组的地址(其值也是首字节的地址)。</p>
</blockquote>
<a id="more"></a>
<p>这点在函数指针的声明时也有说明，<br>先声明一个函数指针数组pa<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> * (* pa[<span class="number">3</span>])(<span class="keyword">const</span> <span class="keyword">double</span> *, <span class="keyword">int</span>);</div></pre></td></tr></table></figure></p>
<p>若我想声明一个指向含有三个函数指针的数组的指针，用<code>auto</code>关键字时可以通过<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> pb = &amp;pa;</div></pre></td></tr></table></figure></p>
<p>根据最上面所说的<code>&amp;</code>用于数组名时，返回整个数组的地址，<code>pa</code>是首元素的地址也就和函数指针数组名相同，<code>&amp;</code>操作后返回整个<code>pa</code>的地址，则<code>pb</code>就是指向含有3个函数指针的数组的指针。</p>
<p>手动声明的话如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> * (* (*pb)[<span class="number">3</span>])(<span class="keyword">const</span> <span class="keyword">double</span> *, <span class="keyword">int</span>)</div></pre></td></tr></table></figure></p>
<p>这里看似很复杂，其实分拆来看很好理解，</p>
<ul>
<li>把约定函数特征的部分去掉就只剩下<code>* (*pb)[3]</code></li>
<li>第一个<code>*</code>是指数组里面的元素是函数的指针</li>
<li><code>(*pb)[3]</code>是指<code>pb</code>是指向含有之前描述的3个元素的数组的指针。</li>
</ul>
<p>关于数组指针取数组中的值</p>
<blockquote>
<p>既然<code>pd</code>指向数组，那么<code>*pd</code>就是数组，而<code>(*pd)[i]</code>是数组中的元素。</p>
</blockquote>
<p>愚蠢的我曾经通过数组指针取数组元素的值的时候还用过将数组指针通过指派运算符转换成元素的指针(数组名)然后操作。<br>也就是下面这样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*((<span class="keyword">double</span> *)pd + i)</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C </tag>
            
            <tag> 指针 </tag>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[指针的两级间接关系与`const`/非`const`混合赋值的理解]]></title>
      <url>http://pytlab.github.io/2016/01/26/%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%A4%E7%BA%A7%E9%97%B4%E6%8E%A5%E5%85%B3%E7%B3%BB%E4%B8%8Econst-%E9%9D%9Econst%E6%B7%B7%E5%90%88%E8%B5%8B%E5%80%BC%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p class="text-danger">为什么进入两级间接关系与一级间接关系不同, `const`与非`const`混合指针赋值方式将不再安全?</p>
<p><br></p>
<h4 id="首先要明确一件事"><a href="#首先要明确一件事" class="headerlink" title="首先要明确一件事:"></a>首先要明确一件事:</h4><div class="alert alert-warning"><i class="fa fa-bell"></i>  非`const`指针是不能指向`const`值的。</div>
<p>原因很简单,非<code>const</code>指针可以改变指向的值,所以非<code>const</code>指针若指向<code>const</code>值,故可以改变<code>const</code>值,前后就矛盾了,因此这种赋值时禁止的。</p>
<p><br></p>
<h4 id="那再来看两级关系，"><a href="#那再来看两级关系，" class="headerlink" title="那再来看两级关系，"></a>那再来看两级关系，</h4><p>先声明两级关系的变量<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> ** pp;</div><div class="line"><span class="keyword">int</span> * p;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">13</span>;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>先假设允许两级关系的赋值，也就是非<code>const</code>指针赋值给<code>const</code>指针的指针<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pp = &amp;p;</div></pre></td></tr></table></figure></p>
<p>那么…<br>pp 做为<code>const</code>变量是可以与<code>const</code>值n关联的，即<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*pp = &amp;n;</div></pre></td></tr></table></figure></p>
<p>然后, 由于刚才<code>pp</code>指向了<code>p</code>， <code>p</code>指向的值就是<code>n</code>，则就意味着</p>
<p><strong>!!! <code>p</code>指向了<code>n</code> !!!</strong></p>
<p>这样一来，就和一开始说的情况一样了，我们将一个非<code>const</code>指针<code>p</code>指向了一个<code>const</code>值<code>n</code>，这样是禁止的。</p>
<p>所以，两级间接关系<code>const</code>与非<code>const</code>混合指针赋值方式将不安全。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C </tag>
            
            <tag> 指针 </tag>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Cpp Primer Plus 6th Answers]]></title>
      <url>http://pytlab.github.io/2016/01/26/Cpp-Primer-Plus-6th-Answers/</url>
      <content type="html"><![CDATA[<p>因为接触了KMCLib，觉得有必要入C++的坑了，决定尽快把《C++ Primer Plus》这本书的课后练习敲一边以达到入门目的，当然我也不指望像这学期开始的时候一样花6天就把Fortran那本书看完了, 毕竟是个大坑我得轻轻的跳免得自己摔得很惨，代码会同步更新到GitHub<br><br><br>PS.由于对C比较熟悉前面几张和C重叠的部分习题就没有写，只写了数据读取和C不同的部分用来学习，所以前几章的习题并不完整。<br><br><br>代码地址: <a href="https://github.com/PytLab/Cpp-Primer-Plus" target="_blank" rel="external">Cpp Primer Plus Answers</a></p>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="https://github.com/PytLab/Cpp-Primer-Plus/tree/master/ch03" target="_blank" rel="external">第三章 处理数据</a></li>
<li><a href="https://github.com/PytLab/Cpp-Primer-Plus/tree/master/ch04" target="_blank" rel="external">第四章 复合类型</a></li>
<li><a href="https://github.com/PytLab/Cpp-Primer-Plus/tree/master/ch05" target="_blank" rel="external">第五章 循环和关系表达式</a></li>
<li><a href="https://github.com/PytLab/Cpp-Primer-Plus/tree/master/ch06" target="_blank" rel="external">第六章 分支语句和逻辑运算符</a><a id="more"></a></li>
<li><a href="https://github.com/PytLab/Cpp-Primer-Plus/tree/master/ch07" target="_blank" rel="external">第七章 函数–C++的编程模块</a></li>
<li><a href="https://github.com/PytLab/Cpp-Primer-Plus/tree/master/ch08" target="_blank" rel="external">第八章 函数探幽</a></li>
<li><a href="https://github.com/PytLab/Cpp-Primer-Plus/tree/master/ch09" target="_blank" rel="external">第九章 内存模型和名称空间</a></li>
<li><a href="https://github.com/PytLab/Cpp-Primer-Plus/tree/master/ch10" target="_blank" rel="external">第十章 对象和类</a></li>
<li><a href="https://github.com/PytLab/Cpp-Primer-Plus/tree/master/ch11" target="_blank" rel="external">第十一章 使用类</a></li>
<li><a href="https://github.com/PytLab/Cpp-Primer-Plus/tree/master/ch12" target="_blank" rel="external">第十二章 类和动态内存分配</a></li>
<li><a href="https://github.com/PytLab/Cpp-Primer-Plus/tree/master/ch13" target="_blank" rel="external">第十三章 类继承</a></li>
<li><a href="https://github.com/PytLab/Cpp-Primer-Plus/tree/master/ch14" target="_blank" rel="external">第十四章 C++中的代码重用</a></li>
<li><a href="https://github.com/PytLab/Cpp-Primer-Plus/tree/master/ch15" target="_blank" rel="external">第十五章 友元、异常和其他</a></li>
<li><a href="https://github.com/PytLab/Cpp-Primer-Plus/tree/master/ch16" target="_blank" rel="external">第十六章 string类和标准模板库</a></li>
<li><a href="https://github.com/PytLab/Cpp-Primer-Plus/tree/master/ch17" target="_blank" rel="external">第十七章 输入、输出和文件</a></li>
</ul>
<h4 id="—–-2016-03-16-complete-—–"><a href="#—–-2016-03-16-complete-—–" class="headerlink" title="—– 2016.03.16 complete! —–"></a>—– 2016.03.16 complete! —–</h4>]]></content>
      
        <categories>
            
            <category> 代码作品 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Freemind theme modified by PytLab]]></title>
      <url>http://pytlab.github.io/2016/01/24/Freemind-modified-by-PytLab/</url>
      <content type="html"><![CDATA[<p>这两天修改了下Freemind的主题的CSS和EJS, 调教出了属于自己的Freemind主题, 由于很喜欢浅色系像GitHub那种风格，于是就参照人家的风格改写的，<br>主题代码地址：<a href="https://github.com/PytLab/hexo-theme-freemind" target="_blank" rel="external">My Freemind Repo</a></p>
<p>另外自己做了一个博客的logo，能力有限就直接用PS做的，不过挺简洁的，我也很喜欢</p>
<p><img src="assets/images/blog_img/2016-01-24-Freemind-modified-by-PytLab/logo_565x250.png" alt=""><br><a id="more"></a></p>
<p>首页截图：</p>
<p><img src="assets/images/blog_img/2016-01-24-Freemind-modified-by-PytLab/homepage.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 代码作品 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Freemind </tag>
            
            <tag> CSS </tag>
            
            <tag> EJS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++字符串读取函数小结]]></title>
      <url>http://pytlab.github.io/2016/01/24/C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AF%BB%E5%8F%96%E5%87%BD%E6%95%B0%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>由于有一些微小的差异不容易记忆，在这里整理下目前看到的C++的字符串读取函数</p>
<a id="more"></a>
<h3 id="面向单词的读取"><a href="#面向单词的读取" class="headerlink" title="面向单词的读取"></a>面向单词的读取</h3><p><code>std::cin</code>直接读取，正如<a href="/2016/01/23/C-C-字符读取总结/">前面</a>总结的cin会跳过空字符。</p>
<h3 id="面向行的读取"><a href="#面向行的读取" class="headerlink" title="面向行的读取"></a>面向行的读取</h3><ol>
<li><p><code>cin.getline()</code><br> 通过换行符确定输入结尾，<strong>读取</strong>但<strong>不保存</strong>换行符(用空字符代替换行符)，调用举例</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.getline(name, <span class="number">20</span>);  <span class="comment">// 包含字符不超过19个</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>cin.get()</code><br> 调用方式和确定结尾方式均与<code>cin.getline()</code>相同，但是<strong>不读取换行符</strong>,换行符仍保留在流中，因此若要连续读入行要使用变体<code>cin.get()</code>将换行符跳过，例如：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.get(name, <span class="number">20</span>);</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.get();</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>.get(name, <span class="number">20</span>);</div></pre></td></tr></table></figure>
<p> 由于返回对象仍是<code>cin</code>，因此可连续调用</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cin</span>.get(name, <span class="number">20</span>).get();</div></pre></td></tr></table></figure>
<p> <strong>注意：</strong></p>
 <div class="alert alert-info"><i class="fa fa-info"></i>  当<code>std::cin.get()</code>函数读取到空行时会返回<code>false</code>，但是在较早的C++标准中的<code>std::cin.get()</code>版本读取空行后并不会返回<code>false</code>，而是将字符串中的第一个字符设为空字符<code>'\0'</code></div>
</li>
<li><p><code>getline()</code><br> 对于string对象的读取，使用的是<code>getline()</code>函数，例如：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str;</div><div class="line">getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, str);</div></pre></td></tr></table></figure>
<p> 若读取失败，返回<code>false</code></p>
</li>
<li><p><code>cin.ignore()</code><br> 该函数接受两个参数，一个实数字，制定要读取的最大字符数；另一个是字符用作输入分界符。例如下面的函数调用读取斌丢弃接下来的255个字符或者知道达到第一个换行符：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cin</span>.ignore(<span class="number">255</span>, <span class="string">'\n'</span>);</div></pre></td></tr></table></figure>
<p> 函数原型：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">istream &amp; <span class="title">ignore</span><span class="params">(<span class="keyword">int</span> = <span class="number">1</span>, <span class="keyword">int</span> = EOF)</span></span>;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><br></p>
<h4 id="cin-getline-VS-cin-get"><a href="#cin-getline-VS-cin-get" class="headerlink" title="cin.getline() VS cin.get()"></a><code>cin.getline()</code> VS <code>cin.get()</code></h4><p><code>cin.get()</code>可以通过判断下一个字符是否是换符<code>\n</code>来判断是否是读取整行而停止还是数组填满<br><code>cin.getline()</code>由于吞掉了<code>\n</code>则无法判断</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GitHub Pages绑定顶级域名的方法]]></title>
      <url>http://pytlab.github.io/2016/01/23/GitHub-Pages%E7%BB%91%E5%AE%9A%E9%A1%B6%E7%BA%A7%E5%9F%9F%E5%90%8D/</url>
      <content type="html"><![CDATA[<p>刚刚把自己买的域名<a href="http://ipytlab.com" target="_blank" rel="external">ipytlab.com</a>与GitHub Pages进行绑定，现在访问<a href="http://ipytlab.com" target="_blank" rel="external">ipytlab.com</a>以及<a href="http://pytlab.github.io">pytlab.github.io</a>均能访问我的博客啦。</p>
<p>在github的help页面有介绍如何绑定域名 - <a href="https://help.github.com/articles/about-custom-domains-for-github-pages-sites/" target="_blank" rel="external">About custom domains for GitHub Pages sites</a></p>
<p>下面简单写一下我将Hexo + Github Pages绑定顶级域名的方法：</p>
<ol>
<li><p>在自己网站项目repo的根目录添加CNAME，里面的内容为域名不要http以及www等前缀，只需写入域名本身，例如</p>
 <figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ipytlab</span><span class="selector-class">.com</span></div></pre></td></tr></table></figure>
 <div class="alert alert-warning"><i class="fa fa-bell"></i>  如果是直接在GitHub网页上添加文件的话，会遇到一个问题就是在通过`hexo g -d`之后hexo会把根目录下的CNAME文件删除。</div>
<p> 所以要把CNAME文件添加到<code>/source</code>目录下，这样<code>hexo g -d</code>之后hexo会自动把CNAME复制到<code>/puclic</code>目录下然后将<code>/public</code>路径下的内容进行复制并push到远程<code>master</code>分支的根目录下。</p>
 <a id="more"></a>
</li>
<li><p>添加DNS Service记录<br> 在<a href="https://www.dnspod.cn" target="_blank" rel="external">DNSPod</a>注册帐号然后添加域名设置两个A记录，分别是@和www，ip地址填</p>
 <figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">192<span class="selector-class">.30</span><span class="selector-class">.252</span><span class="selector-class">.153</span></div></pre></td></tr></table></figure>
<p> 如下图：<br> <img src="/assets/images/blog_img/2016-01-23-GitHub-Pages绑定顶级域名/DNSPod.png" alt=""></p>
</li>
<li><p>设置域名的DNS<br> 在相应域名的DNS Service中添加上图中间的两条记录：<br> <code>f1g1ns1.dnspod.net</code>和<code>f1g1ns1.dnspod.net</code></p>
</li>
<li><p>稍等解析生效后就可以通过在浏览器中输入自己的域名来访问GitHub Pages博客啦! 如下图，<br> <img src="/assets/images/blog_img/2016-01-23-GitHub-Pages绑定顶级域名/homepage.png" alt=""></p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 教程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> GitHub Pages </tag>
            
            <tag> 域名 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C & C++字符读取总结]]></title>
      <url>http://pytlab.github.io/2016/01/23/C-C-%E5%AD%97%E7%AC%A6%E8%AF%BB%E5%8F%96%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>在这里总结一下C和C++的字符读取函数的使用，主要是我每次要用的时候都会出现概念混乱，在这里做小结以便今后在用的时候能迅速回忆并使用。</p>
<a id="more"></a>
<hr>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h2 id="scanf-函数"><a href="#scanf-函数" class="headerlink" title="scanf()函数"></a><code>scanf()</code>函数</h2><p>还是要先从C语言说起，这部分在《C Primer Plus》讲解的很详细。</p>
<h3 id="scanf-的工作"><a href="#scanf-的工作" class="headerlink" title="scanf()的工作"></a><code>scanf()</code>的工作</h3><p><code>scanf</code>可以读取各种格式的数据，<code>scanf</code>的工作是将输入<strong>逐个字符</strong>的转换成其他格式数据(<code>int, float, char, C字符串</code>)</p>
<h3 id="scanf-的工作过程"><a href="#scanf-的工作过程" class="headerlink" title="scanf()的工作过程"></a><code>scanf()</code>的工作过程</h3><p>对于<code>scanf()</code>工作过程重要的一点是<strong><code>scanf()</code>会跳过空白字符</strong>,空白字符包括空格、制表符、换行符。直到遇到符合要求的字符，然后进行格式转换并存入到相应的变量中。</p>
<p>如果格式不匹配，<code>scanf()</code>会认为已经到达相应格式数据的结尾，并把最后一次读取的不符合格式要求哦字符放回输入，然后停在那里，等程序再次调用<code>scanf()</code>时再重复上述过程继续读取。因此流程总结大致为:</p>
<ol>
<li>逐字符读取字符，直到遇到不符合格式说明符的字符;</li>
<li>若遇到不符合的字符，将该字符放回输入，<code>scanf()</code>停止读取;</li>
<li><code>scanf()</code>将读取的字符转换成相应格式数据并存储到对应变量中</li>
<li>程序调用继续重复1、2、3过程读取数据</li>
</ol>
<h3 id="s和-c格式"><a href="#s和-c格式" class="headerlink" title="%s和%c格式"></a><code>%s</code>和<code>%c</code>格式</h3><ul>
<li><code>%s</code>时，<code>scanf()</code>仍然会跳过空白字符，但其他字符都一视同仁了。</li>
<li><code>%c</code>时所有字符全部平等，<strong>不会跳过空白字符！！</strong></li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p><code>scanf()</code>返回成功读取项目的个数。</p>
<ul>
<li>当没有读取任何数据的时候，返回0</li>
<li>检测到文件结尾的时候返回EOF(-1)</li>
</ul>
<h2 id="getchar-函数"><a href="#getchar-函数" class="headerlink" title="getchar()函数"></a><code>getchar()</code>函数</h2><p>和<code>scanf()</code>类似， 调用方式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> ch;</div><div class="line">ch = getchar();</div></pre></td></tr></table></figure></p>
<h2 id="getc-函数"><a href="#getc-函数" class="headerlink" title="getc()函数"></a><code>getc()</code>函数</h2><p>工作方式和<code>getchar()</code>类似，但是可以指定使用的文件<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">FILE * fp;</div><div class="line"><span class="comment">// get fp...</span></div><div class="line">ch = getc(fp);</div></pre></td></tr></table></figure></p>
<p>其中，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ch = getc(<span class="built_in">stdin</span>);  <span class="comment">// 与 ch = getchar()等价</span></div></pre></td></tr></table></figure></p>
<hr>
<p><br></p>
<h2 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h2><h3 id="使用原始的cin对象进行输入"><a href="#使用原始的cin对象进行输入" class="headerlink" title="使用原始的cin对象进行输入"></a>使用原始的<code>cin</code>对象进行输入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> ch;</div><div class="line"><span class="built_in">cin</span> &gt;&gt; ch;</div></pre></td></tr></table></figure>
<p>不过直接使用<code>cin</code>的话，<code>cin</code>会在读取字符的时候<strong>跳过空字符</strong>，因此<code>see you later</code>回显以后会是<code>seeyoulater</code>。</p>
<div class="alert alert-warning"><i class="fa fa-bell"></i>  这里和C中的`scanf("%c", &ch)`不同，cin >> ch依旧会跳过空格和换行符而不是像scanf读取字符时候一视同仁</div>
<h3 id="cin-get-ch"><a href="#cin-get-ch" class="headerlink" title="cin.get(ch)"></a><code>cin.get(ch)</code></h3><p>此方法将参数<code>ch</code>声明为引用,然后给赋值，此方法<strong>不会跳过空字符</strong></p>
<h4 id="cin-get-ch-方法的文件尾条件"><a href="#cin-get-ch-方法的文件尾条件" class="headerlink" title="cin.get(ch)方法的文件尾条件"></a><code>cin.get(ch)</code>方法的文件尾条件</h4><p>若读到文件尾，也就是检测到EOF后<code>cin</code>将<code>eofbit</code>和<code>failbit</code>都设为1，可以分别通过<code>cin.eof()</code>和<code>cin.fail()</code>调用获取<br>也就是<br><code>cin.eof()</code> -&gt; <code>true</code><br><code>cin.fail()</code> -&gt; <code>true</code></p>
<blockquote>
<p>输入错误和EOF都将导致<code>cin</code>返回<code>false</code></p>
</blockquote>
<p>另外，由于这个函数的返回值仍为<code>cin</code>对象，<code>cin</code>对象很神奇会在需要bool的时候自动从istream对象转换成bool型数值。因此可以直接将<code>cin</code>放入条件判断语句中。如:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> ch;</div><div class="line"><span class="built_in">cin</span>.get(ch);</div><div class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>)&#123;...&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="ch-cin-get-方法"><a href="#ch-cin-get-方法" class="headerlink" title="ch = cin.get()方法"></a><code>ch = cin.get()</code>方法</h3><p>此方法与C语言的<code>getchar()</code>类似，会返回读取的字符值。但是这里的返回值是<code>int</code>类型数值。</p>
<h3 id="cin-get-ch-VS-cin-get"><a href="#cin-get-ch-VS-cin-get" class="headerlink" title="cin.get(ch) VS cin.get()"></a><code>cin.get(ch)</code> VS <code>cin.get()</code></h3><table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left"><code>cin.get(ch)</code></th>
<th style="text-align:left"><code>ch=cin.get()</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>传递输入字符的方式</strong></td>
<td style="text-align:left">赋值给参数<code>ch</code></td>
<td style="text-align:left">将参数返回值赋值给<code>ch</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>用于字符输入时函数的返回值</strong></td>
<td style="text-align:left"><code>istream</code>对象(执行<code>bool</code>转换后为<code>true</code>)</td>
<td style="text-align:left"><code>int</code>类型的字符编码</td>
</tr>
<tr>
<td style="text-align:left"><strong>到达<code>EOF</code>时函数的返回值</strong></td>
<td style="text-align:left"><code>istream</code>对象(执行<code>bool</code>转换后为<code>false</code>)</td>
<td style="text-align:left"><code>EOF</code></td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C </tag>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用Freemind装修新家]]></title>
      <url>http://pytlab.github.io/2016/01/22/%E7%94%A8Freemind%E8%A3%85%E4%BF%AE%E6%96%B0%E5%AE%B6/</url>
      <content type="html"><![CDATA[<p>决定使用<a href="https://github.com/hexojs/hexo" target="_blank" rel="external">Freemind</a>主题，主要是对boostrap颇有好感, 很喜欢boostrap的风格。</p>
<h3 id="建站步骤"><a href="#建站步骤" class="headerlink" title="建站步骤"></a>建站步骤</h3><ol>
<li><p>建站方式我也是按照网上的博客，用git建立两个分支:</p>
<ul>
<li><span class="label label-info">hexo</span> , 为默认分支，主要放博客的Markdown文件和theme等网站文件.</li>
<li><span class="label label-default">master</span> , 部署后的网站文件(尽量不要再本地<code>git checkout</code>到master分支，不然要把hexo在装一遍，当然是我git用的不熟的原因啦)</li>
</ul>
</li>
<li><p>在hexo分支执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo</div><div class="line">$ hexo init</div><div class="line">$ npm install</div><div class="line">$ npm install hexo-deployer-git</div></pre></td></tr></table></figure>
</li>
<li><p>备份网站原始文件就通过<code>git add</code>, <code>git commit</code>, <code>git push</code>等命令提交到远程git服务器</p>
</li>
<li><p>生成和部署以及自动备份到github:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate <span class="_">-d</span></div></pre></td></tr></table></figure>
</li>
</ol>
<a id="more"></a>
<h3 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h3><p>关于Hexo的主题在GitHub上有很多repo可以拿来用，具体的可以参考知乎上的回答</p>
<ul>
<li><a href="https://www.zhihu.com/question/24422335" target="_blank" rel="external">有那些好看的Hexo主题?</a></li>
</ul>
<h3 id="管理主题"><a href="#管理主题" class="headerlink" title="管理主题"></a>管理主题</h3><p>有效的管理theme的方法就是使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/wzpan/hexo-theme-freemind.git</div></pre></td></tr></table></figure></p>
<p>将theme的repo直接克隆到本地以便使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git pull</div></pre></td></tr></table></figure></p>
<p>及时进行更新</p>
<h3 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h3><p>还有一种管理theme的方式就是先fork出一个theme的分支，然后<code>clone</code>自己的repo到本地，这样可以进行修改后即使提交到远程服务器可以达到备份主题的效果<br>我自己就修改了Freemind的主题, 修改了些css属性，详见:<a href="https://github.com/PytLab/hexo-theme-freemind" target="_blank" rel="external">PytLab/hexo-theme-freemind</a></p>
]]></content>
      
        <categories>
            
            <category> 教程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> 随笔 </tag>
            
            <tag> Git </tag>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的博客新家]]></title>
      <url>http://pytlab.github.io/2016/01/21/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%96%B0%E5%AE%B6/</url>
      <content type="html"><![CDATA[<p>由于自己买的空间感觉不稳定也不靠谱，于是用<a href="https://github.com/hexojs/hexo" target="_blank" rel="external">Hexo</a>把博客迁到GitHub Pages来了，这是我的博客新家。等有空会把<a href="http://ipytlab.com" target="_blank" rel="external">ipytlab.com</a>上的文章迁移到这里来。<br>嘿嘿，先用不同语言打个招呼先，以后请多多关照ヽ(•̀ω•́ )ゝ<br>ps.很是喜欢用Markdown写博客啊，这代码块我也很是喜欢 (￣y▽￣)~*</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// C </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Hello Github Pages! -- zjshao\n"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// C plus plus</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello Github Pages! -- zjshao"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># python</span></div><div class="line"><span class="keyword">print</span> <span class="string">"Hello Github Pages. -- zjshao"</span></div></pre></td></tr></table></figure>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">! FORTRAN</span></div><div class="line"><span class="function"><span class="keyword">PROGRAM</span></span> main</div><div class="line">  <span class="keyword">IMPLICIT</span> <span class="keyword">NONE</span></div><div class="line">  <span class="built_in">WRITE</span>(*, *) <span class="string">"Hello Github Pages, --zjshao"</span></div><div class="line"><span class="keyword">END</span> <span class="function"><span class="keyword">PROGRAM</span></span> main</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于碰撞理论(Collision Theory)那点事儿]]></title>
      <url>http://pytlab.github.io/2015/11/01/%E5%85%B3%E4%BA%8E%E7%A2%B0%E6%92%9E%E7%90%86%E8%AE%BA-Collision-Theory-%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/</url>
      <content type="html"><![CDATA[<p>这里只总结关于使用碰撞理论进行表面碰撞（吸附）速率的推导。<br>先上个图吧，理解这里全靠这张图。<br><img src="/assets/images/blog_img/2016-03-01-关于碰撞理论-Collision-Theory-那点事儿/surface_collision.png" alt=""><br><a id="more"></a><br>碰撞速率就是单位时间内单位面积分子碰撞到表面的次数。如图给定一个表面其面积为$A$, 若分子能够碰撞到表面则一定有垂直于表面的速率$v_{x}$。<br>所有分子的速率分布服从Boltzmann分布$f(v_{x})$。<br>若垂直于表面的速率为$v_{x}$的分子能在在给定时间$\Delta t$内能够撞到表面的话，则该分子距离表面的距离一定小于$v_{x}\Delta t$。<br>换一个角度理解就是，若在垂直于表面且体积为$V = v_{x}\Delta t A$的立方体之内的分子才能够撞到表面。<br>那就好办了，也就是说把这个体积求出来乘上分子的密度就得到时间$\Delta t$内撞到表面积为$A$的表面的分子数了。那速率也就可以得到了。于是有，<br>$$<br>r_{coll-surf} = \frac{1}{\Delta t A }\int_{0}^{\infty} f(v_{x})V(v_{x}) \rho dv_{x}<br>$$<br>其中$\int_{0}^{\infty} f(v_{x})V(v_{x}) \rho dv_{x}$就是能够碰撞到表面的分子总数<br>能够撞到表面的“体积”   $V=v_{x}\Delta t A$也是速率的函数因此要放在里面一起积分。<br><br><br>于是碰撞速率就可推导出：<br>$$<br>r_{coll-surf} = \frac{1}{\Delta t A }\int_{0}^{\infty} f(v_{x})V(v_{x}) \rho dv_{x} = \rho \int_{0}^{\infty} v_{x} f(v_{x}) dv_{x} \\<br>= \frac{p}{k_{B}T} \int_{0}^{\infty}  v_{x} \sqrt{\frac{m}{2\pi k_{B} T}  } e^{- \frac{mv_{x}^{2}}{2k_{B}T}} dv_{x} \\<br>= \frac{p}{k_{B}T} \bar{v_{x}} = \frac{p}{k_{B}T} \sqrt{\frac{k_{B}T}{2\pi m}}<br>= \frac{p}{\sqrt{2 \pi m k_{B} T}}<br>$$</p>
<div class="alert alert-danger"><i class="fa fa-bug"></i>  这里得到的是单位时间单位面积的碰撞次数，也就是单位为$m^{-2} \bullet s^{-1}$</div>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kinetics </tag>
            
            <tag> catalysis </tag>
            
            <tag> chemistry </tag>
            
            <tag> 学术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[开始看VASP源码]]></title>
      <url>http://pytlab.github.io/2015/10/09/%E5%BC%80%E5%A7%8B%E7%9C%8BVASP%E6%BA%90%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>最近开始看VASP源码啦，心得什么的会写在这里，当然几十万行的VASP代码不可能全部都看，重点还是ionic relaxation的部分啦～come on！</p>
]]></content>
      
        
        <tags>
            
            <tag> chemistry </tag>
            
            <tag> VASP </tag>
            
            <tag> Fortran </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Fortran数组初始化总结]]></title>
      <url>http://pytlab.github.io/2015/09/03/Fortran%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>fortran数组的初始化有些地方和C类似，有些地方由于Fortran有所谓隐含式循环数组初始化更加灵活。<br><strong>初始化为相同的值</strong></p>
<p>C:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> c[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">/*这种方法只能全部初始化为0, 其他数字不行*/</span></div></pre></td></tr></table></figure></p>
<p>Fortran:<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">integer</span> :: f(<span class="number">10</span>) = <span class="number">0</span></div><div class="line"><span class="comment">!DATA</span></div><div class="line"><span class="keyword">INTEGER</span> :: F(<span class="number">10</span>)</div><div class="line"><span class="keyword">DATA</span> F /<span class="number">10</span>*<span class="number">0</span>/</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p><strong>全部初始化</strong></p>
<p>C:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> c[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</div></pre></td></tr></table></figure></p>
<p>Fortran:<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">integer</span> :: f(<span class="number">5</span>) = (/ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> /)</div><div class="line"><span class="comment">!DATA</span></div><div class="line"><span class="keyword">INTEGER</span> :: F(<span class="number">5</span>)</div><div class="line"><span class="keyword">DATA</span> F /<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>/</div></pre></td></tr></table></figure></p>
<p>下面是fortran的特色了，<br>隐含式循环初始化</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">integer</span> :: f(<span class="number">5</span>) = (/ <span class="number">1</span>, (i, i=<span class="number">2</span>, <span class="number">4</span>), <span class="number">5</span> /)</div><div class="line"><span class="comment">!初始化二维数组</span></div><div class="line"><span class="keyword">integer</span> :: f(<span class="number">2</span>, <span class="number">2</span>)</div><div class="line"><span class="keyword">data</span> ((f(i, j), i=<span class="number">1</span>,<span class="number">2</span>), j=<span class="number">1</span>,<span class="number">2</span>) /<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>/</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C </tag>
            
            <tag> Fortran </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于Fortran和C数组的优先模式]]></title>
      <url>http://pytlab.github.io/2015/09/01/%E5%85%B3%E4%BA%8EFortran%E5%92%8CC%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%98%E5%85%88%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>熟悉了C语言和Python中的行优先模式，上手Fortran的列优先模式时候有点绕，大致在这整理下思路。<br>无论对于C或者Fortran数据对象在内存中都是连续排列的。比如我初始化一个3×3的二维数组.<br>C语言<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> c[<span class="number">3</span>][<span class="number">3</span>] = &#123;</div><div class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</div><div class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</div><div class="line">    &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Fortran<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">integer</span> :: f(<span class="number">3</span>, <span class="number">3</span>)</div><div class="line"><span class="keyword">integer</span> :: r, c</div><div class="line"><span class="keyword">data</span> ((m(r, c), r=<span class="number">1</span>, <span class="number">3</span>), c=<span class="number">1</span>, <span class="number">3</span>) /(i, i=<span class="number">1</span>,<span class="number">9</span>)/ <span class="comment">! 注意我这里是按照列进行初始化的</span></div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>通过上面两种语言的初始化数组的方式，数据对象在内存中存放的方式都是<br><code>1|2|3|4|5|6|7|8|9</code><br>但是C和fortran对连续内存块进行随机存取时候的索引优先是不同的，C是按照行优先，也就是stride等于1，上述数据对象的分别为：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c[<span class="string">0</span>][<span class="symbol">0</span>], c[<span class="string">0</span>][<span class="symbol">1</span>], c[<span class="string">0</span>][<span class="symbol">2</span>], c[<span class="string">1</span>][<span class="symbol">0</span>], c[<span class="string">1</span>][<span class="symbol">1</span>], c[<span class="string">1</span>][<span class="symbol">2</span>], c[<span class="string">2</span>][<span class="symbol">0</span>], c[<span class="string">2</span>][<span class="symbol">1</span>], c[<span class="string">2</span>][<span class="symbol">2</span>]</div></pre></td></tr></table></figure></p>
<p>Fortran是列优先, stride等于3，上述对象分别为:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f(<span class="number">1</span>, <span class="number">1</span>), f(<span class="number">2</span>, <span class="number">1</span>), f(<span class="number">3</span>, <span class="number">1</span>), f(<span class="number">1</span>, <span class="number">2</span>), f(<span class="number">2</span>, <span class="number">2</span>), f(<span class="number">3</span>, <span class="number">2</span>), f(<span class="number">1</span>, <span class="number">3</span>), f(<span class="number">2</span>, <span class="number">3</span>), f(<span class="number">3</span>, <span class="number">3</span>)</div></pre></td></tr></table></figure></p>
<p>对于经常使用的话，我觉得直接按照线性代数里面最直观的列向量来处理就行，估计Fortran在设计的时候也是科学家们方便操作列向量才这么设计的。</p>
<p>Fortran数组输出时的注意,<br><code>write(*, *)</code> f进行输出时，是直接按照内存顺序输出的，也就是一列一列输出，但是看起来是一行一行的。<br>例如,</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">program</span></span> ex0714</div><div class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></div><div class="line">    <span class="keyword">integer</span> :: i, j</div><div class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: <span class="built_in">size</span> = <span class="number">5</span></div><div class="line">    <span class="keyword">integer</span> :: m(<span class="built_in">size</span>, <span class="built_in">size</span>)</div><div class="line"></div><div class="line">    <span class="keyword">forall</span>(i = <span class="number">1</span>:<span class="built_in">size</span>, j = <span class="number">1</span>:<span class="built_in">size</span>, i &lt; j) m(i, j) = <span class="number">1</span></div><div class="line">    <span class="keyword">forall</span>(i = <span class="number">1</span>:<span class="built_in">size</span>, j = <span class="number">1</span>:<span class="built_in">size</span>, i == j) m(i, j) = <span class="number">2</span></div><div class="line">    <span class="keyword">forall</span>(i = <span class="number">1</span>:<span class="built_in">size</span>, j = <span class="number">1</span>:<span class="built_in">size</span>, i &gt; j) m(i, j) = <span class="number">3</span></div><div class="line"></div><div class="line">    <span class="built_in">write</span>(*, <span class="string">"(5(5I5, /))"</span>) m</div><div class="line">    <span class="keyword">stop</span></div><div class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> ex0714</div></pre></td></tr></table></figure>
<p>输出就为</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">2 </span>   <span class="number">3</span>    <span class="number">3</span>    <span class="number">3</span>    <span class="number">3</span></div><div class="line"><span class="symbol">1 </span>   <span class="number">2</span>    <span class="number">3</span>    <span class="number">3</span>    <span class="number">3</span></div><div class="line"><span class="symbol">1 </span>   <span class="number">1</span>    <span class="number">2</span>    <span class="number">3</span>    <span class="number">3</span></div><div class="line"><span class="symbol">1 </span>   <span class="number">1</span>    <span class="number">1</span>    <span class="number">2</span>    <span class="number">3</span></div><div class="line"><span class="symbol">1 </span>   <span class="number">1</span>    <span class="number">1</span>    <span class="number">1</span>    <span class="number">2</span></div></pre></td></tr></table></figure>
<p>和我本意不同，所以要按照我的顺序输出就应该改一下输出顺序</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">write(<span class="name">*</span>, <span class="string">"(5(5I5, /))"</span>) ((<span class="name">m</span>(<span class="name">i</span>, j), j=1, size), i=1, size)</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">2 </span>   <span class="number">1</span>    <span class="number">1</span>    <span class="number">1</span>    <span class="number">1</span></div><div class="line"><span class="symbol">3 </span>   <span class="number">2</span>    <span class="number">1</span>    <span class="number">1</span>    <span class="number">1</span></div><div class="line"><span class="symbol">3 </span>   <span class="number">3</span>    <span class="number">2</span>    <span class="number">1</span>    <span class="number">1</span></div><div class="line"><span class="symbol">3 </span>   <span class="number">3</span>    <span class="number">3</span>    <span class="number">2</span>    <span class="number">1</span></div><div class="line"><span class="symbol">3 </span>   <span class="number">3</span>    <span class="number">3</span>    <span class="number">3</span>    <span class="number">2</span></div></pre></td></tr></table></figure></p>
<p>以上</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C </tag>
            
            <tag> Fortran </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git push的时候用ssh放弃https]]></title>
      <url>http://pytlab.github.io/2015/08/29/git-push%E7%9A%84%E6%97%B6%E5%80%99%E7%94%A8ssh%E6%94%BE%E5%BC%83https/</url>
      <content type="html"><![CDATA[<p>这几天改以前的代码，每次git push到github的时候总是提醒我输入我输入github的用户名和密码，很是麻烦。<br>于是找到了原因，之前我的代码是通过https clone到本地的，如果一开始是通过git ssh克隆就不会出现这种问题。如果已经通过https克隆，不用着急可以修改。</p>
<p>在你的版本库.git中打开config文件会有如下一段代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[remote &quot;origin&quot;]  </div><div class="line">fetch = + refs/heads/*:refs/remotes/origin/*  </div><div class="line">url = https://username@github.com/username/projectname.git</div></pre></td></tr></table></figure></p>
<p>url改成相应的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[remote &quot;origin&quot;]  </div><div class="line">fetch = + refs/heads/*:refs/remotes/origin/*  </div><div class="line">url = git@github.com:username/projectname.git</div></pre></td></tr></table></figure></p>
<p>这样就可以通过ssh公钥的方式认证进行git push啦</p>
]]></content>
      
        <categories>
            
            <category> 教程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[具有局部作用域的变量是否可以在作用域外使用?]]></title>
      <url>http://pytlab.github.io/2015/08/22/%E5%85%B7%E6%9C%89%E5%B1%80%E9%83%A8%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%9C%A8%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%A4%96%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>昨天在操作链表的时候看到书上写了一段释放链表内存的代码，感觉奇奇怪怪的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">current = head;</div><div class="line"><span class="keyword">while</span>(current != <span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">free</span>(current);</div><div class="line">    current = current-&gt;next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码就是在释放了current指向的内存之后仍然使用了该内存的数据。感觉好奇怪，不知道是作者的原因还是什么。<br>应该这样写才对：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">current = head;</div><div class="line"><span class="keyword">while</span>(current != <span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line">    tmp = current-&gt;next;</div><div class="line">    <span class="built_in">free</span>(current);</div><div class="line">    current = tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>不然<code>free()</code>可能使当前节点的内容不再可用。<br>后面我在stackoverflow上看到一个<a href="http://stackoverflow.com/questions/6441218/can-a-local-variables-memory-be-accessed-outside-its-scope/6445794#6445794" target="_blank" rel="external">回答</a>，比喻的很好：</p>
<blockquote>
<p>你在某个酒店订了一个房，你入住的时候，你放了一本书在这个酒店的抽屉里，但是你走的时候，你忘了这本书。而且，你还没有把这个房间的钥匙还回去。于是，你在未来某个时候，偷偷地回来，打开这个房间的门，你看到了你的书还在里间。当然，还还可以放回别的书。因为，这个酒店管理不会在你走的时候把你留下的书清走，而且，这个酒店的管理的安保措施不是那么严格，因为他信任每一个客人都会遵守管理条例。</p>
<p>在这种情况下，如果你幸运的话，书还会在那里，也可能你的书已经没了。也有可能当你回去的时候，有一个人在那里正在撕你的书，或者酒店把那个抽屉都挪走并变成衣柜，或是整个酒店正在被拆除以改成了一个足球场，而你偷偷摸摸进到施工现场的时候被炸死。<br>也就是说即使我释放了当前指针指向的内存，我也可以通过同样的指针访问该部分内容，但是内容就没有保障了，所谓some random memory area。这就好像我和系统之间的一个协议，我不会偷着回来我的房间，但是我的确偷偷的这么做了，也就是没有履行协议。<br>后面有个高票的回答也很好：</p>
<p>What you’re doing here is simply reading and writing to memory that used to be the address of a. Now that you’re outside of foo, it’s just a pointer to some random memory area. It just so happens that in your example, that memory area does exist and nothing else is using it at the moment. You don’t break anything by continuing to use it, and nothing else has overwritten it yet. Therefore, the 5 is still there. In a real program, that memory would be re-used almost immediately and you’d break something by doing this (though the symptoms may not appear until much later!)</p>
<p>When you return from foo, you tell the OS that you’re no longer using that memory and it can be reassigned to something else. If you’re lucky and it never does get reassigned, and the OS doesn’t catch you using it again, then you’ll get away with the lie. Chances are though you’ll end up writing over whatever else ends up with that address.</p>
<p>Now if you’re wondering why the compiler doesn’t complain, it’s probably because foo got eliminated by optimization. It usually will warn you about this sort of thing. C assumes you know what you’re doing though, and technically you haven’t violated scope here (there’s no reference to a itself outside of foo), only memory access rules, which only triggers a warning rather than an error.</p>
<p><strong>In short: this won’t usually work, but sometimes will by chance.</strong></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C Notes -- 数组初始化总结]]></title>
      <url>http://pytlab.github.io/2015/08/17/C-NOTE--%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>今天给结构数组初始化的时候发现也能指定初始化项目列表。于是试了试int数组也可以，在这里把这几种常用的数组初始化方法总结下。</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">putarr</span><span class="params">(<span class="keyword">int</span> *)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">/*不同方法初始化*/</span></div><div class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</div><div class="line">    putarr(a);</div><div class="line">    <span class="keyword">int</span> b[<span class="number">5</span>] = &#123;<span class="number">2</span>&#125;;</div><div class="line">    putarr(b);</div><div class="line">    <span class="keyword">int</span> c[<span class="number">5</span>] = &#123; [<span class="number">2</span>] = <span class="number">2</span> &#125;; <span class="comment">/*指定初始化项目*/</span></div><div class="line">    putarr(c);</div><div class="line">    <span class="keyword">int</span> d[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</div><div class="line">    putarr(d);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">putarr</span><span class="params">(<span class="keyword">int</span> * arr)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</div><div class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<pre>
0 1 2 3 4
2 0 0 0 0
0 0 2 0 0
0 1 2 0 0
</pre>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C Notes - 关于逻辑运算符]]></title>
      <url>http://pytlab.github.io/2015/08/14/%E5%85%B3%E4%BA%8E%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      <content type="html"><![CDATA[<p>昨天写了个c语言处理文件的练习题，题目是：</p>
<blockquote>
<p>编写一个代开两个文件的程序。可以使用命令行参数或者请求用户输入来获取文件名。让程序打印第一个文件的第一行，第二个文件的第二行，第一个文件第一行，第二个文件第二行。。。以此类推，知道打印完行数较多的文件的最后一行。</p>
</blockquote>
<p>程序很短很好写，但是在写程序的过程中我是通过逻辑或来判断是否两个文件都读完。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(fgets(line1, SLEN, fp1) != <span class="literal">NULL</span> || fgets(line2, SLEN, fp2) != <span class="literal">NULL</span>)</div><div class="line">&#123;...&#125;</div></pre></td></tr></table></figure></p>
<p>可是这样输出的结果是先打印了第一个文件的所有行然后是第二个文件的所有行。<br>后来想了想，之所以出现这样的结果，有可能是逻辑运算符如果第一个条件满足后就不会运算<code>||</code>后面的表达式了。<br>于是我把代码改成如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">pt1 = fgets(line1, SLEN, fp1);</div><div class="line">pt2 = fgets(line2, SLEN, fp2);</div><div class="line"><span class="keyword">while</span>(pt1 || pt2)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">fputs</span>(line1, <span class="built_in">stdout</span>);</div><div class="line">    <span class="built_in">fputs</span>(line2, <span class="built_in">stdout</span>);</div><div class="line">    pt1 = fgets(line1, SLEN, fp1);</div><div class="line">    pt2 = fgets(line2, SLEN, fp2);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>果然是猜测的原因，以后用或运算符的时候要注意这里了。<br>以上。</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C </tag>
            
            <tag> Notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VASPy一个面向对象的VASP文件处理库]]></title>
      <url>http://pytlab.github.io/2015/08/12/VASPy%E4%B8%80%E4%B8%AA%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84VASP%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%BA%93/</url>
      <content type="html"><![CDATA[<p>放假在家可以写写以前的想法，把vasp中的文件写成python对象，这样既系统有方便写脚本。就在github上开了个repo，目前写了几个文件的class,其中包含处理MaterialStudio的xsd类xml文件的类。不断更新,欢迎使用vasp的小伙伴们star,fork贡献出自己的一份力。<br>库链接：<a href="https://github.com/PytLab/VASPy" target="_blank" rel="external"><ins datetime="2015-08-12T06:17:43+00:00">Processing VASP files with Python - VASPy</ins></a></p>
<a id="more"></a>
<hr>
<h2 id="软件包介绍"><a href="#软件包介绍" class="headerlink" title="软件包介绍"></a>软件包介绍</h2><h3 id="An-object-oriented-VASP-file-processing-library"><a href="#An-object-oriented-VASP-file-processing-library" class="headerlink" title="An object-oriented VASP file processing library."></a>An <strong>object-oriented</strong> VASP file processing library.</h3><p>Make it <strong>easier</strong> to process VASP files.</p>
<p>处理VASP文件从未如此 <strong>灵活</strong> <strong>简单</strong></p>
<h3 id="命令行处理DOS文件使用举例："><a href="#命令行处理DOS文件使用举例：" class="headerlink" title="命令行处理DOS文件使用举例："></a>命令行处理DOS文件使用举例：</h3><pre><code>#处理分割好的DOS文件
&gt;&gt;&gt; from vaspy.electro import DosX
&gt;&gt;&gt; a = DosX(&apos;DOS1&apos;)
&gt;&gt;&gt; b = DosX(&apos;DOS8&apos;)

#分波态密度合并
&gt;&gt;&gt; c = a
&gt;&gt;&gt; c.reset_data()              # 初始化DOS数据
&gt;&gt;&gt; for i in xrange(1, 10):
&gt;&gt;&gt;    c += DosX(&apos;DOS&apos;+str(i))  # 循环合并DOS数据
&gt;&gt;&gt; ...
&gt;&gt;&gt; c.data                      # 以float矩阵显示合并后的数据
                                # 可直接进行计算等操作
&gt;&gt;&gt; c.tofile()                  # 生成新的合并后的DOS文件

#绘图
&gt;&gt;&gt; c.plotsum(0, (5, 10))       # 绘制d轨道pDOS图
</code></pre><h4 id="绘制结果"><a href="#绘制结果" class="headerlink" title="绘制结果:"></a>绘制结果:</h4><p><img src="/2015/08/12/VASPy一个面向对象的VASP文件处理库/pDOS.png" alt=""></p>
<p>处理ELFCAR举例:</p>
<pre><code>&gt;&gt;&gt; from vaspy.electro import ElfCar
&gt;&gt;&gt; a = ElfCar() 
&gt;&gt;&gt; a.plot_contour()   # 绘制等值线图
&gt;&gt;&gt; a.plot_mcontour()  # 使用mlab绘制等值线图(需安装Mayavi)
&gt;&gt;&gt; a.plot_contour3d() # 绘制3d等值线图
&gt;&gt;&gt; a.plot_field()     # 绘制标量场
</code></pre><h4 id="绘制结果-1"><a href="#绘制结果-1" class="headerlink" title="绘制结果:"></a>绘制结果:</h4><p><img src="/assets/images/blog_img/2015-08-12-VASPy一个面向对象的VASP文件处理库/contour2d.png" alt=""></p>
<p><img src="/assets/images/blog_img/2015-08-12-VASPy一个面向对象的VASP文件处理库/contours.png" alt=""></p>
<p>3D 等值线图</p>
<p><img src="/assets/images/blog_img/2015-08-12-VASPy一个面向对象的VASP文件处理库/contour3d.png" alt=""></p>
<p>scalar field</p>
<p><img src="/assets/images/blog_img/2015-08-12-VASPy一个面向对象的VASP文件处理库/field.png" alt=""></p>
<p>charge difference(use ChgCar class)</p>
<p><img src="/assets/images/blog_img/2015-08-12-VASPy一个面向对象的VASP文件处理库/contourf.png" alt=""></p>
<p>操作XDATCAR举例</p>
<pre><code>&gt;&gt;&gt; from vaspy.atomco import XdatCar
&gt;&gt;&gt; xdatcar = XdatCar()
&gt;&gt;&gt; # 输出xdatcar相应Cartesian坐标
&gt;&gt;&gt; for step, data in xdatcar:
&gt;&gt;&gt;     print step
&gt;&gt;&gt;     print xdatcar.dir2cart(xdatcar.bases, data)
&gt;&gt;&gt; # 可直接运行script/中脚本生成相应.arc文件用于MaterialStudio显示动画
&gt;&gt;&gt; python xdatcar_to_arc.py
</code></pre><p>动画实例</p>
<p><img src="/assets/images/blog_img/2015-08-12-VASPy一个面向对象的VASP文件处理库/sn2_my.gif" alt=""></p>
<p><strong>使用者可以编写自己的脚本来批处理VASP文件</strong></p>
]]></content>
      
        <categories>
            
            <category> 代码作品 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> VASP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[有共鸣啦]]></title>
      <url>http://pytlab.github.io/2015/06/14/%E6%9C%89%E5%85%B1%E9%B8%A3%E5%95%A6/</url>
      <content type="html"><![CDATA[<p>今天看Gilbert Strang的公开课，他提到了矩阵的应用中说了化学，<br>这种方法在我之前写kinetic模型的时候就用了，核心代码很少，就能把一连串基元反应配平并合并了哈哈哈。<br>来来来，上code(主要代码)：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">null</span><span class="params">(A, eps=<span class="number">1e-10</span>)</span>:</span></div><div class="line">    <span class="string">"get null space of transposition of site_matrix"</span></div><div class="line">     u, s, vh = np.linalg.svd(A, full_matrices=<span class="number">1</span>, compute_uv=<span class="number">1</span>)</div><div class="line">     null_space = np.compress(s &lt;= eps, vh, axis=<span class="number">0</span>)</div><div class="line">     <span class="keyword">return</span> null_space.T</div><div class="line"> x = null(site_matrix.T)  <span class="comment"># basis of null space</span></div><div class="line"> <span class="keyword">if</span> <span class="keyword">not</span> x.any():  <span class="comment"># x is not empty</span></div><div class="line">     <span class="keyword">raise</span> ValueError(<span class="string">'Failed to get basis of nullspace.'</span>)</div><div class="line"> x = map(abs, x.T.tolist()[<span class="number">0</span>])</div></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> GilbertStrang </tag>
            
            <tag> LinearAlgebra </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[动力学模型已兼容相对能量的输入文件]]></title>
      <url>http://pytlab.github.io/2015/06/14/%E5%8A%A8%E5%8A%9B%E5%AD%A6%E6%A8%A1%E5%9E%8B%E5%B7%B2%E5%85%BC%E5%AE%B9%E7%9B%B8%E5%AF%B9%E8%83%BD%E9%87%8F%E7%9A%84%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>之前的动力学代码的数据文件我是在catmap的基础上进行改进，写了个tablemaker来生成一个csv文件，然后让要计算动力学的人把每个需要的物种的绝对能量输入到表格中，模型会在处理数据的时候自动计算其所有基元反应的能垒以及反应能量变化。之所有这样进行能量输入，是方便在后面能够基于每个物种的能量进行计算，比如在做出是猜测的时候进行Boltzmann分布，在进行敏感度分析时候能够针对每个中间态和过渡态进行分析。<br>但是之前有一次帮师姐计算它的反应，他只有相对能量。如下，</p>
<a id="more"></a>
<p>反应：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">% 反应</div><div class="line">O2 + # &lt;-&gt; O2#</div><div class="line">NO + O2# &lt;-&gt; ONOO#</div><div class="line">ONOO# &lt;-&gt; NO2#</div><div class="line">O# + NO &lt;-&gt; NO2#</div><div class="line">NO2# &lt;-&gt; # + NO2</div><div class="line"></div><div class="line">% 能量</div><div class="line">Ea = [0.63 0.65 0.22 0.65 0];</div><div class="line">G0 = [0.368 -0.455 -1.13 -0.49 -0.19];</div></pre></td></tr></table></figure></p>
<p>于是我就在纸上手动算出来每个物种的所谓’generalized formation energy’。当然首先把O2、N0以及#的能量为0，然后根据相对能量的关系列出来线性方程组，通过矩阵乘法一步计算出所有其他物种的形成能。(顺便在这里吐槽下，所谓generalized formation energy通过这样的方法也能得到，感觉是个很虚的概念诶～)。得到矩阵的具体方法就是下得到一个coefficients matrix，m是从能量数据中得到的等式数，n是除去能量为0的物种以外其他所有物种。贴上获取矩阵的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_unknown_coeff_vector</span><span class="params">(self, elementary_rxn_list)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Expect a elementary_rxn_list,</div><div class="line">    e.g. [['O2_s', 'NO_g'], ['*_s', 'ON-OO_s'], ['*_s', 'ONOO_s']]</div><div class="line">    return coefficient vectors, Ea, G0.</div><div class="line">    e.g. ([[0, 0, -1, 0, 0, 0, 0, 0, 1], [0, 0, -1, 1, 0, 0, 0, 0, 0]], 0.655, -0.455)</div><div class="line">    """</div><div class="line">    idx = self._owner.elementary_rxns_list.index(elementary_rxn_list)</div><div class="line">    Ea, G0 = self.Ea[idx], self.G0[idx]</div><div class="line"></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">'unknowns'</span>):</div><div class="line">        self.get_unknown_species()</div><div class="line"></div><div class="line">    coeff_vects = []</div><div class="line">    <span class="keyword">if</span> Ea != <span class="number">0</span> <span class="keyword">and</span> len(elementary_rxn_list) != <span class="number">2</span>:  <span class="comment"># has barrier</span></div><div class="line">        <span class="comment">#get ts coefficient vector</span></div><div class="line">        is_list, ts_list = elementary_rxn_list[<span class="number">0</span>], elementary_rxn_list[<span class="number">1</span>]</div><div class="line">        is_dict, ts_dict = self.list2dict(is_list), self.list2dict(ts_list)</div><div class="line">        coeff_vect = []</div><div class="line">        <span class="keyword">for</span> unknown <span class="keyword">in</span> self.unknowns:</div><div class="line">            <span class="keyword">if</span> unknown <span class="keyword">in</span> is_dict:</div><div class="line">                coeff = -is_dict[unknown]</div><div class="line">            <span class="keyword">elif</span> unknown <span class="keyword">in</span> ts_dict:</div><div class="line">                coeff = ts_dict[unknown]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                coeff = <span class="number">0</span></div><div class="line">            coeff_vect.append(coeff)</div><div class="line">        coeff_vects.append(coeff_vect)</div><div class="line"></div><div class="line">    <span class="comment">#coefficient vector for G0</span></div><div class="line">    is_list, fs_list = elementary_rxn_list[<span class="number">0</span>], elementary_rxn_list[<span class="number">-1</span>]</div><div class="line">    is_dict, fs_dict = self.list2dict(is_list), self.list2dict(fs_list)</div><div class="line">    coeff_vect = []</div><div class="line">    <span class="keyword">for</span> unknown <span class="keyword">in</span> self.unknowns:</div><div class="line">        <span class="keyword">if</span> unknown <span class="keyword">in</span> is_dict:</div><div class="line">            coeff = -is_dict[unknown]</div><div class="line">        <span class="keyword">elif</span> unknown <span class="keyword">in</span> fs_dict:</div><div class="line">            coeff = fs_dict[unknown]</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            coeff = <span class="number">0</span></div><div class="line">        coeff_vect.append(coeff)</div><div class="line">    coeff_vects.append(coeff_vect)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> Ea:</div><div class="line">        <span class="keyword">return</span> coeff_vects, [Ea, G0]</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> coeff_vects, [G0]</div></pre></td></tr></table></figure></p>
<p>后面的处理就是修改了下parser里面的parse_data()方法，将上面计算得到的形成能解析到动力学模型中。<br>对应于csv_parser，新的rel_energy_parser中也有相应的parse_data()方法来读取能量数据，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_data</span><span class="params">(self)</span>:</span>  <span class="comment"># correspond with parse_data() in csv_parser.py</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Solve Axb equation to get value of generalized free energies.</div><div class="line">    """</div><div class="line">    A, b = [], []</div><div class="line">    <span class="keyword">for</span> rxn_list <span class="keyword">in</span> self._owner.elementary_rxns_list:</div><div class="line">        coeff_vects, value = self.get_unknown_coeff_vector(rxn_list)</div><div class="line">        A.extend(coeff_vects)</div><div class="line">        b.extend(value)</div><div class="line"></div><div class="line">    A, b = np.matrix(A), np.matrix(b).reshape(<span class="number">-1</span>, <span class="number">1</span>)</div><div class="line">    x = A.I*b  <span class="comment"># values for unknowns</span></div><div class="line"></div><div class="line">    <span class="comment">#convert column vector to list</span></div><div class="line">    x = x.reshape(<span class="number">1</span>, <span class="number">-1</span>).tolist()[<span class="number">0</span>]</div><div class="line"></div><div class="line">    <span class="comment">#put values to G_dict</span></div><div class="line">    <span class="keyword">for</span> sp_name, G <span class="keyword">in</span> zip(self.unknowns, x):</div><div class="line">        self.G_dict.setdefault(sp_name, G)</div><div class="line"></div><div class="line">    <span class="comment">#put generalized formation energy into species_definition</span></div><div class="line">    <span class="keyword">for</span> sp_name <span class="keyword">in</span> self.G_dict:</div><div class="line">        sp_dict = self._owner.species_definitions</div><div class="line">        sp_dict[sp_name].setdefault(<span class="string">'formation_energy'</span>, self.G_dict[sp_name])</div><div class="line"></div><div class="line">    setattr(self._owner, <span class="string">'hasdata'</span>, <span class="keyword">True</span>)</div><div class="line"></div><div class="line">    <span class="keyword">return</span></div></pre></td></tr></table></figure></p>
<p>为此我又专门写了一个能够读取相对能量数据并计算动力学模型的运行脚本run_relative.py<br>能量数据放在一个.py结尾的文件中，形如<br><img src="assets/images/blog_img/2015-06-14-动力学模型已兼容相对能量的输入文件/QQ截图20150614221151.gif" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 学术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> kinetic model </tag>
            
            <tag> kinetics </tag>
            
            <tag> Kynetix </tag>
            
            <tag> catalysis </tag>
            
            <tag> chemistry </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C-Primer-Plus 5th Answers]]></title>
      <url>http://pytlab.github.io/2015/05/17/c-primer-plus-5th-answers/</url>
      <content type="html"><![CDATA[<div class="alert alert-info"><i class="fa fa-info"></i>  C Primer Plus第五版课后习题答案</div>
<p>决定空闲的时候把第五版《C-Primer-Plus》的编程练习敲一边来复习下C，在<a href="https://github.com/PytLab/C-Primer-Plus" target="_blank" rel="external">GitHub</a>(<a href="https://github.com/PytLab/C-Primer-Plus" target="_blank" rel="external">https://github.com/PytLab/C-Primer-Plus</a>)上同步更新。</p>
<hr>
<div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  -----------------  更新 已完成 ------------------</div>
<h4 id="Table-of-Content"><a href="#Table-of-Content" class="headerlink" title="Table of Content"></a>Table of Content</h4><ul>
<li><a href="https://github.com/PytLab/C-Primer-Plus/tree/master/ch03" target="_blank" rel="external">第三章 数据和C</a></li>
<li><a href="https://github.com/PytLab/C-Primer-Plus/tree/master/ch04" target="_blank" rel="external">第四章 字符串和格式化输入/输出</a></li>
<li><a href="https://github.com/PytLab/C-Primer-Plus/tree/master/ch05" target="_blank" rel="external">第五章 运算符、表达式和语句</a></li>
<li><a href="https://github.com/PytLab/C-Primer-Plus/tree/master/ch06" target="_blank" rel="external">第六章 C控制语句: 循环</a></li>
<li><a href="https://github.com/PytLab/C-Primer-Plus/tree/master/ch07" target="_blank" rel="external">第七章 C控制语句: 分支和跳转</a></li>
<li><a href="https://github.com/PytLab/C-Primer-Plus/tree/master/ch08" target="_blank" rel="external">第八章 字符输入/输出和输入确认</a></li>
<li><a href="https://github.com/PytLab/C-Primer-Plus/tree/master/ch09" target="_blank" rel="external">第九章 函数</a><a id="more"></a></li>
<li><a href="https://github.com/PytLab/C-Primer-Plus/tree/master/ch10" target="_blank" rel="external">第十章 数组和指针</a></li>
<li><a href="https://github.com/PytLab/C-Primer-Plus/tree/master/ch11" target="_blank" rel="external">第十一章 字符串和字符串函数</a></li>
<li><a href="https://github.com/PytLab/C-Primer-Plus/tree/master/ch12" target="_blank" rel="external">第十二章 存储类、链接和内存管理</a></li>
<li><a href="https://github.com/PytLab/C-Primer-Plus/tree/master/ch13" target="_blank" rel="external">第十三章 文件输入/输出</a></li>
<li><a href="https://github.com/PytLab/C-Primer-Plus/tree/master/ch14" target="_blank" rel="external">第十四章 结构和其他数据形式</a></li>
<li><a href="https://github.com/PytLab/C-Primer-Plus/tree/master/ch15" target="_blank" rel="external">第十五章 位操作</a></li>
<li><a href="https://github.com/PytLab/C-Primer-Plus/tree/master/ch16" target="_blank" rel="external">第十六章 C预处理器和C库</a></li>
<li><a href="https://github.com/PytLab/C-Primer-Plus/tree/master/ch17" target="_blank" rel="external">第十七章 高级数据表示</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 代码作品 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C </tag>
            
            <tag> GitHub </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[动力学模型添加QuasiEquilibriumSolver]]></title>
      <url>http://pytlab.github.io/2015/05/17/%E5%8A%A8%E5%8A%9B%E5%AD%A6%E6%A8%A1%E5%9E%8B%E6%B7%BB%E5%8A%A0QuasiEquilibriumSolver/</url>
      <content type="html"><![CDATA[<p>在用sympy符号运算将动力学模型重新实现一遍以后，出了能进行latex输出等其他好处外，最初使用符号运算的目的是符号求解敏感度 $X_{TRC}$的值，不过由于完全用solve暴力解析求解稳态覆盖度，稍微复杂点的机理就会计算很久。于是我打算用平衡态近似来进行求解，并且写完平衡态solver后不仅仅是求$X_{TRC}$，单独用QuasiEquilibriumSolver求解动力学模型也是可以的。</p>
<p>为了避免直接用sympy.solve()函数直接求解，分析了平衡态近似的求解方法后，自己用python先对求解过程进行了一下”预处理”，这样从一定程度上减小了对solve()依赖。由于这部分还是有点麻烦的，所以写在这里记录下来，方便自己以及其他人学习和改进。</p>
<p>由于平衡态近似求解的方法还是比较单一的，大概过程就是在决定Rate Determining Step后，通过联立其他基元反应的平衡条件，也就是$\prod_{j} \theta_{i,j}^{-} \prod_{j} p_{i,j}^{-} =K_{i}\prod_{j} \theta_{i,j}^{+}\prod_{j} p_{i,j}^{+}$用$\theta^{*}$将其他的$\theta_{i}$表示出来，在回代到归一化条件中$\sum_{i}{\theta_{i}} = 1$,将$\theta^{*}$的表达式求出来，然后分别回代求出不同中间态的覆盖度。<br>计算方法很简单，但是这里涉及到对sympy.Symbol对象的引用和substitution以及后面基元反应的特殊情况，所以写起来略复杂。下面以甲酸裂解的一条路径的基元反应为例说明一下。</p>
]]></content>
      
        <categories>
            
            <category> 学术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> kinetic model </tag>
            
            <tag> kinetics </tag>
            
            <tag> catalysis </tag>
            
            <tag> chemistry </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[动力学模型使用Multiple-Thread]]></title>
      <url>http://pytlab.github.io/2015/04/18/%E5%8A%A8%E5%8A%9B%E5%AD%A6%E6%A8%A1%E5%9E%8B%E4%BD%BF%E7%94%A8Multiple-Thread/</url>
      <content type="html"><![CDATA[<p>这两天想学习下优化代码，既然手底下有自己写完的动力学代码，那正好可以拿着练手。按我现在的认识程度，能对现在写好的动力学代码优化提升效率的方法除了改进算法外，单纯在编程方面一个是<strong>使用多线程并行</strong>，一个是<strong>用c api把循环部分重写</strong>。<br>把python多线程的一点点皮毛看了看就现学现卖了下。<br>把迭代的部分看了看，每步迭代里面都不是各自独立不相关的运算，真心不能给每个部分的运算分配子线程。在整个动力学模型里面最适合用多线程的地方就是作图了，因为作图中的阴影以及循环添加注释是可以分别分配子线程来进行的。于是我就把plotter里面画图的部分改了下:<br>分别添加了两个<code>threading.Thread</code>的子类<code>ShadowThread</code>，<code>NoteThread</code>用来实例化阴影和添加注释的子进程。</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShadowThread</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">    <span class="string">"Sub-class of Thread class to create threads to plot shadows."</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, args)</span>:</span></div><div class="line">        threading.Thread.__init__(self)</div><div class="line">        self.func = func</div><div class="line">        self.args = args</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        apply(self.func, self.args)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoteThread</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">    <span class="string">"Sub-class of Thread class to add notes to line."</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, args)</span>:</span></div><div class="line">        threading.Thread.__init__(self)</div><div class="line">        self.func = func</div><div class="line">        self.args = args</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        apply(self.func, self.args)</div></pre></td></tr></table></figure>
<p>然后就是在画图的代码中实例化thread子类，进行多线程。贴上添加注释部分的多线程代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#use multiple thread to add notes</span></div><div class="line">note_threads = []</div><div class="line">nstates = len(tex_state_list)</div><div class="line"></div><div class="line"><span class="keyword">for</span> pts, tex_states <span class="keyword">in</span> zip(piece_points, tex_state_list):</div><div class="line">    t = NoteThread(add_state_note, (pts, tex_states))</div><div class="line">    note_threads.append(t)</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(nstates):</div><div class="line">    note_threads[i].start()</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(nstates):</div><div class="line">    note_threads[i].join()</div></pre></td></tr></table></figure>
<p>大致过程就是循环实例化<code>thread</code>子类，然后收集到list中，在开始线程执行，最后依次用<code>join()</code>方法检验线程池中的线程是否结束，没有结束就阻塞直到线程结束，如果结束则跳转执行下一个线程的<code>join</code>函数。从而达到阻塞进程直到线程执行完毕的效果。</p>
]]></content>
      
        <categories>
            
            <category> 学术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> kinetic model </tag>
            
            <tag> Kynetix </tag>
            
            <tag> catalysis </tag>
            
            <tag> chemistry </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C Notes -- 内存管理]]></title>
      <url>http://pytlab.github.io/2015/04/13/C-Notes--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<p>在这里把C中有关内存管理的部分稍微总结下，方便以后回头浏览复习。</p>
<a id="more"></a>
<p>用于存储数据的内存可用 <strong>存储时期</strong>、<strong>作用域</strong>、<strong>链接</strong> 来表示。</p>
<p>存储时期：分为 <strong>静态的</strong>、<strong>自动的</strong>、<strong>分配的</strong></p>
<ul>
<li><strong>静态</strong>：内存在程序开始执行时被分配，并在程序运行是一致存在。相对应的是静态内存，所需静态内存在编译时就已经决定了，静态数据在程序载入内存的时候也被载入了内存。</li>
<li><strong>自动</strong>：变量在内存在程序执行到该变量定义所在的代码块时开始分配，退出代码块时释放。对应的是自动内存，在程序运行时为自动变量分配内存和释放内存，自动变量使用的内存数量会不断变化，可以把自动内存堪称是一个可重写的工作区。</li>
<li><strong>分配</strong>：通过<code>malloc()</code>,<code>free()</code>分配和释放。对应的是分配的内存，这种内存数量也会增加或减少，但是这个过程是程序中调用函数控制的，不是自动发生的。</li>
</ul>
<p>作用域决定哪一部分程序可以访问该变量，或者说该变量对程序的哪部分可见。有文件作用域和代码块作用域。</p>
<p>链接描述了变量对其他文件中的程序是否可见。有外部链接，内部链接，和空连接。</p>
<p>5种存储类：<strong>自动</strong>，<strong>寄存器</strong>，<strong>静态</strong>、<strong>空链接，静态</strong>、<strong>内部链接</strong>，<strong>静态、外部链接</strong>。</p>
<p>这里需要强调的是<strong>字符串常量是属于静态存储类。即在一个函数中使用的字符串常量，在整个运行中只存储一次</strong>。<br>整个引号中的内容作为指向该字符串存储位置的指针，也就是说<strong>字符串常量本身是个指针</strong>。</p>
<p>大概梳理下通过数组形式初始化字符串的过程：<br>被引用的字符串存储在可执行文件的数据段部分，当程序被加载到内存的时候，字符串常量也被加载到内存中。被引用的字符串就存储在静态存储区了，然后程序执行的时候为数组分配内存，把字符串内容复制到数组中。</p>
<p>我自己写了个小函数来验证一下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_s</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span> name[] = <span class="string">"shaozhengjiang"</span>;</div><div class="line">	<span class="keyword">char</span> * pt;</div><div class="line"></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"const address: %p\narray address: %p\n"</span>, </div><div class="line">		   &amp;<span class="string">"shaozhengjiang"</span>, name); <span class="comment">//字符串常量</span></div><div class="line">	show_s();</div><div class="line"></div><div class="line">    <span class="comment">//试图通过指向字符串常量的指针改变字符串的值</span></div><div class="line">	pt = <span class="string">"shaozhengjiang"</span>;</div><div class="line">	*(pt + <span class="number">1</span>) = <span class="string">'l'</span>;</div><div class="line">	<span class="built_in">puts</span>(<span class="string">"string after changed: "</span>);</div><div class="line">	<span class="built_in">puts</span>(pt);</div><div class="line">	<span class="comment">//程序崩溃</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_s</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;   <span class="comment">//查看字符串常量的地址是不是相同</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"const address in other function: %p\n"</span>, &amp;<span class="string">"shaozhengjiang"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译执行结果，<br><img src="http://ipytlab.com/wp-content/uploads/2015/04/QQ截图20150413221708.gif" alt=""></p>
<p>可见，两个函数中的字符串常量的地址是相同的都是<01195858>，也就验证了上面的那个过程，字符串常量属于静态存储类，在程序加载到内存的时候字符串也存入内存，值在程序运行时保持。</01195858></p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C </tag>
            
            <tag> Notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C Notes -- 指针和多维数组]]></title>
      <url>http://pytlab.github.io/2015/04/09/C-Notes--%E6%8C%87%E9%92%88%E5%92%8C%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<p>这个地方在看书的时候有点绕，花了点时间顺了顺思路，大概记一下。<br>先声明个二维数组：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> zippo[<span class="number">2</span>][<span class="number">2</span>]; <span class="comment">//整数数组的数组</span></div></pre></td></tr></table></figure></p>
<p>之所以被绕进去是因为下面两点：</p>
<p>把上面两点合起来看的话，就有：<br><code>zippo == &amp;zippo</code><br><code>zippo[0] == &amp;zippo[0][0]</code><br>也就是有：<br><code>zippo[0] == &amp;zippo[0] //zippo[0]存的是自己的地址??</code><br><code>&amp;zippo[0] == &amp;zippo[0][0] //两个不同值的地址竟然一样??</code><br>我就是在这里绕进去了，囧～<br>自己写了个小函数测试下：</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> zippo[<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;;</div><div class="line">	<span class="comment">//二维数组首地址和第一维数组首地址相同</span></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"zippo = %p\n"</span>, zippo);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"&amp;zippo[0] = %p\n"</span>, &amp;zippo[<span class="number">0</span>]);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"zippo[0] = %p\n"</span>, zippo[<span class="number">0</span>]);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"&amp;zippo[0][0] = %p\n\n"</span>, &amp;zippo[<span class="number">0</span>][<span class="number">0</span>]);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"*&amp;zippo[0] = %p\n"</span>, *&amp;zippo[<span class="number">0</span>]);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"*&amp;zippo[0][0] = %d\n\n"</span>, *&amp;zippo[<span class="number">0</span>][<span class="number">0</span>]);</div><div class="line"></div><div class="line">	<span class="comment">//看看第一维第二个和第二维第一个地址是否相同</span></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"&amp;zippo[1] = %p\n"</span>, &amp;zippo[<span class="number">1</span>]);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"&amp;zippo[1][0] = %p\n"</span>, &amp;zippo[<span class="number">1</span>][<span class="number">0</span>]);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译运行结果：<br><img src="http://ipytlab.com/wp-content/uploads/2015/04/ndarray_test.gif" alt=""><br>没出意外，就是想的这样。</p>
<p>为什么呢???<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">printf</span>(<span class="string">"*&amp;zippo[0] = %p\n"</span>, *&amp;zippo[<span class="number">0</span>]);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"*&amp;zippo[0][0] = %d\n\n"</span>, *&amp;zippo[<span class="number">0</span>][<span class="number">0</span>]);</div></pre></td></tr></table></figure></p>
<p>上面这两行代码让我意识到，为什么地址相同的变量，值却不同？恍然大悟啊我去，真相原来是这样的：<br><strong>很多计算机都是以字节编地址对象的地址通常指的是其<strong>首字节</strong>的地址。</strong><br>首字节，<br>首字节！<br>是我没把这里理解好，其实取址运算符和指针的值都是存储的变量的<strong>首字节的值(十六进制)。<br>随便画了张，随便看看吧～<br><img src="http://ipytlab.com/wp-content/uploads/2015/04/neicun.gif" alt=""><br>首字节相同相同那太正常了啊喂～请嘲笑我的智商吧～～～</strong></p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C </tag>
            
            <tag> Notes </tag>
            
            <tag> 指针 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C Notes -- 保护数组内容]]></title>
      <url>http://pytlab.github.io/2015/04/09/C-Notes--%E4%BF%9D%E6%8A%A4%E6%95%B0%E7%BB%84%E5%86%85%E5%AE%B9/</url>
      <content type="html"><![CDATA[<p>在C语言中，函数处理数组的时候，传递的是指向数组的指针。被调用函数接受数组指针后通过指针对数组进行操作，但是这样很容易不小心修改了数组本身的数值。这时候，利用const修饰符可以做到保护数组内容的效果。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ar[], <span class="keyword">int</span> n)</span> <span class="comment">/*函数原型*/</span></span></div></pre></td></tr></table></figure></p>
<p>这个原型声明是告诉编译器，函数应当吧ar所指向的数组作为一个包含常量数据的数组对待，也就是指针ar是一个常量指针(指向常量的指针)。</p>
<p>之所以在这里记录下这个是用来区分下普通指针和常量指针。<br><code>const</code>关键字可以创建数组常量，指针常量，指向常量的指针。<br>指针：</p>
<ul>
<li><p>普通指针，指向变量的指针</p>
</li>
<li><p>常量指针，指向常量的指针</p>
</li>
</ul>
<p><strong>常量指针可以指向常量和变量，而且被指向的变量的值不能修改；<br>变量指针只能指向变量。</strong></p>
<a id="more"></a>
<p>自己写了个小函数大概测试了下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> arv[<span class="number">5</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</div><div class="line">	<span class="keyword">const</span> <span class="keyword">int</span> arc[<span class="number">5</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</div><div class="line">	<span class="keyword">int</span> * pv1, * pv2;  <span class="comment">//普通指针</span></div><div class="line">	<span class="keyword">const</span> <span class="keyword">int</span> * pc1, * pc2;  <span class="comment">//常量指针</span></div><div class="line"></div><div class="line">	pv1 = arv; <span class="comment">//普通指针指向非常量数组首地址</span></div><div class="line">	pc1 = arv; <span class="comment">//常量指针指向非常量数组首地址</span></div><div class="line"></div><div class="line">	<span class="comment">//尝试改变被指向的数值</span></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"ordinary pointer: \n"</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"before: %d\n"</span>, *pv1);</div><div class="line">	*pv1 += <span class="number">1</span>;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"after: %d\n"</span>, *pv1);</div><div class="line"></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"const pointer: \n"</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"before: %d\n"</span>, *pc1);</div><div class="line">	*pc1 += <span class="number">1</span>;  <span class="comment">//不能改变常量指针指向的数值，即使被指向的不是常量</span></div><div class="line">	            <span class="comment">//把常量指针指向的变量当成常量来对待</span></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"after: %d\n"</span>, *pc1);</div><div class="line"></div><div class="line">	pv2 = arc;  <span class="comment">//普通指针指向常量数组的首地址，不允许</span></div><div class="line">	pc2 = arc;  <span class="comment">//常量指针指向常量数组的首地址，允许</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>NB的VS在没编译前就提示了：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="assets/images/blog_img/2015-04-09-C-Notes--保护数组内容/VS.gif" alt=""></h2><p>以上均个人理解，不一定正确</p>
]]></content>
      
        <categories>
            
            <category> 学习小结 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C </tag>
            
            <tag> Notes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[动力学模型工具类–Plotter]]></title>
      <url>http://pytlab.github.io/2015/04/05/%E5%8A%A8%E5%8A%9B%E5%AD%A6%E6%A8%A1%E5%9E%8B%E5%B7%A5%E5%85%B7%E7%B1%BB%E2%80%93Plotter/</url>
      <content type="html"><![CDATA[<p>上周花了周末的时间完成了动力学模型energy profile的自动作图部分，写这个部分的主要目的是能够更加直观的查看整个动力学模型中的反应的热力学行为，也就是快速的数值可视化，通过做出来的图能够和动力学计算的结果做对比分析，方便查看吸附能、能垒、脱附能等数据。<br>此部分作图的主要实现是依赖<code>matplotlib</code>库这一面向对象的作图工具，借助numpy和scipy的数组和插值函数（我自己写写了个小的插值函数）根据输入的反应热力学数据计算出energy profile中的points，进而开启Artist Mode！虽然只是作图但是为了能够做出好看的图以及能够自动显示note等功能，这个类还是写了700行左右的python代码(包括注释和空行)。</p>
<a id="more"></a>
<p>下面来大致记录下实现的过程：</p>
<p><strong>1.插值</strong></p>
<p>好了，扯了前面这些，上点做出来的图吧(均自动生成，可选择是否显示注释/箭头和阴影)。<br>基元反应：<br><figure class="highlight sml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">'HCOOH_g</span> + <span class="number">2</span>*_s &lt;-&gt; <span class="type">H</span>-<span class="type">COOH_s</span> + *_s -&gt; <span class="type">COOH_s</span> + <span class="type">H_s'</span>,  </div><div class="line"><span class="symbol">'COOH_s</span> + *_s &lt;-&gt; <span class="type">COO</span>-<span class="type">H_s</span> + *_s -&gt; <span class="type">CO2_s</span> + <span class="type">H_s'</span>,</div><div class="line"><span class="symbol">'H_s</span> + <span class="type">H_s</span> &lt;-&gt; <span class="type">H</span>-<span class="type">H_s</span> + *_s -&gt; <span class="type">H2_g</span> + <span class="number">2</span>*_s',</div><div class="line"><span class="symbol">'CO2_s</span> -&gt; <span class="type">CO2_g</span> + *_s',</div></pre></td></tr></table></figure></p>
<p>每一步基元反应的图:<br><img src="assets/images/blog_img/2015-04-05-动力学模型工具类–Plotter/0.gif" alt=""><br><img src="assets/images/blog_img/2015-04-05-动力学模型工具类–Plotter/1.gif" alt=""><br><img src="assets/images/blog_img/2015-04-05-动力学模型工具类–Plotter/2.gif" alt=""><br><img src="assets/images/blog_img/2015-04-05-动力学模型工具类–Plotter/3.gif" alt=""><br>整条路径的energy profile：<br><img src="assets/images/blog_img/2015-04-05-动力学模型工具类–Plotter/multi_energy_diagram.jpeg" alt=""><br>[<a href="assets/images/blog_img/2015-04-05-动力学模型工具类–Plotter/multi_energy_diagram.jpeg">点击查看大图</a>]</p>
<p>另，可以根据这个动力学库单独写脚本，把不同路径的图和在一张图中，后面我会写一套针对这个动力学模型进行计算的脚本(包括各种作图），到时候添加。</p>
]]></content>
      
        <categories>
            
            <category> 学术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> kinetic model </tag>
            
            <tag> kinetics </tag>
            
            <tag> Kynetix </tag>
            
            <tag> catalysis </tag>
            
            <tag> chemistry </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PARSER中的反应方程式配平]]></title>
      <url>http://pytlab.github.io/2015/03/08/PARSER%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%BA%94%E6%96%B9%E7%A8%8B%E5%BC%8F%E9%85%8D%E5%B9%B3/</url>
      <content type="html"><![CDATA[<p>之所以把反应方程式配平拿出来写是因为之前在这段时间写完solver的过程中发现自己还是对动力学的质量作用定理理解的不够深刻，在之前的setup file中的反应方程式我默认的是以已经配平好的基元反应作为输入的，例如<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">rxn_expressions = [</div><div class="line"></div><div class="line">                <span class="string">'CO_g + *_s -&gt; CO_s'</span>,</div><div class="line">                <span class="string">'3H2_g + 6*_s -&gt; 6H_s'</span>,</div><div class="line">                <span class="string">'CO_s + *_s &lt;-&gt; C-O_s + *_s -&gt; C_s + O_s'</span>,</div><div class="line">                <span class="string">'O_s + H_s -&gt; HO_s + *_s'</span>,</div><div class="line">                <span class="string">'HO_s + H_s &lt;-&gt; H-OH_s + *_s -&gt; H2O_g + 2*_s'</span>,</div><div class="line">                <span class="string">'C_s + H_s &lt;-&gt; H-C_s + *_s -&gt; CH_s + *_s'</span>,</div><div class="line">                <span class="string">'CH_s + H_s -&gt; CH2_s + *_s'</span>,</div><div class="line">                <span class="string">'CH2_s + H_s -&gt; CH3_s + *_s'</span>,</div><div class="line">                <span class="string">'CH3_s + H_s -&gt; CH4_g + 2*_s'</span></div><div class="line">]</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>然后通过正则表达式解析反应方程式后通过集合做差集运算获得总的反应方程式。具体方法在之前的<a href="http://ipytlab.com/%e5%8a%a8%e5%8a%9b%e5%ad%a6%e6%a8%a1%e5%9e%8b%e5%b7%a5%e5%85%b7%e7%b1%bb-parser/" title="动力学模型工具类–Parser" target="_blank" rel="external"><ins datetime="2015-03-08T12:02:07+00:00">博客</ins></a>中有写：</p>
<blockquote>
<p><strong>获取总的反应方程式并检查是否守恒:</strong></p>
<p>主要是通过<code>get_total_rxn_equation()</code>方法，获取总的反应方程式的方法是利用字典和集合数据类型，通过正则表达式获取初态和终态的所有物种和相应总数的字典，然后遍历所有的基元反应获取两边的字典(包含所有物种的类型和数目)，然后将这两个字典转化成集合，进行相互两次差集的运算获取总反应的两边的物种以及每个物种的数目，最终整合成字符串以化学方程式的形式返回。如果最终的总反应方程不守恒的话则需要用户检查基元反应计量数是否正确。</p>
</blockquote>
<p>但后来通过牛顿法解稳态的时候发现解出来的覆盖度解有问题，然后一点点向回退，检查Jacobian Matrix，在检查覆盖度变化率动力学方程组，然后检查到反应速率表达式的时候发现和我手推的时候不一样！这才意识到化学计量数被我之前一直忽略了，这里我曾经有想过化学计量数和质量作用定律的关系，看来要使用质量作用定律还是要按照基元反应来写，因为我在后面计算反应所率的时候会按照前面的化学计量数来统一吸附物的覆盖率变化的。反而在最开始写基元反应表达式的时候引入化学计量数会使后面的反应速率表达式错误。所以输入文件中的基元反应表达式必须写成如下这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">rxn_expressions = [</div><div class="line"></div><div class="line">                <span class="string">'CO_g + *_s -&gt; CO_s'</span>,</div><div class="line">                <span class="string">'H2_g + 2*_s -&gt; 2H_s'</span>,</div><div class="line">                <span class="string">'CO_s + *_s &lt;-&gt; C-O_s + *_s -&gt; C_s + O_s'</span>,</div><div class="line">                <span class="string">'O_s + H_s -&gt; HO_s + *_s'</span>,</div><div class="line">                <span class="string">'HO_s + H_s &lt;-&gt; H-OH_s + *_s -&gt; H2O_g + 2*_s'</span>,</div><div class="line">                <span class="string">'C_s + H_s &lt;-&gt; H-C_s + *_s -&gt; CH_s + *_s'</span>,</div><div class="line">                <span class="string">'CH_s + H_s -&gt; CH2_s + *_s'</span>,</div><div class="line">                <span class="string">'CH2_s + H_s -&gt; CH3_s + *_s'</span>,</div><div class="line">                <span class="string">'CH3_s + H_s -&gt; CH4_g + 2*_s'</span></div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>好，那么问题来了。怎么配平？？这里我搁置了两天，一直在想该怎么写能让程序自动把这些基元反应配平，然后求出总的反应表达式，自己也尝试了很多方法，我尝试修改之前的通过集合运算的方法还是解决不了。正在想放弃这一功能的时候，和师兄交流，师兄是用matlab写代码的，由于矩阵是matlab的基本数据类型，必然很多时候会用矩阵的思想，他说貌似可以用类似矩阵消元的方式来配平。忽然就感觉这个问题有戏，就在纸上随便画了两个矩阵，看了看，我去，可以通过求解系数矩阵的零空间的基的方式把配平系数求出来，系数出来了，配平什么的就是自然而然的了。然后就着手把这个问题写完了，实现的方法(以CO氧化的反应为例)：</p>
<p>基元反应方程式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">rxn_expressions = [</div><div class="line"></div><div class="line">               <span class="string">'*_s + CO_g -&gt; CO*'</span>, </div><div class="line">               <span class="string">'2*_s + O2_g &lt;-&gt; O-O* + *_s -&gt; 2O*'</span>,</div><div class="line">               <span class="string">'CO* +  O* &lt;-&gt; O-CO* + * -&gt; CO2_g + 2*'</span>,</div><div class="line"></div><div class="line">                   ]</div></pre></td></tr></table></figure></p>
<p>获取此反应的系数矩阵，在这里要把吸附物和气体分子分开，因为最后是要把吸附物的系数全部变为0的。<br>吸附物顺序：$(*,CO^{*}, O^{*}), 气体顺序：( CO, O_{2}, CO_{2})</p>
<p>设$A$为吸附物系数矩阵，$B$为气体系数矩阵，</p>
<p>吸附物系数矩阵<br>$$<br>A = \left[\begin{matrix}<br>     1 &amp; -1 &amp; 0 \\<br>     2 &amp; 0 &amp; -2 \\<br>    -2 &amp; 1 &amp; 1<br>    \end{matrix} \right]<br>$$<br>气体分子系数矩阵<br>$$<br>B = \left[\begin{matrix}<br>     1 &amp; -1 &amp; 0 \\<br>     2 &amp; 0 &amp; -2 \\<br>    -2 &amp; 1 &amp; 1<br>    \end{matrix} \right]<br>$$</p>
<p>求矩阵$A$的转置的零空间的基，即$A^{T}\bullet x = 0$<br>将获取的零空间的基转化成整数形式后再左乘矩阵$B$，也就是( $x\bullet B$ )变得到了配平系数向量了.<br>由于python没有像matlab那样的直接有null函数求零空间的基的函数，利用numpy的函数有写了个：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">null</span><span class="params">(A, eps=<span class="number">1e-10</span>)</span>:</span></div><div class="line">    <span class="string">"get null space of transposition of site_matrix"</span></div><div class="line">    u,s,vh = np.linalg.svd(A,full_matrices=<span class="number">1</span>,compute_uv=<span class="number">1</span>)</div><div class="line">    null_space = np.compress(s &lt;= eps, vh, axis=<span class="number">0</span>)</div><div class="line">    <span class="keyword">return</span> null_space.T</div></pre></td></tr></table></figure></p>
<p>代买实现分别是写了两个方法先获取矩阵，然后在进行矩阵运算，在最后也进行了守恒的检测，贴上来：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_stoichiometry_matrices</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Go through elementary_rxns_list,</div><div class="line">    return sites stoichiometry matrix and gas stoichiometry matrix.</div><div class="line">    """</div><div class="line">    sites_names = [<span class="string">'*_'</span>+site_name </div><div class="line">                   <span class="keyword">for</span> site_name <span class="keyword">in</span> self._owner.site_names] + \</div><div class="line">                   list(self._owner.adsorbate_names)</div><div class="line">    gas_names = list(self._owner.gas_names)</div><div class="line">    <span class="comment">#initialize matrices</span></div><div class="line">    m = len(self._owner.elementary_rxns_list)</div><div class="line">    n_s, n_g = len(sites_names), len(gas_names)</div><div class="line">    site_matrix, gas_matrix = np.matrix(np.zeros((m, n_s))),\</div><div class="line">                              np.matrix(np.zeros((m, n_g)))</div><div class="line">    <span class="comment">#go through all elementary equations</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m):</div><div class="line">        states_list = self._owner.elementary_rxns_list[i]</div><div class="line">        <span class="keyword">for</span> sp <span class="keyword">in</span> states_list[<span class="number">0</span>]:  <span class="comment">#for initial state</span></div><div class="line">            stoichiometry, sp_name = self.split_species(sp)</div><div class="line">            <span class="keyword">if</span> sp_name <span class="keyword">in</span> sites_names:</div><div class="line">                j = sites_names.index(sp_name)</div><div class="line">                site_matrix[i, j] += stoichiometry</div><div class="line">            <span class="keyword">if</span> sp_name <span class="keyword">in</span> gas_names:</div><div class="line">                j = gas_names.index(sp_name)</div><div class="line">                gas_matrix[i, j] += stoichiometry</div><div class="line">        <span class="keyword">for</span> sp <span class="keyword">in</span> states_list[<span class="number">-1</span>]:  <span class="comment">#for final state</span></div><div class="line">            stoichiometry, sp_name = self.split_species(sp)</div><div class="line">            <span class="keyword">if</span> sp_name <span class="keyword">in</span> sites_names:</div><div class="line">                j = sites_names.index(sp_name)</div><div class="line">                site_matrix[i, j] -= stoichiometry</div><div class="line">            <span class="keyword">if</span> sp_name <span class="keyword">in</span> gas_names:</div><div class="line">                j = gas_names.index(sp_name)</div><div class="line">                gas_matrix[i, j] -= stoichiometry</div><div class="line"></div><div class="line">    <span class="keyword">return</span> site_matrix, gas_matrix</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_total_rxn_equation</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">"Get total reaction expression of the kinetic model."</span></div><div class="line">    site_matrix, gas_matrix = self.get_stoichiometry_matrices()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">null</span><span class="params">(A, eps=<span class="number">1e-10</span>)</span>:</span></div><div class="line">        <span class="string">"get null space of transposition of site_matrix"</span></div><div class="line">        u,s,vh = np.linalg.svd(A,full_matrices=<span class="number">1</span>,compute_uv=<span class="number">1</span>)</div><div class="line">        null_space = np.compress(s &lt;= eps, vh, axis=<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> null_space.T</div><div class="line">    x = null(site_matrix.T)  <span class="comment">#basis of null space</span></div><div class="line">    x = map(abs, x.T.tolist()[<span class="number">0</span>])</div><div class="line">    <span class="comment">#convert entries of x to integer</span></div><div class="line">    min_x = min(x)</div><div class="line">    x = [round(i/min_x, <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> x]</div><div class="line">    setattr(self._owner, <span class="string">'trim_coeffients'</span>, x)</div><div class="line">    x = np.matrix(x)</div><div class="line">    total_coefficients = (x*gas_matrix).tolist()[<span class="number">0</span>]</div><div class="line">    <span class="comment">#create total rxn expression</span></div><div class="line">    reactants_list, products_list = [], []</div><div class="line">    <span class="keyword">for</span> sp_name <span class="keyword">in</span> self._owner.gas_names:</div><div class="line">        idx = self._owner.gas_names.index(sp_name)</div><div class="line">        coefficient = total_coefficients[idx]</div><div class="line">        <span class="keyword">if</span> coefficient &lt; <span class="number">0</span>: <span class="comment">#for products</span></div><div class="line">            coefficient = abs(int(coefficient))</div><div class="line">            <span class="keyword">if</span> coefficient == <span class="number">1</span>:</div><div class="line">                coefficient = <span class="string">''</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                coefficient = str(coefficient)</div><div class="line">            products_list.append(coefficient + sp_name)</div><div class="line">        <span class="keyword">else</span>: <span class="comment">#for reactants</span></div><div class="line">            coefficient = int(coefficient)</div><div class="line">            <span class="keyword">if</span> coefficient == <span class="number">1</span>:</div><div class="line">                coefficient = <span class="string">''</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                coefficient = str(coefficient)</div><div class="line">            reactants_list.append(coefficient + sp_name)</div><div class="line">    reactants_expr = <span class="string">' + '</span>.join(reactants_list)</div><div class="line">    products_expr = <span class="string">' + '</span>.join(products_list)</div><div class="line">    total_rxn_equation = reactants_expr + <span class="string">' -&gt; '</span> + products_expr</div><div class="line"></div><div class="line">    <span class="comment">#check conservation</span></div><div class="line">    states_dict = self.parse_single_elementary_rxn(total_rxn_equation)[<span class="number">0</span>]</div><div class="line">    check_result = self.check_conservation(states_dict)</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> check_result:</div><div class="line">        setattr(self._owner, <span class="string">'total_rxn_equation'</span>, total_rxn_equation)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">if</span> check_result == <span class="string">'mass_nonconservative'</span>:</div><div class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Mass of total equation \''</span>+</div><div class="line">                        total_rxn_equation+<span class="string">'\' is not conservative!'</span>)</div><div class="line">        <span class="keyword">if</span> check_result == <span class="string">'site_nonconservative'</span>:</div><div class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Site of total equation \''</span>+</div><div class="line">                        total_rxn_equation+<span class="string">'\' is not conservative!'</span>)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> total_rxn_equation</div></pre></td></tr></table></figure></p>
<p>效果图：<br><img src="2015/03/08/PARSER中的反应方程式配平/QQ截图20150308205550.gif" alt=""><br>→_→欲拯救世界必先学线性代数</p>
<p>顺便把之前那个化学式配平的代码也贴上来吧，虽然以后再也用不到了，留个纪念也不错。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_total_rxn_equation_orig</span><span class="params">(self, elementary_rxns_list)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Analyse elementary_rxns_list, get total_rxn_equation and </div><div class="line">    check the conservation of it, set total_rxn_equation as attr of model.</div><div class="line">    """</div><div class="line">    reactants_dict = &#123;&#125;</div><div class="line">    products_dict = &#123;&#125;</div><div class="line">    <span class="keyword">for</span> equation_list <span class="keyword">in</span> elementary_rxns_list:</div><div class="line">        <span class="comment">#for reactants</span></div><div class="line">        <span class="keyword">for</span> reactant <span class="keyword">in</span> equation_list[<span class="number">0</span>]:</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="string">'*'</span> <span class="keyword">in</span> reactant:</div><div class="line">                m = self._owner.regex_dict[<span class="string">'species'</span>][<span class="number">0</span>].search(reactant)</div><div class="line">                <span class="keyword">if</span> m.group(<span class="number">1</span>):</div><div class="line">                    stoichiometry = float(m.group(<span class="number">1</span>))</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    stoichiometry = <span class="number">1.0</span></div><div class="line">                species_name = m.group(<span class="number">2</span>)</div><div class="line">                site = m.group(<span class="number">3</span>)</div><div class="line">                total_name = species_name + <span class="string">'_'</span> + site</div><div class="line">            <span class="keyword">else</span>: <span class="comment">#for free site</span></div><div class="line">                m = self._owner.regex_dict[<span class="string">'empty_site'</span>][<span class="number">0</span>].search(reactant)</div><div class="line">                <span class="keyword">if</span> m.group(<span class="number">1</span>):</div><div class="line">                    stoichiometry = float(m.group(<span class="number">1</span>))</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    stoichiometry = <span class="number">1.0</span></div><div class="line">                site_name = m.group(<span class="number">2</span>)</div><div class="line">                total_name = <span class="string">'*_'</span> + site_name</div><div class="line">            <span class="keyword">if</span> reactants_dict.has_key(total_name):</div><div class="line">                reactants_dict[total_name] += stoichiometry</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                reactants_dict.setdefault(total_name, stoichiometry)</div><div class="line">        <span class="comment">#for products</span></div><div class="line">        <span class="keyword">for</span> product <span class="keyword">in</span> equation_list[<span class="number">-1</span>]:</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="string">'*'</span> <span class="keyword">in</span> product:</div><div class="line">                m = self._owner.regex_dict[<span class="string">'species'</span>][<span class="number">0</span>].search(product)</div><div class="line">                <span class="keyword">if</span> m.group(<span class="number">1</span>):</div><div class="line">                    stoichiometry = float(m.group(<span class="number">1</span>))</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    stoichiometry = <span class="number">1.0</span></div><div class="line">                species_name = m.group(<span class="number">2</span>)</div><div class="line">                site = m.group(<span class="number">3</span>)</div><div class="line">                total_name = species_name + <span class="string">'_'</span> + site</div><div class="line">            <span class="keyword">else</span>: <span class="comment">#for free site</span></div><div class="line">                m = self._owner.regex_dict[<span class="string">'empty_site'</span>][<span class="number">0</span>].search(product)</div><div class="line">                <span class="keyword">if</span> m.group(<span class="number">1</span>):</div><div class="line">                    stoichiometry = float(m.group(<span class="number">1</span>))</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    stoichiometry = <span class="number">1.0</span></div><div class="line">                site_name = m.group(<span class="number">2</span>)</div><div class="line">                total_name = <span class="string">'*_'</span> + site_name</div><div class="line">            <span class="keyword">if</span> products_dict.has_key(total_name):</div><div class="line">                products_dict[total_name] += stoichiometry</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                products_dict.setdefault(total_name, stoichiometry)</div><div class="line">    <span class="comment">#return sorted(reactants_dict.items()), sorted(products_dict.items())</span></div><div class="line"></div><div class="line">    reactants_set, products_set = set(reactants_dict.items()), \</div><div class="line">                                  set(products_dict.items())</div><div class="line">    <span class="comment">#return reactants_set, products_set</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set2str</span><span class="params">(rxn_set)</span>:</span></div><div class="line">        rxn_list = []</div><div class="line">        <span class="keyword">for</span> sp_tuple <span class="keyword">in</span> rxn_set:</div><div class="line">            species_name, number = sp_tuple[<span class="number">0</span>], str(sp_tuple[<span class="number">1</span>])</div><div class="line">            <span class="keyword">if</span> number == <span class="string">'1'</span>:</div><div class="line">                number = <span class="string">''</span></div><div class="line">            sp_str = number + species_name</div><div class="line">            rxn_list.append(sp_str)</div><div class="line">        <span class="keyword">return</span> <span class="string">' + '</span>.join(rxn_list)</div><div class="line">    total_reactants_str = set2str(reactants_set - products_set)</div><div class="line">    total_products_str = set2str(products_set - reactants_set)</div><div class="line"></div><div class="line">    <span class="comment">#return total_reactants_str + ' -&gt; ' + total_products_str</span></div><div class="line">    total_rxn_equation = total_reactants_str + <span class="string">' -&gt; '</span> + total_products_str</div><div class="line"></div><div class="line">    <span class="comment">#check conservation</span></div><div class="line">    states_dict = self.parse_single_elementary_rxn(total_rxn_equation)[<span class="number">0</span>]</div><div class="line">    check_result = self.check_conservation(states_dict)</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> check_result:</div><div class="line">        setattr(self._owner, <span class="string">'total_rxn_equation'</span>, total_rxn_equation)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">if</span> check_result == <span class="string">'mass_nonconservative'</span>:</div><div class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Mass of total equation \''</span>+</div><div class="line">                        total_rxn_equation+<span class="string">'\' is not conservative!'</span>)</div><div class="line">        <span class="keyword">if</span> check_result == <span class="string">'site_nonconservative'</span>:</div><div class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Site of total equation \''</span>+</div><div class="line">                        total_rxn_equation+<span class="string">'\' is not conservative!'</span>)</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 学术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> kinetic model </tag>
            
            <tag> Kynetix </tag>
            
            <tag> catalysis </tag>
            
            <tag> chemistry </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[动力学模型工具类--Parser]]></title>
      <url>http://pytlab.github.io/2015/02/19/%E5%8A%A8%E5%8A%9B%E5%AD%A6%E6%A8%A1%E5%9E%8B%E5%B7%A5%E5%85%B7%E7%B1%BB--Parser/</url>
      <content type="html"><![CDATA[<p>这部分其实在放假前就开始写了，后面在写的过程中又添加了前面的table_maker和后面的parser的一些修修补补。在这里整体介绍下这个类的一些特性和简要实现过程。<br>这个类最初的目的还是很简单，就是解析setup file 和 input file把所有的信息全部解析到模型对象中，其中包括模型所必需的一些属性，例如吸附物，过渡态，气体，表面等信息，能量数据，形成能数据等。。。整个类的大概属性和操作在<a href="http://ipytlab.com/%e5%8a%a8%e5%8a%9b%e5%ad%a6%e6%a8%a1%e5%9e%8b%e4%bb%a3%e7%a0%81%e7%9a%84%e6%95%b4%e4%bd%93%e7%bb%84%e7%bb%87%e6%a1%86%e6%9e%b6/" title="动力学模型代码的整体组织框架" target="_blank" rel="external">UML图</a>中可以看到，其中包含一个基类<code>ParserBase</code>类，以及子类CsvParser类，在这里我只写了<code>CsvParser</code>，可以再扩展写用于其它表格的Parser，例如利用xlrd模块直接操作excel。</p>
<p><strong>解析基元反应方程式:</strong><br>在KineticModel中已经通过load()方法中遍历执行setup file后的局部变量的方式将setup file加载到了model中成为model对象的属性。在setup file中定义了一个<code>species_definitions</code>的字典类型变量，用来存储model中所有物种和位点的信息，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="string">'O_s'</span>: &#123;<span class="string">'elements'</span>: &#123;<span class="string">'O'</span>: <span class="number">1</span>&#125;,</div><div class="line">        <span class="string">'formation_energy'</span>: <span class="number">0.597</span>,</div><div class="line">        <span class="string">'frequencies'</span>: [<span class="number">359.5</span>, <span class="number">393.3</span>, <span class="number">507.0</span>],</div><div class="line">        <span class="string">'information'</span>: <span class="string">'None'</span>,</div><div class="line">        <span class="string">'name'</span>: <span class="string">'O'</span>,</div><div class="line">        <span class="string">'site'</span>: <span class="string">'s'</span>,</div><div class="line">        <span class="string">'type'</span>: <span class="string">'adsorbate'</span>&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>在前面table_maker中就是利用的这个变量的遍历生成的表格。<code>species_definitions</code>的生成我主要用了dict类型数据，分别写了几个方法来避免3重以上的循环，不然3重以上循环的代码给别人看估计要被抽了。。。<br>大致思路还是分治啦，大概介绍下分开的这几个方法的作用：</p>
<ul>
<li><code>parse_site_expression()</code>和<code>parse_species_expression()</code><br>这两个方法类似，都是解析单个物种，例如<code>&#39;2CH3_s&#39;</code>，生成关于这个物种的<code>dict</code>，例如<code>{&#39;CH3_s&#39;: {&#39;number&#39;: 2, &#39;site&#39;: &#39;s&#39;, &#39;elements&#39;: {&#39;C&#39;: 1, &#39;H&#39;:3}}}</code>, 其中化学式的匹配是通过正则表达式的方法，在model模型中分别用compile()将三个常用的正则表达式编译，并设为model对象的属性。<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#set elementary parse regex(compiled)</span></div><div class="line">self.regex_dict = &#123;&#125;</div><div class="line"></div><div class="line">states_regex = re.compile(<span class="string">r'([^\&lt;\&gt;]*)(?:\&lt;?\-\&gt;)'</span>+</div><div class="line">	                  <span class="string">r'(?:([^\&lt;\&gt;]*)(?:\&lt;?\-\&gt;))?([^\&lt;\&gt;]*)'</span>)</div><div class="line">self.regex_dict[<span class="string">'IS_TS_FS'</span>] = [states_regex, [<span class="string">'IS'</span>,<span class="string">'TS'</span>,<span class="string">'FS'</span>]]</div><div class="line"></div><div class="line">species_regex = re.compile(<span class="string">r'(\d*)([^\_\+\*\&lt;\&gt;]+)_(\w+)'</span>)</div><div class="line">self.regex_dict[<span class="string">'species'</span>] = \</div><div class="line">            [species_regex, [<span class="string">'stoichiometry'</span>,<span class="string">'name'</span>,<span class="string">'site'</span>]]</div><div class="line"></div><div class="line">site_regex = re.compile(<span class="string">r'(\d*)(?:\*\_)(\w+)'</span>)</div><div class="line">self.regex_dict[<span class="string">'empty_site'</span>] = \</div><div class="line">            [site_regex, [<span class="string">'stoichiometry'</span>, <span class="string">'site'</span>]]</div></pre></td></tr></table></figure>
</li>
</ul>
<p></p><p><em>   <code>parse_state_expression()</code><br>这个就感觉像剥洋葱啦，就是分析包含多个物种的一个状态，例如反应中的一个过渡态`’CH2-H_s + </em>_s’<code>,生成相应的字典和物种列表，也就是个</code>tuple`，例如<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="string">'sp_dict'</span>: &#123;<span class="string">'CH-H_s'</span>: &#123;<span class="string">'number'</span>: <span class="number">1</span>, </div><div class="line">                        <span class="string">'site'</span>: <span class="string">'s'</span>, </div><div class="line">                        <span class="string">'elements'</span>: &#123;<span class="string">'C'</span>: <span class="number">1</span>, <span class="string">'H'</span>: <span class="number">2</span>&#125;&#125;&#125;&#125;,</div><div class="line">             &#123;&#125;,</div><div class="line">             [<span class="string">'CH2-H_s'</span>, <span class="string">'*_s'</span>]</div></pre></td></tr></table></figure></p>
<p></p><p><em>   parse_single_elementary_rxn()<br>继续剥洋葱，这次是解析整个基元反应方程式，将一个基元反应<br>‘C_s + H_s &lt;-&gt; H-C_s + </em>_s -&gt; CH_s + *_s’<br>解析成<code>state_dict</code> 和 <code>rxn equation list的tuple</code>:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(&#123;<span class="string">'FS'</span>: &#123;<span class="string">'empty_sites_dict'</span>: &#123;<span class="string">'s'</span>: &#123;<span class="string">'number'</span>: <span class="number">1</span>, <span class="string">'type'</span>: <span class="string">'s'</span>&#125;&#125;,</div><div class="line">   <span class="string">'species_dict'</span>: &#123;<span class="string">'CH_s'</span>: &#123;<span class="string">'elements'</span>: &#123;<span class="string">'C'</span>: <span class="number">1</span>, <span class="string">'H'</span>: <span class="number">1</span>&#125;,</div><div class="line">     <span class="string">'number'</span>: <span class="number">1</span>,</div><div class="line">     <span class="string">'site'</span>: <span class="string">'s'</span>&#125;&#125;,</div><div class="line">   <span class="string">'state_expression'</span>: <span class="string">'CH_s + *_s'</span>&#125;,</div><div class="line">  <span class="string">'IS'</span>: &#123;<span class="string">'empty_sites_dict'</span>: &#123;&#125;,</div><div class="line">   <span class="string">'species_dict'</span>: &#123;<span class="string">'C_s'</span>: &#123;<span class="string">'elements'</span>: &#123;<span class="string">'C'</span>: <span class="number">1</span>&#125;, <span class="string">'number'</span>: <span class="number">1</span>, <span class="string">'site'</span>: <span class="string">'s'</span>&#125;,</div><div class="line">    <span class="string">'H_s'</span>: &#123;<span class="string">'elements'</span>: &#123;<span class="string">'H'</span>: <span class="number">1</span>&#125;, <span class="string">'number'</span>: <span class="number">1</span>, <span class="string">'site'</span>: <span class="string">'s'</span>&#125;&#125;,</div><div class="line">   <span class="string">'state_expression'</span>: <span class="string">'C_s + H_s'</span>&#125;,</div><div class="line">  <span class="string">'TS'</span>: &#123;<span class="string">'empty_sites_dict'</span>: &#123;<span class="string">'s'</span>: &#123;<span class="string">'number'</span>: <span class="number">1</span>, <span class="string">'type'</span>: <span class="string">'s'</span>&#125;&#125;,</div><div class="line">   <span class="string">'species_dict'</span>: &#123;<span class="string">'H-C_s'</span>: &#123;<span class="string">'elements'</span>: &#123;<span class="string">'C'</span>: <span class="number">1</span>, <span class="string">'H'</span>: <span class="number">1</span>&#125;,</div><div class="line">     <span class="string">'number'</span>: <span class="number">1</span>,</div><div class="line">     <span class="string">'site'</span>: <span class="string">'s'</span>&#125;&#125;,</div><div class="line">   <span class="string">'state_expression'</span>: <span class="string">'H-C_s + *_s'</span>&#125;&#125;,</div><div class="line"> [[<span class="string">'C_s'</span>, <span class="string">'H_s'</span>], [<span class="string">'H-C_s'</span>, <span class="string">'*_s'</span>], [<span class="string">'CH_s'</span>, <span class="string">'*_s'</span>]])</div></pre></td></tr></table></figure></p>
<p></p><p>*   <code>parse_elementary_rxns()</code><br>最后循环分析所有的基元反应，并将<code>gas_names, adsorbate_names, transition_state_names, elementary_rxns_list</code>赋值到model的属性中。</p>
<p></p><p></p>
<p></p><p><br><strong><font size="4">检验基元反应方程守恒:</font></strong><br>这里主要是针对每一个基元反应进行质量守恒和位点守恒进行检测。主要用的了两个方法，一个是获取反应的元素个数的dict，一个是获取位点数的dict：</p>
<p><li>对于分析元素质量守恒</li></p>
<p></p><p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_elements_num_dict</span><span class="params">(self, species_dict)</span>:</span></div><div class="line">    sum_element_dict = &#123;&#125;</div><div class="line">    <span class="keyword">for</span> sp <span class="keyword">in</span> species_dict:</div><div class="line">        sp_num = species_dict[sp][<span class="string">'number'</span>]</div><div class="line">        group = &#123;&#125;</div><div class="line">        <span class="comment">#generate a dict e.g. group = &#123;'C': 2, 'O': 2&#125;</span></div><div class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> species_dict[sp][<span class="string">'elements'</span>]:</div><div class="line">            group.setdefault(element, </div><div class="line">                species_dict[sp][<span class="string">'elements'</span>][element]*sp_num)</div><div class="line">        sum_element_dict = \</div><div class="line">                self.merge_elements_dict(sum_element_dict, group)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> sum_element_dict</div></pre></td></tr></table></figure></p>
<p>这个是分析通过解析以后的得到的state_dict来获取元素数量的dict<br>例如获取<br><code>{&#39;C_s&#39;: {&#39;elements&#39;: {&#39;C&#39;: 1}, &#39;number&#39;: 1, &#39;site&#39;: &#39;s&#39;},
 &#39;CO_s&#39;: {&#39;elements&#39;: {&#39;C&#39;: 1, &#39;O&#39;: 1}, &#39;number&#39;: 2, &#39;site&#39;: &#39;s&#39;}}</code><br>得到<br><code>{&#39;C&#39;: 2, &#39;O&#39;: 1}</code></p>
<p><li>对于分析位点守恒</li></p>
<p></p><p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_total_site_dict</span><span class="params">(self, state_dict)</span>:</span></div><div class="line">    total_site_dict = &#123;&#125;</div><div class="line">    <span class="keyword">if</span> state_dict[<span class="string">'empty_sites_dict'</span>]:</div><div class="line">        <span class="keyword">for</span> empty_site <span class="keyword">in</span> state_dict[<span class="string">'empty_sites_dict'</span>]:</div><div class="line">            total_site_dict.setdefault(empty_site, </div><div class="line">                state_dict[<span class="string">'empty_sites_dict'</span>][empty_site][<span class="string">'number'</span>])</div><div class="line"></div><div class="line">    <span class="comment">#get site number from species dict</span></div><div class="line">    <span class="keyword">for</span> species <span class="keyword">in</span> state_dict[<span class="string">'species_dict'</span>]:</div><div class="line">        site = state_dict[<span class="string">'species_dict'</span>][species][<span class="string">'site'</span>]</div><div class="line">        <span class="keyword">if</span> site == <span class="string">'g'</span>: <span class="comment">#neglect gas site when check conservation</span></div><div class="line">            <span class="keyword">continue</span></div><div class="line">        number = state_dict[<span class="string">'species_dict'</span>][species][<span class="string">'number'</span>]</div><div class="line">        <span class="keyword">if</span> site <span class="keyword">in</span> total_site_dict:</div><div class="line">            total_site_dict[site] += number</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            total_site_dict.setdefault(site, number)</div><div class="line">    <span class="keyword">return</span> total_site_dict</div></pre></td></tr></table></figure></p>
<p>这个是同时分析空位和吸附物中来获取总的吸附位点的数量。</p>
<p></p><p></p>
<p></p><p><br><strong><font size="4">获取总的反应方程式并检查是否守恒:</font></strong><br>这一部分一开始在写parser的时候没想写，昨天在奶奶家把parser的获取数据并计算形成能的部分写完以后闲着没事就写了，写完了才发现，这个是非常重要的还！主要是通过<code>get_total_rxn_equation()</code>方法，获取总的反应方程式的方法是利用字典和集合数据类型，通过正则表达式获取初态和终态的所有物种和相应总数的字典，然后遍历所有的基元反应获取两边的字典(包含所有物种的类型和数目)，然后将这两个字典转化成集合，进行相互两次差集的运算获取总反应的两边的物种以及每个物种的数目，最终整合成字符串以化学方程式的形式返回。如果最终的总反应方程不守恒的话则需要用户检查基元反应计量数是否正确。<br>这部分代码贴上来有点占篇幅，有兴趣的可以下载源码。</p>
<p></p><p></p>
<p></p><p><br><strong><font size="4">计算 generalized formation energy 等数据:</font></strong><br>这一部分是写在CsvParser的类方法，主要工作是分析由table_maker生成的表格中的DFT_energy这一列数据，然后生成相应的generalized formation energy.最后把formation energy，frequencies， information的数据添加到species_definitions相应的key中。以便后面计算的时候获取能量数据。<br>generalized formation energy要相对于共同的参考能量:</p>
<p>[latex]E<em>{i} =U</em>{i}-\sum<em>{j}^{}{n</em>{j}R_{j}} [/latex]</p>
<p>其中[latex]E<em>{i} [/latex]是物种i的 generalized formation energy， [latex]U</em>{i}[/latex]是物种i的初始DFT能量，[latex]n<em>{j}[/latex]为是原子j在物种i中的数目，[latex]R</em>{j}[/latex]<br>为原子j的参考能量。<br>实现代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_data</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Parse input file, add data e.g. formation energy, </div><div class="line">    frequencies, information, to _owner.species_definition </div><div class="line">    and set corresponding dict as model's attrs.</div><div class="line">    """</div><div class="line">    file_obj = open(<span class="string">'./energy.csv'</span>, <span class="string">'rU'</span>)</div><div class="line">    file_obj.readline()</div><div class="line">    <span class="comment">#formation_energy_dict, frequencies_dict = &#123;&#125;, &#123;&#125;</span></div><div class="line">    <span class="keyword">for</span> line_str <span class="keyword">in</span> file_obj:</div><div class="line">        line_list = line_str.strip(<span class="string">'\n'</span>).split(<span class="string">','</span>)</div><div class="line">        site_name, species_name, formation_energy,\</div><div class="line">                   frequencies, information =\</div><div class="line">        line_list[<span class="number">1</span>], line_list[<span class="number">2</span>], float(line_list[<span class="number">4</span>]),\</div><div class="line">                eval(line_list[<span class="number">5</span>].replace(<span class="string">' '</span>, <span class="string">','</span>)), line_list[<span class="number">6</span>]</div><div class="line">        <span class="comment">#get full name</span></div><div class="line">        <span class="comment">#for gas</span></div><div class="line">        <span class="keyword">if</span> site_name == <span class="string">'gas'</span>:</div><div class="line">            full_name = species_name + <span class="string">'_g'</span></div><div class="line">        <span class="comment">#for any species on site</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="comment">#get site symbol</span></div><div class="line">            <span class="keyword">for</span> site_symbol <span class="keyword">in</span> self._owner.site_names:</div><div class="line">                <span class="keyword">if</span> self._owner.species_definitions[site_symbol]\</div><div class="line">                    [<span class="string">'site_name'</span>] == site_name:</div><div class="line">                    <span class="keyword">break</span></div><div class="line">            <span class="keyword">if</span> species_name == <span class="string">'slab'</span>:</div><div class="line">                full_name = site_symbol</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                full_name = species_name + <span class="string">'_'</span> + site_symbol</div><div class="line">        <span class="comment">#update _owner.species_definition</span></div><div class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> [<span class="string">'formation_energy'</span>, <span class="string">'frequencies'</span>, <span class="string">'information'</span>]:</div><div class="line">            <span class="comment">#print eval(key)</span></div><div class="line">            self._owner.species_definitions[full_name].\</div><div class="line">                            setdefault(key, eval(key))</div><div class="line">    file_obj.close()</div></pre></td></tr></table></figure></p>
<p><strong>解析以后的甲酸裂解的总反应方程式：</strong><br><img src="2015/02/19/动力学模型工具类--Parser/total_rxn_equation.gif" alt="甲酸裂解总反应"></p>
<p><strong>计算formation energy之前的 table:</strong><br><img src="2015/02/19/动力学模型工具类--Parser/table_before_parse.gif" alt=""></p>
<p><strong>计算formation energy之后的 table:</strong><br><img src="2015/02/19/动力学模型工具类--Parser/table_after_parse.gif" alt=""></p>
<p><strong>parse data之后的 species_definitions:</strong><br><img src="2015/02/19/动力学模型工具类--Parser/species_definition.gif" alt=""></p>
<p>———————————————————————-我是分割线——————————————————————–<br>今天是大年初一，祝所有人身体健康，工作顺利。今天红包抢的很开心，嘿嘿～</p>
]]></content>
      
        <categories>
            
            <category> 学术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> kinetic model </tag>
            
            <tag> kinetics </tag>
            
            <tag> Kynetix </tag>
            
            <tag> catalysis </tag>
            
            <tag> chemistry </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[动力学模型工具类--TableMaker]]></title>
      <url>http://pytlab.github.io/2015/02/17/%E5%8A%A8%E5%8A%9B%E5%AD%A6%E6%A8%A1%E5%9E%8B%E5%B7%A5%E5%85%B7%E7%B1%BB--TableMaker/</url>
      <content type="html"><![CDATA[<p>table_maker类本来是没有考虑到最初的模型框架中的，写到parser部分的时候在想可以根据setup file提供的基元反应化学方程式自动生成input file表格，这样方便以后使用本模型的用户在输入能量信息的时候能够根据模型的需求输入相应的能量数据，这样在输入数据的时候就避免了过多的输入或者漏掉数据的情况。<br>input file 主要形式是表格，其中header包含: </p>
<p><code>surface_name, site_name, species_name, DFT_energy, formation_energy, frequencies, infomation</code></p>
<ul>
<li><code>surface_name</code>: 是研究的表面的名字，例如’Pd’; 如果是气体，则为None</li>
<li><code>site_name</code>: 是指具体晶面，例如’111’</li>
<li><code>species_name</code>: 是指吸附在表面的物种名称，如果是表面则为slab</li>
<li><code>DFT_energy</code>: 是DFT计算出的初始能量，后面会对此能量进行处理，计算出generalized formation energy作为动力学计算的输入数据</li>
<li><code>frequencie</code>: 振动频率，用于热力学校正，以list的形式写在表格中，数目根据分子的构型3N-5 或者 3N-6个</li>
<li><code>information</code>: 数据的参考信息</li>
</ul>
<a id="more"></a>
<p>自动生成表格的前提是model必须要有具有正确格式和信息的setup file，因为此table_maker生成表格的原理是，根据setup file生成临时的动力学模型对象，利用工具中的table_maker生成此对象对应的表格。<br>在CatMap中input file使用Tab分割的，不容易查看能量数据。在此模型中，我用了csv格式文件作为输入文件，引文都好分隔符文件是可以用excel打开的，虽然用excel修改数据会造成数据精度丢失，但是有表格的话数据会有很好的可视性。修改数据的话还是建议用NotePad或者其他编辑器打开修改。<br>生成的csv表格大致如下：</p><p><br><img src="csv.gif" alt=""></p><p><br><img src="csv_excel.gif" alt=""></p>
<p>table_maker实现过程:<br>1. 还是要有一个<code>TableBase</code>类，用于生成不同的table_maker的子类。目前，这个基类主要包含一些获取于model对象中的一些变量。这些变量都是用parser解析setupfile获取的，因此若要用table_maker，必须要有parser并且对setupfile进行了正确的解析。因此在model的<code>load()</code>中一开始我是把table_maker作为和parser等工具一样通过执行setupfile后遍历局部变量的，结果在实例化parser之前先循环到了table_maker，就抛出异常了。。。因此后面我又单独写了个<code>set_table_maker()</code>方法，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_table_maker</span><span class="params">(self, maker_name)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Import table_maker and set the instance of it as attr of model </div><div class="line">    """</div><div class="line">    <span class="comment">#The 'BLACK MAGIC' is hacked from CatMap (catmap/model.py)</span></div><div class="line">    <span class="comment">#https://docs.python.org/2/library/functions.html#__import__</span></div><div class="line">    basepath = os.path.dirname(</div><div class="line">                inspect.getfile(inspect.currentframe()))</div><div class="line">    <span class="keyword">if</span> basepath <span class="keyword">not</span> <span class="keyword">in</span> sys.path:</div><div class="line">        sys.path.append(basepath)</div><div class="line">    <span class="comment">#from loggers import logger</span></div><div class="line">    _module = __import__(<span class="string">'table_makers'</span>, globals(), locals())</div><div class="line">    maker_instance = getattr(_module, maker_name)(owner=self)</div><div class="line">    setattr(self, <span class="string">'table_maker'</span>, maker_instance)</div></pre></td></tr></table></figure></p>
<p>在遍历局部变量的时候，进行了对table_maker的判断：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#ignore table maker which will be loaded after load()</span></div><div class="line"><span class="keyword">if</span> key == <span class="string">'table_maker'</span>: </div><div class="line">    setattr(self, <span class="string">'table_maker_name'</span>, locs[key])</div><div class="line">    <span class="keyword">continue</span></div></pre></td></tr></table></figure></p>
<p>方法是获取table_maker的名称(<code>string</code>)，然后在<code>load()</code>之后通过<code>set_table_maker()</code>方法对table_maker进行实例化。<br>2. csv_maker<br>这里主要包含两部分，一部分是生成初始的表格，另一部分就是更新表格。<br>生成初始表格，就是根据模型的属性生成的表格框架，也就是有物种信息但是没有能量数据以及振动频率数据，这些数据需要手动输入，输入后利用csv_maker的<code>create_new_table()</code>方法对表格进行更新，也就是计算能量生成相应的generalized formation energy数据。其中更新的mode有两种，一种是’add’，用于第一次生成generalized formation energy的情况; 另一种是’update’, 用于已经生成过formation energy，但是修改过raw_energy的情况。更新表格的代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_new_table</span><span class="params">(self, mode)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Read initial input file, calculate generalized formation energy.</div><div class="line">    Create a new input file containing </div><div class="line">    a column of generalized formation energy.</div><div class="line">    """</div><div class="line">    <span class="comment">#get old table content</span></div><div class="line">    f = open(<span class="string">'./energy.csv'</span>, <span class="string">'rU'</span>)</div><div class="line">    lines_list = f.readlines()</div><div class="line">    f.close()</div><div class="line"></div><div class="line">    content_str = <span class="string">''</span></div><div class="line"></div><div class="line">    <span class="comment">#modify header</span></div><div class="line">    header_str = lines_list[<span class="number">0</span>].strip(string.whitespace)</div><div class="line">    <span class="keyword">if</span> mode == <span class="string">'add'</span>:</div><div class="line">        header_list = header_str.split(<span class="string">','</span>)</div><div class="line">        header_list.insert(<span class="number">4</span>, <span class="string">'formation_energy'</span>)</div><div class="line">        new_header_str = <span class="string">','</span>.join(header_list) + <span class="string">'\n'</span></div><div class="line">        content_str += new_header_str</div><div class="line">    <span class="keyword">if</span> mode == <span class="string">'update'</span>:</div><div class="line">        content_str += header_str + <span class="string">'\n'</span></div><div class="line"></div><div class="line">    <span class="comment">#modify species part</span></div><div class="line">    <span class="keyword">for</span> row_str <span class="keyword">in</span> lines_list[<span class="number">1</span>:]:</div><div class="line">        new_row_str = self.get_new_row(row_str, mode=mode) + <span class="string">'\n'</span></div><div class="line">        content_str += new_row_str</div><div class="line"></div><div class="line">    <span class="comment">#create new input file</span></div><div class="line">    f = open(<span class="string">'./energy.csv'</span>, <span class="string">'w'</span>)</div><div class="line">    f.write(content_str)</div><div class="line">    f.close()</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 学术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> kinetic model </tag>
            
            <tag> kinetics </tag>
            
            <tag> Kynetix </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[自动登录小木虫并获取每日金币的Python脚本]]></title>
      <url>http://pytlab.github.io/2015/02/13/%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E5%B0%8F%E6%9C%A8%E8%99%AB%E5%B9%B6%E8%8E%B7%E5%8F%96%E6%AF%8F%E6%97%A5%E9%87%91%E5%B8%81%E7%9A%84Python%E8%84%9A%E6%9C%AC/</url>
      <content type="html"><![CDATA[<p>前段时间用<code>urllib, urllib2, cookielib</code>实现了自动登录校园网的脚本，类似发送请求的原理同样可以用在小木虫等类似的这种用PHP+MySQL实现的<a href="http://www.discuz.net/forum.php" title="discuz" target="_blank" rel="external">discuz</a>论坛上面。于是就动手开始写了。<br>写这个脚本的最初目的是懒得每天手动到小木虫网站上点击领取金币了，而且我这种经常忘记这种事情，等要用到金币的时候就后悔莫及了，那干脆用python写一个开机自动领取金币的脚本更省事。<br>对了这个脚本实际上是上个登录校园网的一个分支，也就是LoggerBase的一个子类，一开始采用OO的方式果然是对的。。。<br>看了下小木虫的领取金币的页面的代码，获取小木虫金币的方式是通过POST方式向<a href="http://emuch.net/bbs/memcp.php?action=getcredit" target="_blank" rel="external">http://emuch.net/bbs/memcp.php?action=getcredit</a>传表单信息。于是原理就可以是通过python向这个页面发送表单信息达到自动领取金币的效果。<br><a id="more"></a><br>表单信息:<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">getmode</span> = <span class="number">1</span></div><div class="line"><span class="attr">creditsubmit</span> = 领取红包</div></pre></td></tr></table></figure></p>
<p>要获取金币之前必须要做的就是登录小木虫论坛了，原理也是向表单处理页面(<a href="http://emuch.net/bbs/logging.php?action=login)发送请求.表单信息可以是：" target="_blank" rel="external">http://emuch.net/bbs/logging.php?action=login)发送请求.表单信息可以是：</a><br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">username</span> = vanillasmile</div><div class="line"><span class="attr">password</span> = ******</div><div class="line"><span class="attr">cookietime</span> = <span class="number">31536000</span></div><div class="line"><span class="attr">loginsubmit</span> = 会员登录</div></pre></td></tr></table></figure></p>
<p>在这里和登录校园网不同的是，登录小木虫有两个更多的信息要处理，一个是页面的<code>formhash</code>，这个应该是个改变的POST变量，虽然我在写这个脚本的时候这个变量一直没有变，但是后面写成之后使用脚本登录的时候我每次会记录<code>formhash</code>的值，发现这个是还是会变的，但是不知道是间隔多长时间变一次，于是就通过python抽取每次页面的<code>formhash</code>的值，然后再传递。获取HTML标签内容一开始我使用的是<code>BeautifulSoup</code>模块:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_hash_code_BSoup</span><span class="params">(hash_name, url)</span>:</span></div><div class="line">    login_page = urllib.urlopen(url).read()</div><div class="line">    login_soup = BeautifulSoup(login_page)</div><div class="line">    formhash_tag = login_soup.find(<span class="string">'input'</span>,attrs = &#123;<span class="string">'name'</span>:hash_name&#125;)</div><div class="line">    <span class="keyword">if</span> formhash_tag:</div><div class="line">    <span class="keyword">return</span> formhash_tag[<span class="string">'value'</span>]</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">	<span class="keyword">return</span></div></pre></td></tr></table></figure></p>
<p>但后来吧代码发给别人用之后才发现<code>BeatifulSoup</code>不是python的标准库，在让其他人安装的话会很麻烦，于是干脆自己写了个获取formhash的方法:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@staticmethod</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_hash_code</span><span class="params">(tag_name, response)</span>:</span></div><div class="line">    hash_regex = <span class="string">r'(&lt;input.+name=")('</span> + tag_name + <span class="string">r')(" value=")([\d\w]+)("&gt;)'</span></div><div class="line">    m = re.search(hash_regex, response)</div><div class="line">    <span class="keyword">if</span> m:</div><div class="line">    <span class="comment">#retrun tag_name, hash_code</span></div><div class="line">        <span class="keyword">return</span> m.group(<span class="number">2</span>), m.group(<span class="number">4</span>) </div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span></div></pre></td></tr></table></figure></p>
<p>获取了这个信息就可以完成登录的第一步了，登录方法和之前登录校园网的方法相同, 设置cookie，发送请求，获取请求返回内容:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">post_with_cookie</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">"post data with cookie setting, return page string and cookie tuple"</span></div><div class="line">    <span class="comment">#get formhash</span></div><div class="line">    url_login = self.url_login</div><div class="line">    response = urllib2.urlopen(url_login).read()</div><div class="line">    formhash = self.get_hash_code(<span class="string">'formhash'</span>, response)</div><div class="line">    <span class="comment">#update form_data_dict</span></div><div class="line">    self.add_form_data(&#123;<span class="string">'formhash'</span>:formhash&#125;)</div><div class="line">    <span class="comment">#set cookie</span></div><div class="line">    cj = cookielib.CookieJar()</div><div class="line">    form_data = self.form_data_dict</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        opener=urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))</div><div class="line">        urllib2.install_opener(opener)</div><div class="line">        req=urllib2.Request(url_login,urllib.urlencode(form_data))</div><div class="line">        u=urllib2.urlopen(req)</div><div class="line">        cookie_list = []</div><div class="line">        <span class="keyword">for</span> index, cookie <span class="keyword">in</span> enumerate(cj):</div><div class="line">            cookie_list.append(cookie)</div><div class="line">            <span class="keyword">return</span> u.read(), tuple(cookie_list)</div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        <span class="keyword">print</span> <span class="string">"Ooops! Failed to log in !&gt;_&lt; there may be a problem."</span></div><div class="line">        <span class="keyword">return</span></div></pre></td></tr></table></figure></p>
<p>第二个不同就是完成上面登录过程后会有小木虫的验证问题，感到幸运的是，小木虫不是用随即文字或者数字图片的验证码方式，而是通过计算并回答数学问题获取验证信息的，这个就太好办了，那就先从返回的页面中抽取问题，然后交给python计算一下，再自动将验证信息添加到form_data中最后一起发送实现登录。<br>写代码的过程中发现，其实小木虫只会计算乘法和除法，而且问题都是3、4个问题来回重复。。。<br>贴上登录小木虫的方法代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_in</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Method to pass values by POST 2 times to log in emuch.net,</div><div class="line">    return cookie tuple.</div><div class="line">    """</div><div class="line">    num1, num2, operation = <span class="number">0</span>, <span class="number">0</span>, <span class="string">''</span></div><div class="line">    qustion_regex = <span class="string">r'(\xce\xca\xcc\xe2\xa3\xba)(\d+)(.+)(\d+)'</span>+\</div><div class="line">	<span class="string">r'(\xb5\xc8\xd3\xda\xb6\xe0\xc9\xd9?)'</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span> <span class="keyword">not</span> (num1 <span class="keyword">and</span> num2 <span class="keyword">and</span> operation):</div><div class="line">        response = self.post_with_cookie()[<span class="number">0</span>]</div><div class="line">        match_obj = re.search(qustion_regex, response)</div><div class="line">        <span class="comment">#get question parts</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            num1, num2, operation = match_obj.group(<span class="number">2</span>), match_obj.group(<span class="number">4</span>),\</div><div class="line">								match_obj.group(<span class="number">3</span>)</div><div class="line">            <span class="comment">#return num1, num2, operation</span></div><div class="line">        <span class="keyword">except</span>:</div><div class="line">            <span class="comment">#print "failed to get question"</span></div><div class="line">            <span class="comment">#time.sleep(6)</span></div><div class="line">            <span class="keyword">pass</span></div><div class="line"></div><div class="line">    <span class="comment">#further log in</span></div><div class="line">    <span class="comment">#calculate verify question</span></div><div class="line">    <span class="comment">#division</span></div><div class="line">    <span class="keyword">if</span> operation == <span class="string">'\xb3\xfd\xd2\xd4'</span>:</div><div class="line">        answer = str(int(num1) / int(num2))</div><div class="line">    <span class="comment">#multiplication</span></div><div class="line">    <span class="keyword">if</span> operation == <span class="string">'\xb3\xcb\xd2\xd4'</span>:</div><div class="line">        answer = str(int(num1) * int(num2))</div><div class="line"></div><div class="line">    <span class="comment">#get formhash value</span></div><div class="line">    formhash = self.get_hash_code(<span class="string">'formhash'</span>,response)[<span class="number">1</span>]</div><div class="line">    <span class="comment">#get post_sec_hash value</span></div><div class="line">    post_sec_hash = self.get_hash_code(<span class="string">'post_sec_hash'</span>,response)[<span class="number">1</span>]</div><div class="line"></div><div class="line">    <span class="comment">#update form_data_dict</span></div><div class="line">    self.add_form_data(&#123;<span class="string">'formhash'</span>:formhash,</div><div class="line">			<span class="string">'post_sec_code'</span>:answer,</div><div class="line">			<span class="string">'post_sec_hash'</span>:post_sec_hash</div><div class="line">			&#125;)</div><div class="line"></div><div class="line">    <span class="comment">#login_response = self.post_with_cookie()</span></div><div class="line">    cookies_tup = self.post_with_cookie()[<span class="number">1</span>]</div><div class="line"></div><div class="line">    <span class="keyword">return</span> cookies_tup</div></pre></td></tr></table></figure></p>
<p>登录成功以后终于可以去实现最初目的了，获取金币(实现自动登录真的是没什么用处啊喂)。<br>获取金币也需要获取<code>formhash</code>的值，那就重复用<code>get_hash_code()</code>就好了，贴上代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_credit</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">"""get today's credit, </span></div><div class="line">       if get, return page content, else return 'have_got' and credit_num</div><div class="line">    """</div><div class="line">    <span class="comment">#get formhash value</span></div><div class="line">    req_1 = urllib2.Request(self.credit_url, </div><div class="line">				urllib.urlencode(&#123;<span class="string">'getmode'</span>:<span class="string">'1'</span>&#125;))</div><div class="line">    response_1 = urllib2.urlopen(req_1).read()</div><div class="line">    <span class="keyword">if</span> self.get_hash_code(<span class="string">'formhash'</span>, response_1):</div><div class="line">        formhash = self.get_hash_code(<span class="string">'formhash'</span>, response_1)[<span class="number">1</span>]</div><div class="line">        <span class="comment">#formhash = self.get_hash_code_BSoup('formhash', credit_url)</span></div><div class="line">        credit_form_data = &#123;<span class="string">'getmode'</span>:<span class="string">'1'</span>, <span class="string">'creditsubmit'</span>:<span class="string">'领取红包'</span>&#125;</div><div class="line">        credit_form_data[<span class="string">'formhash'</span>] = formhash</div><div class="line">        setattr(self, <span class="string">'credit_form_data'</span>, credit_form_data)</div><div class="line"></div><div class="line">        <span class="comment">#post values to get credit</span></div><div class="line">        data = urllib.urlencode(credit_form_data)</div><div class="line">        req_2 = urllib2.Request(self.credit_url, data)</div><div class="line">        response_2 = urllib2.urlopen(req_2).read()</div><div class="line">        <span class="keyword">if</span> response_2:</div><div class="line">            credit_num = self.get_credit_number(response_2)</div><div class="line">            self.log(event=<span class="string">'get_credit_succeed'</span>, credit_num=credit_num)</div><div class="line"></div><div class="line">        <span class="keyword">return</span> response_2</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="comment">#print 'got!'</span></div><div class="line">        credit_num = self.get_credit_number(</div><div class="line">			self.send_post(self.credit_url,self.form_data_dict))</div><div class="line">        self.log(event=<span class="string">'get_credit_fail'</span>, credit_num=credit_num)</div><div class="line">        <span class="keyword">return</span> <span class="string">'have_got'</span>, credit_num</div></pre></td></tr></table></figure></p>
<p>其中如果用户已经领取了今天的金币，那么便不会再返回获取金币的部分，也就是没有form部分了，我是通过判断此页面是否还会有formhash的值来判断用户是否已经领取金币。为了方便后面单独的执行脚本输出相应的信息，这个直接返回的特定字符串提供给后面的代码进行判断。上面这段代码中有一个<code>get_credit_number()</code>方法，没错我多写了个方法获取用户当前金币数，原理还是抓取页面，正则表达式匹配:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@staticmethod</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_credit_number</span><span class="params">(response)</span>:</span></div><div class="line">    <span class="comment">#regex = r'(&lt;u&gt;\xbd\xf0\xb1\xd2: )(\d\d\.\d)(&lt;/u&gt;)'</span></div><div class="line">    regex_float = <span class="string">r'(&lt;u&gt;\xbd\xf0\xb1\xd2: )(\d*\.\d+)(&lt;/u&gt;)'</span></div><div class="line">    regex_int = <span class="string">r'(&lt;u&gt;\xbd\xf0\xb1\xd2: )(\d*)(&lt;/u&gt;)'</span></div><div class="line">    m_float = re.search(regex_float, response)</div><div class="line">    m_int = re.search(regex_int, response)</div><div class="line">    <span class="keyword">if</span> m_float:</div><div class="line">        credit_num_str = m_float.group(<span class="number">2</span>)</div><div class="line">    <span class="keyword">if</span> m_int:</div><div class="line">        credit_num_str = m_int.group(<span class="number">2</span>)</div><div class="line">    <span class="keyword">return</span> credit_num_str</div></pre></td></tr></table></figure></p>
<p>最后我还是单独写了个”run_credit.py”脚本给别人直接执行使用，自动登录小木虫并获取金币。其中在后面同学用这个脚本的时候向我反映开机如果没联网会不再自动登录小木虫，于是我又在run_credit.py里面添加了检测网络连接的部分，其中包括检测是否连上无线网但是没登录以及是否联网。若连接网络失败，窗口不会消失，会不断提示用户联网，等待联网成功后自动登录。<br>emuch()函数会返回字符串信号用来判断。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">emuch</span><span class="params">(emuch_logger)</span>:</span></div><div class="line">    url = emuch_logger.url_login</div><div class="line">    <span class="comment">#chk internet connection</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        resp = urllib2.urlopen(url)</div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        <span class="keyword">return</span> <span class="string">'no_internet'</span></div><div class="line"></div><div class="line">    title_1 = emuch_logger.get_page_title(url)</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        title_2 = emuch_logger.get_page_title(<span class="string">'http://www.weibo.com/'</span>)</div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        title_2 = <span class="keyword">None</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        title_3 = emuch_logger.get_page_title(<span class="string">'http://www.baidu.com/'</span>)</div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        title_3 = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> title_1 == title_2 <span class="keyword">or</span> title_1 == title_3:</div><div class="line">        <span class="keyword">return</span> <span class="string">'need_login'</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        cookies = emuch_logger.log_in()</div><div class="line">        <span class="comment">#get credit</span></div><div class="line">        response = emuch_logger.get_credit()</div><div class="line">        <span class="comment">#check if there is a formhash tag</span></div><div class="line">        <span class="keyword">if</span> <span class="string">'have_got'</span> <span class="keyword">in</span> response:</div><div class="line">            <span class="keyword">print</span> <span class="string">'You\'ve got today\'s coin~'</span></div><div class="line">            <span class="keyword">print</span> <span class="string">'Current credit number : %s'</span> % str(response[<span class="number">1</span>])</div><div class="line">            <span class="keyword">return</span> </div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            credit_num = emuch_logger.get_credit_number(response)</div><div class="line">            <span class="keyword">print</span> <span class="string">"Today's credit -&gt; get!"</span></div><div class="line">            <span class="keyword">print</span> <span class="string">'Current credit number : %s'</span> % str(credit_num)</div><div class="line">            <span class="keyword">return</span></div></pre></td></tr></table></figure></p>
<p>后面我还添加的半夜自动下载小木虫付费资源的部分，在后面的文章中进行简单介绍。</p>
]]></content>
      
        <categories>
            
            <category> 代码作品 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> loggers </tag>
            
            <tag> python </tag>
            
            <tag> emuch </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[动力学模型代码的整体组织框架]]></title>
      <url>http://pytlab.github.io/2015/02/12/%E5%8A%A8%E5%8A%9B%E5%AD%A6%E6%A8%A1%E5%9E%8B%E4%BB%A3%E7%A0%81%E7%9A%84%E6%95%B4%E4%BD%93%E7%BB%84%E7%BB%87%E6%A1%86%E6%9E%B6/</url>
      <content type="html"><![CDATA[<p>这个动力学模型大概是在放假前一两个星期开始写的，由于我写代码的低效，今天才刚刚完成了model中的load()的部分，其中包括解析setup file中的基元反应的反应方程式以及检测方程式质量守恒以及吸附位守恒等主要功能。在这里大概记录下写这个模型的大致过程，以便以后回来方便浏览和回想思路。<br>首先是整个代码的组织框架，这个当时想了一段时间大概要怎么组织整个模型，这个还是很重要的。因为看过经典的《C Premier Plus》上面有写道：</p>
<blockquote>
<p>随着程序的变得更长更复杂，头脑中的想象就开始无能为力了，而且错误也将变得难以发现。最终，那些忽略计划步骤的人会浪费大量时间并带来混乱的挫折，因为他们编写出了难看、功能不正常而且艰深难懂的程序。工作越来越复杂，需要的计划工作量就越大。</p>
<p>这里有一句忠告，那就是应该养成在编写代码前进行规划的习惯。使用古老而可敬的笔记技术来大略记录下程序的目标，并购了出设计的样貌。如果您这样做了，最终会节省时间并感到满意。</p>
</blockquote>
<p>这学期通过上课之余的其他时间，零零碎碎的把CatMap的90%的代码看过了，大概抓住了整个模型的BIG PICTURE.由于CatMap模型的目的是进行催化剂的筛选，主要是利用BEP关系分析原始的DFT计算出的能量进行简单粗暴的线性拟合，拟合出基于两个descriptors的map，从而对于map上的每一个点进行动力学稳态求解，输出的变量主要包括coverage, rate等。对于动力学模型的学习我还是主要以了解和学习为目的的。总览这个代码，catmap充分利用了Python OO的特性把动力学模型的几个组成部分有机的组合在了一起,这是很好的，非常有利于今后的代码维护和功能的增加。在看代码的过程中，catmap给我的印象就是它过度的修改了python的内置方法，例如<code>__getattr__(), __getattribute__(), __setattr__()</code>等，这样做的目的我觉得作者是想给model这个类至高无上的”权利”, 修改前面的内置方法主要是在<code>ModelWrapper</code>类中，而这个<code>ModekWrapper</code>类是其他”工具”类的父类，在<code>ModelWrapper</code>类中修改了<code>__getattr__(), __getattribute__(), __setattr__()</code>等方法，使得其他”工具”类的属性都附给model使其成为model的属性。<br><a id="more"></a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReactionModelWrapper</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">(self,attr)</span>:</span></div><div class="line">        <span class="string">"Force use of custom getattr"</span></div><div class="line">        <span class="keyword">return</span> self.__getattr__(self,attr)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self,attr)</span>:</span></div><div class="line">        <span class="string">"Return the value of the reaction model instance if its there. Otherwise return the instances own value (or none if the instance does not have the attribute defined and the attribute is not private)"</span></div><div class="line">        <span class="keyword">if</span> attr == <span class="string">'_rxm'</span>:</div><div class="line">            <span class="keyword">return</span> object.__getattribute__(self,attr)</div><div class="line"></div><div class="line">        <span class="keyword">elif</span> hasattr(self._rxm,attr):</div><div class="line">            <span class="keyword">return</span> getattr(self._rxm,attr)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">if</span> attr <span class="keyword">in</span> self.__dict__:</div><div class="line">                val =  object.__getattribute__(self,attr)</div><div class="line">                <span class="keyword">del</span> self.__dict__[attr] </div><div class="line">                <span class="comment">#this makes sure that the attr is read from _rxm</span></div><div class="line">                setattr(self._rxm,attr,val)</div><div class="line">                <span class="keyword">return</span> val</div><div class="line">            <span class="keyword">elif</span> attr.startswith(<span class="string">'_'</span>):</div><div class="line">                <span class="keyword">raise</span> AttributeError()</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self,attr,val)</span>:</span></div><div class="line">        <span class="string">"Set attribute for the instance as well as the reaction_model instance"</span></div><div class="line">        accumulate = [<span class="string">'_required'</span>,<span class="string">'_log_strings'</span>,<span class="string">'_function_strings'</span>]</div><div class="line">        <span class="keyword">if</span> attr == <span class="string">'_rxm'</span>:</div><div class="line">            self.__dict__[attr] = val </div><div class="line">        <span class="keyword">elif</span> attr <span class="keyword">in</span> accumulate:</div><div class="line">            self._rxm.__dict__[attr].update(val)<span class="comment"># val = (k, v)</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            setattr(self._rxm,attr,val)</div></pre></td></tr></table></figure>
<p>这种关系不知道为什么作者会这么做，在后面调用的时候就出现了不知道什么原因的报错(如下图)。虽然这样使得model的组织更有灵活性，但是一定要谨慎，灵活也是有代价的。</p>
<p>由于学习动力学模型的初衷是学习python用来做科学计算，还是想自己把整个模型都自己写一遍来实现，以便达到最初的学习目的，改代码什么的这种无聊的事情自己真的做不下去。趴在地上想了会，我需要实现的功能其实是CatMap的子集，其中要设计多个表面的迁移过程，但是这种过程也不过是添加了site type的类型，在解稳态方程的时候添加了单独的表面归一条件。在解析表达式的时候将多个表面考虑进来写的更加general应该就可以了。<br>下图是我大概组织的<strong>整个代码的组织结构</strong>：<br><img src="assets/images/blog_img/2015-02-12-动力学模型代码的整体组织框架/model_uml.gif" alt="model_structure"><br>在这里我没有赋予model过于重要的地位，而是尽量将model与tools的功能分开来实现，各自完成各自的任务，通过实例化过程中初始化调用，使几个部分与主体model进行联系。同时我还单独写了个<code>logger</code>类用来生成<code>logger</code>对象记录model以及model的各个工具在运行过程中的日志文件，这样就把记录日志的任务交给了loggers来完成，这种分治的感觉还是很好的，起码是整个模型的代码清晰不让人感觉揉成一团，使用<code>set_logger()</code>方法在初始化过程中自动实例化logger，其中应用了CatMap中所谓的”BLACK MAGIC”, 说白了就是调用python内置的<code>__import__()</code>方法来import包含类的文件，并自动在执行代码的过程中实现其他文件中类的实例化(python官方文档对这个方法的介绍:<a href="https://docs.python.org/2/library/functions.html#__import__" target="_blank" rel="external">https://docs.python.org/2/library/functions.html#<strong>import</strong></a>).<br>相对于CatMap，我多加了一个table_maker用来根据model的物种信息生成setup file的表格，方便用户输入能量信息，并计算出generalized formation energy. 在这里我默认写了csv格式的table，当然还能写其他的table_maker实例。另外csv文件修改数据的话最好还是用NotePad打开修改，excel会造成数字精度损失，查看整个文件不做能容修改的话还是可以用excel打开的，有表格更容易查看整体内容信息。<br>贴上<code>set_logger()</code>的代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_logger</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    import logger and get an instance of Logger class</div><div class="line">    """</div><div class="line">    <span class="comment">#The 'BLACK MAGIC' is hacked from CatMap (catmap/model.py)</span></div><div class="line">    <span class="comment">#https://docs.python.org/2/library/functions.html#__import__</span></div><div class="line">    basepath = os.path.dirname(</div><div class="line">                inspect.getfile(inspect.currentframe()))</div><div class="line">    <span class="keyword">if</span> basepath <span class="keyword">not</span> <span class="keyword">in</span> sys.path:</div><div class="line">        sys.path.append(basepath)</div><div class="line">    <span class="comment">#from loggers import logger</span></div><div class="line">    _module = __import__(<span class="string">'loggers.logger'</span>, globals(), locals())</div><div class="line">    logger_instance = getattr(_module, <span class="string">'Logger'</span>)(owner=self)</div><div class="line">    setattr(self, <span class="string">'logger'</span>, logger_instance)</div></pre></td></tr></table></figure></p>
<p>这个方法打算在后面补充<code>load()</code>中实例化各个工具类的时候模仿CatMap的方法写，这里就大概记录下目前来讲我组织代码的结构，充分利用python OO特性方便代码维护和扩充，以便在今后在此框架的基础上添加更多的方法和工具类以完成更加复杂的动力学计算任务。还有，毕竟代码是写给人看的，不是写给计算机看的。</p>
<p><strong>2015.2.25补充：</strong><br>前几天在开始写solver之前意识到不仅仅table_maker需要依赖parser解析的数据，solver也依赖parser解析的数据，例如parse_elementary_rxns()获取基元反应的列表方便对solver物种进行分析。之前我是把load()中的set_table_maker()单独写在遍历环境变量实例化工具类的代码之前的。</p>
<blockquote>
<p>1. 还是要有一个<code>TableBase</code>类，用于生成不同的table_maker的子类。目前，这个基类主要包含一些获取于model对象中的一些变量。这些变量都是用parser解析setupfile获取的，因此若要用table_maker，必须要有parser并且对setupfile进行了正确的解析。因此在model的<code>load()</code>中一开始我是把table_maker作为和parser等工具一样通过执行setupfile后遍历局部变量的，结果在实例化parser之前先循环到了table_maker，就抛出异常了。。。因此后面我又单独写了个<code>set_table_maker()</code>方法，</p>
<p>…</p>
<p>在遍历局部变量的时候，进行了对table_maker的判断：</p>
<p>…</p>
<p>方法是获取table_maker的名称(<code>string</code>)，然后在<code>load()</code>之后通过<code>set_table_maker()</code>方法对table_maker进行实例化。<br>上面是在<a href="http://ipytlab.com/%e5%8a%a8%e5%8a%9b%e5%ad%a6%e6%a8%a1%e5%9e%8b%e5%b7%a5%e5%85%b7%e7%b1%bb-tablemaker/" title="动力学模型工具类–TableMaker" target="_blank" rel="external"><ins datetime="2015-02-25T15:49:52+00:00">动力学模型工具类–TableMaker</ins></a>中我当时写的。</p>
</blockquote>
<p>如今开始写solver的时候发现，parser应该是最优先实例化的，实例化parser以后，在用parser解析一些数据，以供后面的工具实例化的过程中使用。贴上代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#assign parser ahead to provide essential attrs for other tools</span></div><div class="line">self.set_parser(locs[<span class="string">'parser'</span>])</div><div class="line"></div><div class="line"><span class="comment">#assign other tools</span></div><div class="line"><span class="keyword">for</span> key <span class="keyword">in</span> locs.keys():</div><div class="line">    <span class="comment">#ignore tools which will be loaded later</span></div><div class="line">    <span class="keyword">if</span> key <span class="keyword">in</span> self._tools: </div><div class="line">        <span class="comment">#setattr(self, 'table_maker_name', locs[key])</span></div><div class="line">        <span class="keyword">continue</span></div><div class="line">    <span class="comment">#check type of variables</span></div><div class="line">    <span class="keyword">if</span> key <span class="keyword">in</span> self._attr_type_dict: </div><div class="line">        <span class="comment">#chech attr type</span></div><div class="line">        <span class="keyword">if</span> type(locs[key]) != self._attr_type_dict[key]:</div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                locs[key] = self._attr_type_dict[key](locs[key])</div><div class="line">                setattr(self, key, locs[key])</div><div class="line">            <span class="keyword">except</span>:</div><div class="line">                <span class="keyword">raise</span> ValueError(<span class="string">'\''</span>+key+<span class="string">'\' is in wrong type. '</span></div><div class="line">					+ str(self._attr_type_dict[key])</div><div class="line">					+ <span class="string">' object is expected.'</span>)</div><div class="line">        setattr(self, key, locs[key])</div><div class="line"></div><div class="line"><span class="comment">#use parser parse essential attrs for other tools</span></div><div class="line"><span class="comment">#parse elementary rxns</span></div><div class="line"><span class="keyword">if</span> self.rxn_expressions:</div><div class="line">    self.parser.parse_elementary_rxns(self.rxn_expressions)</div><div class="line">    <span class="comment">#get total rxn equation</span></div><div class="line"><span class="keyword">if</span> self.elementary_rxns_list:</div><div class="line">    self.parser.get_total_rxn_equation(self.elementary_rxns_list)</div></pre></td></tr></table></figure></p>
<p>在这里为了能使_tools中的属性在最后添加到对象中，我把工具类属性的赋值放在了其他属性赋值的后面，就这样分隔了开来。<br>遍历局部变量实例化工具类的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#load tools of model</span></div><div class="line"><span class="keyword">for</span> key <span class="keyword">in</span> self._tools:</div><div class="line">    <span class="comment">#black magic to auto-import classes</span></div><div class="line">    <span class="comment">#HACKED from CatMap</span></div><div class="line">    <span class="keyword">if</span> key == <span class="string">'parser'</span>: <span class="comment">#ignore parser loaded before</span></div><div class="line">        <span class="keyword">continue</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            <span class="keyword">if</span> locs[key]:</div><div class="line">                <span class="keyword">if</span> <span class="keyword">not</span> key.endswith(<span class="string">'s'</span>):</div><div class="line">                    pyfile = key + <span class="string">'s'</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    pyfile = key</div><div class="line">                basepath=os.path.dirname(</div><div class="line">                         inspect.getfile(inspect.currentframe()))</div><div class="line">                <span class="keyword">if</span> basepath <span class="keyword">not</span> <span class="keyword">in</span> sys.path: </div><div class="line">                        sys.path.append(basepath)</div><div class="line">                sublocs = &#123;&#125;</div><div class="line">                _temp = \</div><div class="line">                    __import__(pyfile, globals(), sublocs, [locs[key]])  </div><div class="line">                tool_instance = getattr(_temp, locs[key])(owner=self) </div><div class="line">                setattr(self, key, tool_instance)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                setattr(self, key, <span class="keyword">None</span>)</div><div class="line">        <span class="keyword">except</span> ImportError:</div><div class="line">            <span class="keyword">raise</span> AttributeError(key.capitalize()+<span class="string">' '</span>+locs[key]+\</div><div class="line">                    <span class="string">' could not be imported. Ensure that the class '</span>+\</div><div class="line">                    <span class="string">'exists and is spelled properly.'</span>)</div><div class="line">        <span class="comment">#HACK END</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 学术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> kinetic model </tag>
            
            <tag> kinetics </tag>
            
            <tag> Kynetix </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[What does if __name__ == '__main__'  do ?]]></title>
      <url>http://pytlab.github.io/2015/02/10/what-does-if-name-main-do/</url>
      <content type="html"><![CDATA[<p>在python经常能看到<code>if __name__ == &#39;__main__: &#39;</code>这一判断句，而且双下划线就意味着是内置的变量。那这句话到底有什么作用？去stackoverflow上搜了下看到一个不错的回答<a href="http://http://stackoverflow.com/questions/419163/what-does-if-name-main-do" title="python - What does `if __name__ == &quot;__main__&quot;:` do? - Stack Overflow" target="_blank" rel="external">[python - What does <code>if __name__ == &amp;quot;__main__&amp;quot;:</code> do? - Stack Overflow]</a>，这个判断句的作用也就了解了。<br>我大致的理解：<br>当python的解释器读取一个源文件的时候，解释器会在真正执行代码之前把文件中的代码执行一遍。在这个过程中，解释器会定义一些特殊的内部变量。例如，解释器直接运行该代码的时候会定义变量<code>__name__</code>，并把值<code>&#39;__main__&#39;</code>赋给它;相反，如果，这个代码正在被另一个python程序<code>import</code>的时候，那么解释器就会把<code>__name__</code>这个变量的值赋成代码文件本身的名字’<strong>‘(代码文件名为: </strong>.py)。</p>
<a id="more"></a>
<p>写了几行测试代码，大概解释一下：<br>文件名: test<strong>name</strong>.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys <span class="comment">#just for explaining the process</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="string">"test"</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> __name__</div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">"run me"</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'test__name__'</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">"import me"</span></div></pre></td></tr></table></figure>
<p>当在shell中执行python test.py的时候，解释器设置一些特殊的变量，例如<code>__name__ == &#39;__main__&#39;</code>.之后，他会导入<code>sys</code>模块，在之后会读取<code>def</code>函数块，创建一个函数object，并创建一个名为’test’的变量引用这个函数object. 在之后会读if语句，好了，关键到了，由于现在是直接在命令行python test.py, 这时<code>__name__ == &#39;test__name__&#39;</code>的返回值为<code>True</code>，那自然会执行<code>print &quot;run me&quot;</code>. 另一种情况，就是我在命令行执行<code>import test__name__</code>, 在读取if语句之前的过程和之前相同，读到if语句的时候会进行判断，这个时候由于我不是直接执行代码，而是把文件当作模块导入，解释器附给变量’<code>__name__</code>‘的值不再是<code>&#39;__main__&#39;</code>了而是文件的名字<code>&#39;test__name__&#39;</code>, 便会执行<code>print &quot;import me&quot;</code>.</p>
<p>执行结果:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">4</span>]: run test__name__.py</div><div class="line">__main__</div><div class="line">run me</div><div class="line"></div><div class="line">In [<span class="number">5</span>]: <span class="keyword">import</span> test__name__</div><div class="line">test__name__</div><div class="line"><span class="keyword">import</span> me</div></pre></td></tr></table></figure></p>
<p>这一语句有什么作用? 其中一个作用就是当导入代码的时候我们很多时候并不想执行某些语句，有时候有些print语句会在命令行显示出来，这样这条判断句就可以导入代码的时候不执行某些语句。<br>回答里的原话:</p>
<blockquote>
<p>One of the reasons for doing this is that sometimes you write a module (a .py file) where it can be executed directly. Alternatively, it can also be imported and used in another module. By doing the main check, you can have that code only execute when you want to run the module as a program and not have it execute when someone just wants to import your module and call your functions themselves.</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用PyUnit framework写单元测试]]></title>
      <url>http://pytlab.github.io/2015/02/10/%E5%88%A9%E7%94%A8PyUnit%20framework%E5%86%99%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>以前写代码没有意识到单元测试的重要性。直到project的规模慢慢变大的时候，或者当把程序给别人使用抛出exception，自己着急要解决问题的时候才意识到提前写好unit test是很重要的(我理解的对么??)。于是慢慢的我也开始写unit test了。今天就看了下python的document上面介绍PyUnit的部分，简单的学习了一下利用PyUnit写单元测试脚本。<br>关于unit test,</p>
<blockquote>
<p>在计算机编程中，单元测试（又称为模块测试, Unit Testing）是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。</p>
<p>通常来说，程序员每修改一次程序就会进行最少一次单元测试，在编写程序的过程中前后很可能要进行多次单元测试，以证实程序达到软件规格书要求的工作目标，没有程序错误；虽然单元测试不是什么必须的，但也不坏，这牵涉到项目管理的政策决定。<br><a id="more"></a></p>
</blockquote>
<p>python内部自带了一个单元测试的模块，PyUnit也就是我们说的：unittest. Official Doc上关于PyUnit的介绍: </p>
<blockquote>
<p>The Python unit testing framework, sometimes referred to as “PyUnit,” is a Python language version of JUnit, by Kent Beck and Erich Gamma. JUnit is, in turn, a Java version of Kent’s Smalltalk testing framework. Each is the de facto standard unit testing framework for its respective language.</p>
<p>unittest supports test automation, sharing of setup and shutdown code for tests, aggregation of tests into collections, and independence of the tests from the reporting framework. The unittest module provides classes that make it easy to support these qualities for a set of tests.</p>
<p>To achieve this, unittest supports some important concepts:</p>
<p><strong>test fixture</strong></p>
<p>A test fixture represents the preparation needed to perform one or more tests, and any associate cleanup actions. This may involve, for example, creating temporary or proxy databases, directories, or starting a server process.</p>
<p><strong>test case</strong></p>
<p>A test case is the smallest unit of testing. It checks for a specific response to a particular set of inputs. unittest provides a base class, TestCase, which may be used to create new test cases.</p>
<p><strong>test suite</strong></p>
<p>A test suite is a collection of test cases, test suites, or both. It is used to aggregate tests that should be executed together.</p>
<p><strong>test runner</strong></p>
<p>A test runner is a component which orchestrates the execution of tests and provides the outcome to the user. The runner may use a graphical interface, a textual interface, or return a special value to indicate the results of executing the tests.<br>由于是初次使用PyUnit框架写单元测试脚本，我还是用了简单的测试用例(test case),用了之后才发现，诶！不错～<br>unittest的简单使用，大概分以下几个方面：</p>
</blockquote>
<p>下面是unittest模块的常用方法：</p>
<p>今天就用unittest为model的load()方法解析化学方程式写了单元测试，感觉爽爽的(๑&gt;◡&lt;๑) ,贴上代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> unittest</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestKineticModel</span><span class="params">(unittest.TestCase)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment">#create an instance of KineticModel</span></div><div class="line">        sys.path.append(<span class="string">'E:\BaiduYun\MyDocuments\ECUST+\Python\script'</span>)</div><div class="line">        <span class="keyword">from</span> kinetic <span class="keyword">import</span> model</div><div class="line">        self.km = model.KineticModel(setup_file=<span class="string">'methanation.mkm'</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_set_logger</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"make sure set_logger method takes effects"</span></div><div class="line">        self.assertTrue(hasattr(self.km, <span class="string">'logger'</span>))</div><div class="line"></div><div class="line">        <span class="comment">#should raise an exception for an AttributeError</span></div><div class="line">        self.assertRaises(AttributeError)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_load</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""test the load() method has loaded variables</span></div><div class="line">        in setup file into model as attrs of it"""</div><div class="line"></div><div class="line">        <span class="comment">#make sure all vars in setup file are parsed in</span></div><div class="line">        globs, locs = &#123;&#125;, &#123;&#125;</div><div class="line">        execfile(self.km.setup_file, globs, locs)</div><div class="line">        <span class="keyword">for</span> var <span class="keyword">in</span> locs:</div><div class="line">            self.assertTrue(hasattr(self.km, var))</div><div class="line">            self.assertRaises(AttributeError)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_parse_site_expression</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"make sure site can be parsed successfully"</span></div><div class="line">        site_expression = <span class="string">'3*_s'</span></div><div class="line">        site_dict = self.km.parse_site_expression(site_expression)</div><div class="line">        target_dict = &#123;<span class="string">'s'</span>: &#123;<span class="string">'number'</span>: <span class="number">3</span>, <span class="string">'type'</span>: <span class="string">'s'</span>&#125;&#125;</div><div class="line">        self.assertDictEqual(target_dict, site_dict)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_parse_species_expression</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"make sure species expression e.g. '2CH3_s' can be parsed successfully"</span></div><div class="line"></div><div class="line">        <span class="comment">#test adsorbate</span></div><div class="line">        adsorbate_expression = <span class="string">'2CH3_s'</span></div><div class="line">        adsorbate_dict = \</div><div class="line">                self.km.parse_species_expression(adsorbate_expression)</div><div class="line">        target_adsorbate_dict = &#123;<span class="string">'CH3_s'</span>: &#123;<span class="string">'number'</span>: <span class="number">2</span>, </div><div class="line">                                 <span class="string">'site'</span>: <span class="string">'s'</span>, </div><div class="line">                                 <span class="string">'elements'</span>: &#123;<span class="string">'C'</span>: <span class="number">1</span>, <span class="string">'H'</span>: <span class="number">3</span>&#125;&#125;&#125;</div><div class="line">        self.assertDictEqual(adsorbate_dict, target_adsorbate_dict)</div><div class="line"></div><div class="line">        <span class="comment">#test transition state</span></div><div class="line">        ts_expression = <span class="string">'3CH2-H_s'</span></div><div class="line">        ts_dict = self.km.parse_species_expression(ts_expression)</div><div class="line">        target_ts_dict = &#123;<span class="string">'CH2-H_s'</span>: &#123;<span class="string">'number'</span>: <span class="number">3</span>, </div><div class="line">                                      <span class="string">'site'</span>: <span class="string">'s'</span>, </div><div class="line">                                      <span class="string">'elements'</span>: &#123;<span class="string">'C'</span>: <span class="number">1</span>, <span class="string">'H'</span>: <span class="number">3</span>&#125;&#125;&#125;</div><div class="line">        self.assertDictEqual(ts_dict, target_ts_dict)</div><div class="line"></div><div class="line"><span class="comment">#if __name__ == '__main__':</span></div><div class="line"><span class="comment">#    unittest.main()</span></div><div class="line">suite = unittest.TestLoader().loadTestsFromTestCase(TestKineticModel)</div><div class="line">unittest.TextTestRunner(verbosity=<span class="number">2</span>).run(suite)</div></pre></td></tr></table></figure></p>
<p>运行脚本后可以显示每个case的测试结果，以及测试消耗时间。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">2</span>]: run model_test.py</div><div class="line">test_load (__main__.TestKineticModel)</div><div class="line">test the load() method has loaded variables ... ok</div><div class="line">test_parse_site_expression (__main__.TestKineticModel)</div><div class="line">make sure site can be parsed successfully ... ok</div><div class="line">test_parse_species_expression (__main__.TestKineticModel)</div><div class="line">make sure species expression e.g. <span class="string">'2CH3_s'</span> can be parsed successfully ... ok</div><div class="line">test_set_logger (__main__.TestKineticModel)</div><div class="line">make sure set_logger method takes effects ... ok</div><div class="line"></div><div class="line">----------------------------------------------------------------------</div><div class="line">Ran <span class="number">4</span> tests <span class="keyword">in</span> <span class="number">0.013</span>s</div><div class="line"></div><div class="line">OK</div></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> python </tag>
            
            <tag> unittest </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[自动登陆华理校园网的python脚本]]></title>
      <url>http://pytlab.github.io/2015/02/08/%E8%87%AA%E5%8A%A8%E7%99%BB%E9%99%86%E5%8D%8E%E7%90%86%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84python%E8%84%9A%E6%9C%AC/</url>
      <content type="html"><![CDATA[<p>前段时间实验室的校园网总是被挤掉，虽然没用python写过爬虫，但是这也是契机来学习一下标准库里的<code>urllib,      urllib2, cookielib</code>等这些类似的Lib.于是就着手开始写了个自动检测网络连接，并自动连接校园网的python脚本(<a href="https://github.com/PytLab/loggers" title="loggers" target="_blank" rel="external">loggers|GitHub</a>)，便于以后进行扩  展，分别写了两个类, 一个<code>class LoggerBase</code>, 一个子类<code>class EcustLogger(LoggerBase)</code>其中的代码风格模仿了这学期看的一个叫<a href="https://github.com/ajmedford/catmap" title="catmap" target="_blank" rel="external">CatMap|GitHub</a>的<code>Micro Kinetic Model</code>的风格，从其中学习了利用字典数据类型进行脚本日志的生成等， 例如<br>    <strong>日志记录</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(self, event, **kwargs)</span>:</span></div><div class="line">    <span class="string">"append log info into log file"</span></div><div class="line">    file_obj = open(self.log_file,<span class="string">'a'</span>)</div><div class="line">    <span class="comment">#append new log infomation</span></div><div class="line">    message_template = Template(self._log_str[event])</div><div class="line">    message = message_template.substitute(kwargs)</div><div class="line">    append_ctnt = self._log_format % (message, <span class="string">'['</span>+time.ctime()+<span class="string">']'</span>)</div><div class="line">    file_obj.write(append_ctnt)</div><div class="line">    file_obj.close()</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>其中日志的<code>log_str</code>如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">self._log_str = &#123;</div><div class="line">	<span class="string">'match_file_fail'</span> : <span class="string">'No file link in \'$&#123;url&#125;\''</span>,</div><div class="line">	<span class="string">'suffix_unmatch:'</span> : (<span class="string">'Warning: unmatched suffix : \'$&#123;suffix_1&#125;\' and '</span></div><div class="line">			       <span class="string">'\'$&#123;suffix_2&#125;\'	,force to change to \'$&#123;suffix_2&#125;\''</span>),</div><div class="line">	<span class="string">'illegal_path'</span>    : <span class="string">'illegal_path : $&#123;illegal_path&#125;'</span>,</div><div class="line">	<span class="string">'download_fail'</span>   : <span class="string">'$&#123;filename&#125; download overtime'</span>,</div><div class="line">	<span class="string">'download_times'</span>  : <span class="string">'$&#123;filename&#125; download time:$&#123;times&#125; '</span>,</div><div class="line">	<span class="string">'download_time'</span>   : <span class="string">'$&#123;filename&#125; download time used : $&#123;time_pass&#125;s '</span></div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>这种生成日志的原理就是利用dict存固定格式的log语句，然后利用<code>re</code>模块的<code>substitute</code>方法替换其中的可变的字符串，然后写个<code>log()</code>方法吧字符串append到日志文件中。</p>
<p>脚本原理还是很简单的，就是不断的想处理表单的程序发送请求，获取返回信息。由于本人对于网站的学习只学习了一点点皮毛，看到学校的校园网登陆的html代码发现处理表单的是一个cgi脚本，不是我以前写网站的时候直接用一个php页面来处理(这里我不是太懂，望轻喷)。<br><strong>主要登陆的方法：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_login</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="comment">#set cookie</span></div><div class="line">    cj = cookielib.CookieJar()</div><div class="line"></div><div class="line">    url_login = self.url_login</div><div class="line">    form_data = self.form_data_dict</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            opener=urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))</div><div class="line">            urllib2.install_opener(opener)</div><div class="line">            req=urllib2.Request(url_login,urllib.urlencode(form_data))</div><div class="line">            u=urllib2.urlopen(req)</div><div class="line">            <span class="keyword">return</span> u.read().decode(<span class="string">'utf-8'</span>).encode(<span class="string">'gbk'</span>)</div><div class="line">        <span class="keyword">except</span>:</div><div class="line">            <span class="keyword">print</span> <span class="string">"Ooops! Failed to log in !&gt;_&lt; there may be a problem."</span></div><div class="line">            <span class="keyword">return</span></div></pre></td></tr></table></figure>
<p>首先先设置cookie，获取表单信息，向表单处理cgi发送request，华理的表单处理cgi在 <a href="http://172.20.13.100/cgi-bin/srun_portal" target="_blank" rel="external">http://172.20.13.100/cgi-bin/srun_portal</a> 上。最后用<code>urllib2.urlopen()</code>抓取页面信息，转码并返回。</p>
<p><strong>检测网络连接</strong></p>
<p>检测网络连接就是用ping命令了，用python的subprocess module的call函数。我分别选择了华理校园网登录页面，百度，和微博三个进行检测。<br>网络连接一共分为四种情况：</p>
<ul>
<li>3个网址都无法ping通: 那就return ‘connect2none’</li>
<li>能ping通登录首页，无法登录其他两个网站: 这就是指连接了校园网还没有登录校园网的情况。</li>
<li>三个网站都能ping通:<br>这个要进一步分析是否是没有登录校园网，以为在测试脚本的时候，会发现，即使用户没有登录校园网账号，ping外网还是能ping通，不知道这个是什么原因了，囧。那我 就尝试获取页面的title的方法看是不是相同来判断是否已登录校园网。单独在LoggerBase里面写了个获取title的方法：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page_title</span><span class="params">(self, url)</span>:</span></div><div class="line">    page_ctnt = urllib2.urlopen(url).read()</div><div class="line">    match = re.search(<span class="string">r'(&lt;title&gt;)(.*)(&lt;/title&gt;)'</span>,page_ctnt)</div><div class="line">    <span class="keyword">return</span> match.group(<span class="number">2</span>) <span class="comment">#title</span></div></pre></td></tr></table></figure>
<p>如果获取的title相同，那说明指连接到了校园网不能连接到外网。如果都不同，外网就已经连接上了。*   能连接到校园网而且能够连接到其他两个任意一个:</p>
<p>最终不知道为什么对于1m和4m的区分区别不开，opt选项无论是1还是2，登陆页面都显示已登陆，但是还是连不上外网。其中一些其他的form中的参数我也搞不懂是做什么的，就直接硬上了。。。最终脚本对于4m账号的有限连接有效，对于1m以及无线连接无效(´-ι_-｀)。</p>
]]></content>
      
        <categories>
            
            <category> 代码作品 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ecust </tag>
            
            <tag> loggers </tag>
            
            <tag> python </tag>
            
            <tag> 校园网 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://pytlab.github.io/2015/02/08/hello-world-2/</url>
      <content type="html"><![CDATA[<p>这是我的博客新家，在这里和大家分享自己的学习过程中的经验和见解(ง •̀_•́)ง</p>
<p>–PytLab</p>
]]></content>
      
        
    </entry>
    
  
  
</search>
