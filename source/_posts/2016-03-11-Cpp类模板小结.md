---
title: C++类模板小结
date: 2016-03-11 10:39:20
tags:
  - Cpp
categories:
  - 学习小结
description: "在这里就只总结下关于类模板具体化"
toc: true
---

之前有总结过C++的[**函数模板具体化**](../../../2016/02/05/Cpp函数模板小结/)，里面按照隐式实例化、显式实例化和显式具体化来总结的。
类似函数模板的具体化，类模板具体化除了上面三种具体化方式还有一种叫部分具体化，下面简单总结下：

### 隐式实例化
这是最常使用的类模板实例化的方式，在`<>`中指出对象所需的类型，编译器使用通用模板提供的方式生成具体的类定义，编译器在程序需要对象之前不会隐式实例化生成类的具体定义的。
``` Cpp
ArrayTP<int, 10> stuff;  // 编译器使用参数int和10生成类定义然后生成对象并命名为stuff
```
<!-- more -->

### 显式实例化
显式实例化还是针对的**类定义的生成**，相当于不要编译器决定生成什么类型的类而是由人强制让编译器给我生成一个类定义，使用方式：
``` Cpp
template class ArrayTP<string, 100>;  // 生成一个ArrayTP<string, 100>类定义
```

### 显式具体化
我还是喜欢把它称为特殊化，他并不是个通用模板而是针对某一类型参数专门写的一个模板，因为特定的类型可能的处理方式（或者说行为）并不相同。以为还是一个模板一次还是需要`<>`符号的。
``` Cpp
template <> class SortedArray<const char *>
{
    ...
}
```
其实我在想，这个直接定义一个`cosnt char *`类型的类有啥区别呢？

### 部分具体化
C++还允许部分具体化(partial specialization)，及部分限制模板的通用性，例如，部分具体化可以给类型参数之一制定具体的类型：
``` Cpp
// 通用模板
template <class T1, class T2> class Pair {...};
// 将类型T2进行部分具体化
template <class T1> class Pair<T1, int> {...};
```
这里其实就相当于把要具体化的类型参数移到后面的尖括号中，若全部移过去就相当于第3条中的显式具体化了。
``` Cpp
template <> class Pair<int, int> {...};  // 这就是一个显式具体化了
```
这样部分具体化出来的还是一个模板，因为他不是实例化。
