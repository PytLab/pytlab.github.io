---
title: C Notes -- 保护数组内容
tags:
  - C
  - Notes
categories:
  - 学习小结
date: 2015-04-09 16:07:14
---

在C语言中，函数处理数组的时候，传递的是指向数组的指针。被调用函数接受数组指针后通过指针对数组进行操作，但是这样很容易不小心修改了数组本身的数值。这时候，利用const修饰符可以做到保护数组内容的效果。
```
int sum(const int ar[], int n) /*函数原型*/
```
这个原型声明是告诉编译器，函数应当吧ar所指向的数组作为一个包含常量数据的数组对待，也就是指针ar是一个常量指针(指向常量的指针)。

之所以在这里记录下这个是用来区分下普通指针和常量指针。
`const`关键字可以创建数组常量，指针常量，指向常量的指针。
指针：
* 普通指针，指向变量的指针

* 常量指针，指向常量的指针

**常量指针可以指向常量和变量，而且被指向的变量的值不能修改；
变量指针只能指向变量。**

<!-- more -->

自己写了个小函数大概测试了下：
``` C
#include <stdio.h>

int main(void)
{
	int arv[5] = {10, 20, 30, 40, 50};
	const int arc[5] = {10, 20, 30, 40, 50};
	int * pv1, * pv2;  //普通指针
	const int * pc1, * pc2;  //常量指针

	pv1 = arv; //普通指针指向非常量数组首地址
	pc1 = arv; //常量指针指向非常量数组首地址

	//尝试改变被指向的数值
	printf("ordinary pointer: \n");
	printf("before: %d\n", *pv1);
	*pv1 += 1;
	printf("after: %d\n", *pv1);

	printf("const pointer: \n");
	printf("before: %d\n", *pc1);
	*pc1 += 1;  //不能改变常量指针指向的数值，即使被指向的不是常量
	            //把常量指针指向的变量当成常量来对待
	printf("after: %d\n", *pc1);

	pv2 = arc;  //普通指针指向常量数组的首地址，不允许
	pc2 = arc;  //常量指针指向常量数组的首地址，允许
    return 0;
}
```
NB的VS在没编译前就提示了：
![](VS.gif)
------------------------------
以上均个人理解，不一定正确
